desc: LiveBeatRepeater
author: brumbear
version: 1.12
changelog:
  - 3 different loop fade algorithms selectable by user
  - Updated Fx routing options
  - Added loop start, loop end and playhead indicators (cannot be manipulated yet)
  - Improve memory management
  - Fixed bug during loop fade out when reversing
link: Forum thread https://forum.cockos.com/showthread.php?t=211834
about:
  # LiveBeatRepeater

  JSFX for live performance stutter effects. Zero latency. Synchronized (sample accurate!) to project tempo and time signature. Works well with linear songs as well as loop based material. Mashes up nicely your rhythms on drum tracks/percussion. Great toy on voices.

  What makes this fx different from the classical looper or "instant" samplers is the fact that it constantly samples the input and repeats what you just heard when you trigger the repeat mode. I.e. you do not have to trigger recording a loop blindly hoping it will be what you want, but you repeat what was just played.

  Most fun if controlled via a MIDI/OSC hardware device (pad controller, touch screen device). E.g. Repeat On-Off to a pad, continuous Loop Length to a rotary encoder (relative mode) and stepped Loop Length to dedicated pads (one for each loop length).

  Separate loop audio routing allows to feed the repeating loop into any custom fx chain. Resonant HP/LP filters with variable cut off frequency, ping pong delays, distortion etc work particularly well with the stutter and allow spontaneous live (or automated) build ups.

// This effect Copyright (C) 2018 and later Pacific Peaks Studio
// License: GPLv3 - http://www.gnu.org/licenses/gpl
// desc: LiveBeatRepeater (brumbear@pacific_peaks)
// author: brumbear @ pacific peaks
// 2020-09-30: Release V1.12


//------------------------------------------------------------------------------------------------
slider1:SL_repeat=0<0,1,1{Off,On}>Repeat
slider2:SL_direction=0<0,1,1{Forward,Reverse}>Direction
slider3:SL_loop_length_STP=5<0,13,1{2,1,1T(=2/3),1/2,1/2T(=1/3),1/4,1/4T(=1/6),1/8,1/8T(=1/12),1/16,1/16T(=1/24),1/32, 1/64, 1/128}>Loop Length [bars] (Stepped Mode)
// Continuous Loop Length will be reset to closest stepped Loop Length when Repeat is switched from ON to OFF unless Transition is set to "Immediately"
slider4:SL_loop_length_CTN=48<0,128,0.1>Loop Length (Continuous Mode)
slider5:SL_pointer_start=0<-2,0,0.01>Loop Start Pos [bar]
slider6:SL_pointer_read=0<-2,0,0.01>Loop Playhead
slider7:SL_pointer_end=0<-2,0,0.01>Loop End Pos [bar]

slider10:SL_loop_start=1<0,3,1{Immediately,At Next Beat,At Next Bar}>Loop Start Trigger
slider11:SL_infade_algo=2<0,2,1{Extrapolated Slope,Reverse Crossfade,Padded Reverse Crossfade}>Loop Fade-In Algorithm
slider12:SL_infade_time=20<10,100,1>Loop Fade-In Time [ms]
slider13:SL_length_transitions=2<0,2,1{Immediately/Continuous,At Next Beat (Stepped Mode),At Loop End (Stepped Mode)}>Length Transitions
slider14:SL_repeat_ending=1<0,1,1{Immediately,Soft Fade Out}>Repeat Ending  

slider20:SL_fx_routing=0<0,2,1{Main=Combined / Fx=Loop only,Main=Muted when looping / Fx=Loop only,Main=Input passthrough / Fx =Loop only}>Fx Channel Routing

in_pin:Input left
in_pin:Input right
out_pin:Main output left
out_pin:Main output right
out_pin:Fx loop output left
out_pin:Fx loop output right


//===========================================================================================================
//===========================================================================================================
@init

log2 = log(2);

function loop_length_SL_loop_length_STP(n) // returns the inverse of the fractional loop length of a bar (e.g. 4 for 1/4bar), see values for SL_loop_length_STP
(
 n == 0 ? 0.5 // SL_loop_length_CTN = 0
 : n == 1 ? 1 // SL_loop_length_CTN = 16
  : n == 2 ? 1.5 // SL_loop_length_CTN = 25.36
   : n == 3 ? 2 // SL_loop_length_CTN = 32
    : n == 4 ? 3 // etc... calculation as per below function SL_loop_length_CTN_from_SL_loop_length_STP
     : n == 5 ? 4 
      : n == 6 ? 6
       : n == 7 ? 8 
        : n == 8 ? 12
         : n == 9 ? 16 
          : n == 10 ? 24
           : n == 11 ? 32 
            : n == 12 ? 64 
             : n == 13 ? 128 // 128
             : 0;
);

function SL_loop_length_CTN_from_SL_loop_length_STP(x) 
// calculate the exact value for continuous loop length with double float precision
// the exact value of slider 3 will later be used to calculated the loop size [samples]
(
 (log(loop_length_SL_loop_length_STP(x))/log2 + 1) * 16;
);


function Nearest_Loop_Length(i) // aka "SL_loop_length_STP_from_SL_loop_length_CTN", returns SL_loop_length_STP index from SL_loop_length_CTN value
(
 i <= 8 ? 0 // midpoint between SL_loop_length_CTN = 0 and SL_loop_length_CTN = 16
 : i <= 20.68 ? 1 //  midpoint between SL_loop_length_CTN = 16 and SL_loop_length_CTN = 25.36
  : i <= 28.68 ? 2 // etc...
   : i <= 36.68 ? 3
    : i <= 44.68 ? 4
     : i <= 52.68 ? 5  
      : i <= 60.68 ? 6
       : i <= 68.68 ? 7
        : i <= 76.68 ? 8
         : i <= 84.68 ? 9
          : i <= 92.68 ? 10
           : i <= 104 ? 11
            : i <= 120 ? 12
           : 13;
);

function Write_Tail(left,right)
(
  tail_pos_WRITE += 1; tail_pos_WRITE >= tailbuf_size ? tail_pos_WRITE = 0;
  tail0[tail_pos_WRITE] = left;
  tail1[tail_pos_WRITE] = right;
);

function Update_Tail()
(
  SL_infade_algo == 2 ? (
    // Padding
    m_L = last_spl_played_L - llast_spl_played_L;
    m_R = last_spl_played_R - llast_spl_played_R;
    pad0_L = last_spl_played_L + 0.75 * m_L; pad0_R = last_spl_played_R + 0.75 * m_R;
    Write_Tail(pad0_L,pad0_R);
    pad1_L = pad0_L + 0.5 * m_L; pad1_R = pad0_R + 0.5 * m_R;
    Write_Tail(pad1_L,pad1_R);
    pad2_L = pad1_L + 0.25 * m_L; pad2_R = pad1_R + 0.25 * m_R;
    Write_Tail(pad2_L,pad2_R);
    Write_Tail(pad1_L,pad1_R);
    Write_Tail(pad0_L,pad0_R);
  );
  tail_pos_READ = tail_pos_WRITE;
);

function Update_Pointers()
local(offset)
(
  // TODO: reference to loop_end_freeze and scale to 2*samples per bar
  offset = loop_end_freeze - loop_start + 1; offset < 0 ? offset += buf_size; 
  SL_pointer_start =  -offset/samples_per_bar;
  
  offset = loop_end_freeze - loop_end; offset < 0 ? offset += buf_size;
  SL_pointer_end =  -offset/samples_per_bar;
  
  offset = loop_end_freeze - loop_pos_READ; offset < 0 ? offset += buf_size;
  SL_pointer_read = -offset/samples_per_bar;
);

//------------------------------------------------------------------------------------------------
// need some defaults when sliders have not been touched yet, no playback or just input monitoring
// default is only used to claim & clean indexed memory for buffer area. Will be updated with actual values.
default_srate = 96000;
default_samples_per_bar = default_srate * 2; // assuming 120bpm, 4/4 signature
samples_per_bar = default_samples_per_bar;

// Loop fade-in algorithm variables
default_infade_time = 0.1; // maximum fade-in time in seconds
infade_size = floor(default_srate*default_infade_time + 0.5);
infade_relative_pos = 0;
slope_factor = 0.7;
max_slope = 0.13;
last_spl_played_L = 0;
last_spl_played_R = 0;
llast_spl_played_L = 0;
llast_spl_played_R = 0;
next_spl_extrap_L = 0;
next_spl_extrap_R = 0;

// create a buffer hosting 2 sections: track ring buffer and loop copy buffer
buf_size = 5 * samples_per_bar; //track ring buffer has to be > 2x max loop length sample
buf0 = 0; buf1 = buf0 + buf_size; // Start address pointers
buf_pos_WRITE = 0; // position in track ring buffer that is being filled with current track samples
loop_copy_offset = 2 * buf_size; // buf0[loop_copy_offset + pos] and buf1[loop_copy_offset + pos] store a copy of the max length loop portion from track ring buffer.
loop_pos_COPY = 0; // position that gets copied from track ring buffer to loop copy buffer
loop_copied = 0; // flag to indicate that the max length loop portion (= 2 bars) has been fully copied
memset(buf0, 0, 4 * buf_size); // The total size to this point is : buf0 .. buf1+loop_copy_offset+buf_size = 4 * buf_size 

// create tail buffer to store last played samples
tailbuf_size = 3 * infade_size; // greater than 2 * infade_size + padding samples
tail0 = buf0 + 4 * buf_size; tail1 = tail0 + tailbuf_size; // Start address pointers. Tail buffer starts right after track ring and loop copy buffer
tail_pos_WRITE = 0;
tail_pos_READ = 0;
memset(tail0, 0, 2 * tailbuf_size);

loop_size = 0; // repeat loop length. E.g. loop_size = 10, loop_start = 0 => loop_end = 9
loop_start = 0; // start position of loop within track ring buffer
loop_end = buf_size - 1; // end position of loop within track ring buffer. Frozen when repeat mode is switched on. loop_end contains the last sample of the loop.
loop_end_freeze = loop_end;
loop_overflow = 0; // flag to indicate if loop stretches beyond buffer end, i.e. loop_end < loop_start
loop_pos_READ = 0; // position in buffer that will be played back when repeat is on
loop_trigger_beat_pos = 0;
play_loop = 0;

next_loop_start = 0; 
next_loop_overflow = 0;
next_loop_trigger_beat_pos = 0;

last_SL_repeat = 0;
last_SL_loop_length_STP = 5;
last_SL_loop_length_CTN = 48;

immediate_transition_override = 0; // flag to indicate if we are in Continuos Mode (NOT discrete loop length)


//===========================================================================================================
//===========================================================================================================
@slider
// synchronize loop length sliders
(last_SL_loop_length_CTN != SL_loop_length_CTN) && (last_SL_loop_length_STP == SL_loop_length_STP) ? (
  SL_loop_length_STP = Nearest_Loop_Length(SL_loop_length_CTN);
  last_SL_loop_length_STP = SL_loop_length_STP;
  last_SL_loop_length_CTN = SL_loop_length_CTN;
  immediate_transition_override = 1;
):(
  last_SL_loop_length_STP != SL_loop_length_STP ? (
    SL_loop_length_CTN = SL_loop_length_CTN_from_SL_loop_length_STP(SL_loop_length_STP);
    last_SL_loop_length_STP = SL_loop_length_STP;
    last_SL_loop_length_CTN = SL_loop_length_CTN;
    immediate_transition_override = 0;
  );  
);    

// adjust the loop fade-in time
infade_size = floor(srate*SL_infade_time/1000 + 0.5);

// adjust loop start position when loop length changes
loop_size = floor(samples_per_bar /(2^(SL_loop_length_CTN/16-1)) + 0.5);
(SL_length_transitions == 1) && (immediate_transition_override == 0) ? (
  // loop start point may only be updated at next beat
  next_loop_trigger_beat_pos = floor(beat_position + 1);
  next_loop_start = loop_end - (loop_size - 1);
  next_loop_start <0 ? (next_loop_start += buf_size; next_loop_overflow = 1;) : (next_loop_overflow = 0);
):(
  // update the loop start position
  loop_start = loop_end - (loop_size - 1);
  loop_start <0 ? (loop_start += buf_size; loop_overflow = 1;) : (loop_overflow = 0);
);

// check if repeat switched to ON
SL_repeat > last_SL_repeat ? (
  SL_loop_start == 0 ? loop_trigger_beat_pos = beat_position 
    : SL_loop_start == 1 ? loop_trigger_beat_pos = floor(beat_position + 1)
      : loop_trigger_beat_pos = (floor(beat_position/ts_num) + 1) * ts_num 
); 
// check if repeat switched to OFF
SL_repeat < last_SL_repeat ? (
  play_loop = 0; 
  immediate_transition_override = 0;
  SL_length_transitions != 0 ? (
    // revert back to Stepped Mode and set slider 3 to closest stepped length unless transition was set to "Immediately"
    SL_loop_length_CTN = SL_loop_length_CTN_from_SL_loop_length_STP(SL_loop_length_STP);
    last_SL_loop_length_STP = SL_loop_length_STP;
    last_SL_loop_length_CTN = SL_loop_length_CTN;
  );
  SL_repeat_ending ? ( // fade out requested?
    SL_direction == 0 ? (
      loop_pos_READ <= loop_end ? (
        remaining_loop_length = loop_end - loop_pos_READ;
      ):(
        remaining_loop_length = buf_size - loop_pos_READ + loop_end;
      );
      remaining_loop_length == 0 ? ( // no need for fade out as we are exactly at the loop end
        fade_vol = 0;
      ):(
        fade_step = 1/remaining_loop_length;
        fade_vol =1;
      );
    ):(
      loop_pos_READ >= loop_start ? (
        remaining_loop_length = loop_pos_READ - loop_start;
      ):(
        remaining_loop_length = loop_pos_READ + buf_size - loop_start;
      );
      remaining_loop_length == 0 ? ( // no need for fade out as we have fully reversed to the loop start
        fade_vol = 0;
      ):(
        fade_step = 1/remaining_loop_length;
        fade_vol =1;
      );
    );
  );        
); 
last_SL_repeat = SL_repeat;


//===========================================================================================================
//===========================================================================================================
@block
// has playback just stopped?
(play_state == 0) && (play_state != last_play_state) ? (
  SL_repeat = 0;
  play_loop = 0; 
  immediate_transition_override = 0;
  memset(buf0, 0, 4 * buf_size);
  memset(tail0, 0, 2 * tailbuf_size);
  SL_length_transitions != 0 ? (
    // revert back to Stepped Mode and set slider 3 to closest stepped length unless transition was set to "Immediately"
    SL_loop_length_CTN = SL_loop_length_CTN_from_SL_loop_length_STP(SL_loop_length_STP);
    last_SL_loop_length_STP = SL_loop_length_STP;
    last_SL_loop_length_CTN = SL_loop_length_CTN;
  );  
);
last_play_state = play_state;

// adjust buffer size and pointers to follow parameter changes
(ts_num > 0) && (tempo > 0) ? (
  samples_per_beat = floor((srate/tempo)*60 + 0.5);
  samples_per_bar = ts_num * samples_per_beat; // ts_num is equal to beats per bar)
):(
  samples_per_bar = default_samples_per_bar;
  samples_per_beat = floor( default_samples_per_bar/ts_num + 0.5);
);
buf_size = 5 * samples_per_bar; 
buf0 = 0; buf1 = buf0 + buf_size;
loop_copy_offset = 2 * buf_size; 
tailbuf_size = 3 * infade_size; 
tail0 = buf0 + 4 * buf_size; tail1 = tail0 + tailbuf_size; 

beat_offset = 0;


//===========================================================================================================
//===========================================================================================================
@sample
//------------------------------------------------------------------------------------------------
// Calculate the exact current beat position
beat_offset += 1;
exact_beat_position = beat_position + (beat_offset/samples_per_beat);

//------------------------------------------------------------------------------------------------
// Continously fill the track ring buffer with the audio input
in_spl0 = spl0; in_spl1 = spl1;
buf0[buf_pos_WRITE] = in_spl0; buf1[buf_pos_WRITE] = in_spl1;

//------------------------------------------------------------------------------------------------
// check if loop playback got just requested and we are ready to go
(play_loop == 0) && (SL_repeat) && (exact_beat_position >= loop_trigger_beat_pos) ? (
  // freeze the loop end point at the current position, set loop start point and flag to play the loop
  loop_end = buf_pos_WRITE - 1;
  loop_end < 0 ? loop_end = buf_size - 1;
  loop_end_freeze = loop_end;
  loop_start = loop_end - (loop_size - 1);
  loop_start <0 ? (loop_start += buf_size; loop_overflow = 1;) : (loop_overflow = 0);
  next_loop_start = loop_start; next_loop_overflow = loop_overflow;
  loop_pos_READ = loop_start;
  infade_relative_pos = 0;
  Update_Tail();
  loop_pos_COPY = loop_end - (2*samples_per_bar) + 1; // start copy at max length that the looping section can have
  loop_pos_COPY <0 ? loop_pos_COPY += buf_size;
  loop_copied = 0;
  play_loop = 1;
);

//------------------------------------------------------------------------------------------------
play_loop ? (  
  // Copy the max length loop portion (2 bars) of the track ring section to the loop_copy section of the buffer 
  loop_copied == 0 ? (
    buf0[loop_copy_offset + loop_pos_COPY] = buf0[loop_pos_COPY];
    buf1[loop_copy_offset + loop_pos_COPY] = buf1[loop_pos_COPY];
    loop_pos_COPY == loop_end ? loop_copied = 1;
    loop_pos_COPY += 1; loop_pos_COPY >= buf_size ? loop_pos_COPY = 0;
  );

  // check if there is the need to update the loop start position
  (SL_length_transitions == 1) && (immediate_transition_override == 0) ? (
    loop_start != next_loop_start ? (
      exact_beat_position >= next_loop_trigger_beat_pos ? (
        loop_start = next_loop_start;
        loop_overflow = next_loop_overflow;
        loop_pos_READ = loop_start;
        infade_relative_pos = 0;
        Update_Tail();
      );
    );
  );      
  
   
  // play back the loop
  loop_spl_L = buf0[loop_copied*(loop_copy_offset) + loop_pos_READ];  loop_spl_R = buf1[loop_copied*(loop_copy_offset) + loop_pos_READ];
  infade_relative_pos < infade_size - 1 ? (
    // gradual loop fade-in
    infade_ratio = infade_relative_pos / infade_size;
    
    SL_infade_algo == 0 ? ( // extrapolated slope
      last_spl_delta_L = last_spl_played_L - llast_spl_played_L;
      last_spl_delta_R = last_spl_played_R - llast_spl_played_R;
      abs(last_spl_delta_L) > max_slope ? last_spl_delta_L = sign(last_spl_delta_L)*max_slope;
      abs(last_spl_delta_R) > max_slope ? last_spl_delta_R = sign(last_spl_delta_R)*max_slope;
      next_spl_extrap_L = last_spl_played_L + slope_factor * last_spl_delta_L;
      next_spl_extrap_R = last_spl_played_R + slope_factor * last_spl_delta_R;
      out_spl2 = loop_spl_L * infade_ratio + next_spl_extrap_L * (1 - infade_ratio);
      out_spl3 = loop_spl_R * infade_ratio + next_spl_extrap_R * (1 - infade_ratio);
    ):( // reverse crossfade
      out_spl2 = loop_spl_L * infade_ratio + tail0[tail_pos_READ] * (1 - infade_ratio);
      out_spl3 = loop_spl_R * infade_ratio + tail1[tail_pos_READ] * (1 - infade_ratio);
      tail_pos_READ -= 1; tail_pos_READ < 0 ? tail_pos_READ = tailbuf_size - 1;
    );
    
    infade_relative_pos += 1;
  ):(
    out_spl2 = loop_spl_L;  out_spl3 = loop_spl_R;
  );  
    
  // Fx channel routing
  SL_fx_routing == 0 ? (
    out_spl0 = out_spl2;  out_spl1 = out_spl3; // combined
  ):(
    SL_fx_routing == 1 ? (
      out_spl0 = 0; out_spl1 = 0; // muted
    ):(
      out_spl0 = in_spl0; out_spl1 = in_spl1; // passthrough
    );
  );
   
  
  // store last samples played for extrapolation or reverse crossfade
  llast_spl_played_L = last_spl_played_L; llast_spl_played_R = last_spl_played_R;
  last_spl_played_L = out_spl2; last_spl_played_R = out_spl3;
  Write_Tail(out_spl2,out_spl3);
  
  // advancing the loop READ position depending on specific settings
  SL_direction == 0 ? (
    (SL_length_transitions == 2) && (immediate_transition_override == 0) ? (
      //loop must play till end before READ position may be set to current loop start position
      loop_pos_READ == loop_end ? (
        loop_pos_READ = loop_start;
        infade_relative_pos = 0;
        Update_Tail();
      ):(
        loop_pos_READ += 1; loop_pos_READ >= buf_size ? loop_pos_READ = 0;
      );  
    ):(
      // loop READ position moves to (new) start position immediately if it has reached the loop end or if loop length has been shortened while playing
      loop_pos_READ += 1; loop_pos_READ >= buf_size ? loop_pos_READ = 0;  
      loop_overflow == 0 ? (
        (loop_pos_READ > loop_end)||(loop_pos_READ < loop_start) ? (
          loop_pos_READ = loop_start;
          infade_relative_pos = 0;
          Update_Tail();
        ); 
      ):(
        (loop_pos_READ > loop_end)&&(loop_pos_READ < loop_start) ? (
          loop_pos_READ = loop_start;
          infade_relative_pos = 0;
          Update_Tail();
        );  
      );
    );   
  ):(
    // loop READ position moves to end position immediately if it has reached the current loop start or if the loop has been shortened while playing
    loop_pos_READ -= 1; loop_pos_READ < 0 ? loop_pos_READ = buf_size - 1;  
    loop_overflow == 0 ? (
      loop_pos_READ < loop_start ? (
        loop_pos_READ = loop_end;
        infade_relative_pos = 0;
        Update_Tail();
      ); 
    ):(
      (loop_pos_READ > loop_end)&&(loop_pos_READ < loop_start) ? (
        loop_pos_READ = loop_end;
        infade_relative_pos = 0;
        Update_Tail();
      );  
    );
  );
  
//------------------------------------------------------------------------------------------------  
):(
  // No continuous loop playback from here
   
  llast_spl_played_L = last_spl_played_L; llast_spl_played_R = last_spl_played_R;

  // is there a loop fading out?
  fade_vol > 0 ? (
    track_X_vol = sqrt(1-fade_vol); loop_X_vol = sqrt(fade_vol); // equal power cross fade
    out_spl2 = buf0[loop_copied*loop_copy_offset+loop_pos_READ]*loop_X_vol; out_spl3 = buf1[loop_copied*loop_copy_offset+loop_pos_READ]*loop_X_vol;
    // Fx channel routing
    SL_fx_routing == 0 ? (
      out_spl0 = in_spl0*track_X_vol + out_spl2; out_spl1 = in_spl1*track_X_vol + out_spl3; // combined
      last_spl_played_L = out_spl0; last_spl_played_R = out_spl1;
      Write_Tail(out_spl0,out_spl1);
    ):(
      SL_fx_routing == 1 ? (
        out_spl0 = in_spl0*track_X_vol; out_spl1 = in_spl1*track_X_vol; // fade muted track back in
        last_spl_played_L = out_spl2; last_spl_played_R = out_spl3;
        Write_Tail(out_spl2,out_spl3);
      ):(
        out_spl0 = in_spl0; out_spl1 = in_spl1; // passthrough
        last_spl_played_L = out_spl2; last_spl_played_R = out_spl3;
        Write_Tail(out_spl2,out_spl3);
      );
    );
    
    fade_vol -= fade_step;
    SL_direction == 0 ? (
      loop_pos_READ += 1; loop_pos_READ >= buf_size ? loop_pos_READ = 0;
    ):(
      loop_pos_READ -= 1; loop_pos_READ < 0 ? loop_pos_READ = buf_size - 1;
    );
    
  ):( // no loop fade out
    out_spl0 = in_spl0; out_spl1 = in_spl1;
    out_spl2 = 0; out_spl3 = 0;
    last_spl_played_L = out_spl0; last_spl_played_R = out_spl1;
    Write_Tail(out_spl0,out_spl1);
  );    
);
//------------------------------------------------------------------------------------------------  
// Output audio
spl0 = out_spl0; spl1 = out_spl1;
play_state == 0 ? (
  out_spl2 = 0; out_spl3 = 0;
);
spl2 = out_spl2; spl3 = out_spl3;

//------------------------------------------------------------------------------------------------

buf_pos_WRITE += 1; buf_pos_WRITE >= buf_size ? buf_pos_WRITE = 0;
Update_Pointers();




