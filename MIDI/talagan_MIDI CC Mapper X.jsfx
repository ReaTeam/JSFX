desc: MIDI CC Mapper X
author: Ben 'Talagan' Babut
version: 5.3.1
changelog:
  - Bug Fix : Note OFF events with non-zero velocities should make keypress feedback indicator disappear
screenshot:
  Dark Theme https://stash.reaper.fm/45504/MIDICCMapperX-5-0-Dark.png
  Light Theme https://stash.reaper.fm/45505/MIDICCMapperX-5-0-Light.png
provides:
  [script main] talagan_MIDI CC Mapper X/MIDI CC Mapper X - Dump Current Function.lua
  [data] talagan_MIDI CC Mapper X/README.md
  [data] talagan_MIDI CC Mapper X/lib.txt
  [data] talagan_MIDI CC Mapper X/_tools/*
  [data] talagan_MIDI CC Mapper X/func/lib/*
  [data] talagan_MIDI CC Mapper X/func/lib/circ/*
  [data] talagan_MIDI CC Mapper X/func/lib/kawaik4/*
  [data] talagan_MIDI CC Mapper X/func/lib/sin/*
  [data] talagan_MIDI CC Mapper X/func/lib/sstep/*
  [data] talagan_MIDI CC Mapper X/func/user_lib/*
about:
  # Midi CC Mapper X

  This JSFX  is an extended version of the original plugin called "MIDI CC Mapper" with many more features. It allows to modify the behavior and the real-time feel of a MIDI controller, by acting as a pre-filter on the MIDI input. It can :

  - Tweak CC (or Channel Pressure) / Pitch Bend / Keyboard Velocity / Poly After Touch response curves :
      - By using predefined curves, some of them being parametric
      - By pen-drawing/prototyping custom curves
      - By smoothing the current curve
      - By restricting the range of values of your curve
      - By extending the predefined curves with your own sets of functions (through lib files)
      - The current curve can be exported and reused in your own sets
  - Morph the response curves between a starting curve and an ending curve, with a morphing parameter
      - The morphing parameter can be automated
      - An auto-emit option is available to continuously fill the gaps with MIDI events when the morphing parameter changes
  - Split/drop/channel re-route keyboard keys
  - Transpose keyboard keys
  - Re-route CCs / CP
  - Re-route CC channels
  - Conditionally channel re-route/drop CCs / CP / Pitch Bend / Velocity / Poly After Touch based on input/output values
  - Pass through initial unmodified events (and act as a splitter)
  - Handle High-Res input and Output for the CCs (CC/CC+32) and Keyboard velocity (CC#88 format).

  The UI shows a virtual controller, on which CCs can be attributed to controls, allowing a user to visually map her/his real controller.

  High-Res MIDI input can be enabled via a global parameter, and High-Res MIDI output can be enabled on CCs individually.

  ## Keyboard Filtering Module

  Located in the top left of the main window, it can be used to achieve keyboard splitting, up to five different ranges (green/red/blue/orange/purple). You can enable/disable the whole splitting configuration with the button located in the module title bar. If splitting is enabled, the keys can be colorized with the mouse by left/right clicking and moving the mouse on them while the mouse is down. The UI provides feedback for currently pressed keys on the MIDI Controller.

  An input channel may be defined for the keyboard, it may be "any" or a specific one : all other channels will be ignored by the plugin. Output channels may be defined for the each color range of the keyboard to possibly reroute them, with the option to drop each of them (to filter some keys out).

  This module can be of great help for defining regions on the keyboard, especially when used on multiple tracks at the same time ; you can easily achieve left/right hand split, multi-instruments combinations and more. In addition to routing, each range has its own configuration for transposition, velocity response curve, and After-Touch response curve.

  ## Keyboard Transposition Module

  Located in the top right of the main window. This module can be enabled or bypassed globally with the button located in the module title bar. If enabled, applies the sum of two parameters, one for transposing by octaves, one for transposing by semitones ; each keyboard color range has its own set of params and may be enabled/disabled individually.

  ## CC Routing/Curve tweaking

  Located in the bottom of the main window. This module UI is contextual to the selected control. When selected, a control can be enabled or disabled individually with the button located in the module title bar.

  There are 4 types of control, depending on the MIDI feature, which can be (from left to right) :

  - Pitch Bend (1 pitch wheel)
  - CC or Channel Pressure (1 mod wheel, 4 pedals, 10 faders, 10 knobs, 10 pads)
  - Velocity (5 Velocity controls, one for each keyboard color range)
  - After-Touch (5 AfterTouch controls, one for each keyboard color range)

  For each control, the response curve :

  - can be defined from one of the templates on the right
  - can be pendrawn by hand with the mouse
  - can be smoothed with the smooth button
  - may be restricted to a user-defined space by configuring MIDI min/max values.

  For CC (or CP) controls :

  - A description can be given that will appear in the title bar
  - A short description can be given that will appear close to the control for convenience
  - An input CC can be assigned (except for the velocity control which is tied to the keyboard velocity)
  - This input CC can be CC learned
  - An output CC can be assigned
  - This output CC can be copied from the input CC

  Note that MIDI Channel Pressure is not technically a MIDI CC# and uses a different type of MIDI message. However, MIDI CC Mapper X unifies CC and CP by proposing a virtual "Channel Pressure" CC #128. If selected as input and routing is ok, messages of type Channel Pressure will be converted to CC messages and reversely if selected as output.

  Additionally, for Pitch Bend and CC controls, channel routing may be achieved.

  ## Morphing curves

  For each control, an additional response curve may be defined. The control will now used a morphed curve calculated from the start curve and this new end curve, using a morph parameter, which can be automated.

  An auto-emit option is available for standard controls (cc + pitch bend). This option will ensure that, if there was some activity on the control, and the morph parameter is moved (by automation, e.g.) some midi events will be forged and emitted to ensure the continuity of the MIDI flow.

  ## Customizing the function library

  The function library is customizable. You can rearrange things, remove sets and functions, and add your own functions after having generated them or having exported them from REAPER. Please refer to the library manual, which is located in <REAPER_RESOURCE_PATH>/Data/talagan_MIDI CC Mapper X/README.md .

  ## Reaper forum thread

  https://forum.cockos.com/showthread.php?t=172630

  ## Detailed PDF Documentation

  https://stash.reaper.fm/45839/MIDI%20CC%20Mapper%20X.pdf

  ## Notes

  Older versions (v1 and v2) can be found on the forum thread.
donation:
  https://www.paypal.com/donate/?business=3YEZMY9D6U8NC&no_recurring=1&currency_code=EUR
license:
  MIT (Do whatever you like with this code).
docs:
  Midi official site : https://www.midi.org/specifications
  Midi HR CC #88 for Velocity : https://forum.cockos.com/showthread.php?t=83782

options:want_all_kb
options:gmem=MIDICCMapperX

slider1:0.5<0,1,0.001>-Morph Pitch Bend
slider2:0.5<0,1,0.001>-Morph Mod Wheel

slider3:0.5<0,1,0.001>-Morph Pedal 1
slider4:0.5<0,1,0.001>-Morph Pedal 2
slider5:0.5<0,1,0.001>-Morph Pedal 3
slider6:0.5<0,1,0.001>-Morph Pedal 4

slider7:0.5<0,1,0.001>-Morph Fader 1
slider8:0.5<0,1,0.001>-Morph Fader 2
slider9:0.5<0,1,0.001>-Morph Fader 3
slider10:0.5<0,1,0.001>-Morph Fader 4
slider11:0.5<0,1,0.001>-Morph Fader 5
slider12:0.5<0,1,0.001>-Morph Fader 6
slider13:0.5<0,1,0.001>-Morph Fader 7
slider14:0.5<0,1,0.001>-Morph Fader 8
slider15:0.5<0,1,0.001>-Morph Fader 9
slider16:0.5<0,1,0.001>-Morph Fader 10

slider17:0.5<0,1,0.001>-Morph Knob 1
slider18:0.5<0,1,0.001>-Morph Knob 2
slider19:0.5<0,1,0.001>-Morph Knob 3
slider20:0.5<0,1,0.001>-Morph Knob 4
slider21:0.5<0,1,0.001>-Morph Knob 5
slider22:0.5<0,1,0.001>-Morph Knob 6
slider23:0.5<0,1,0.001>-Morph Knob 7
slider24:0.5<0,1,0.001>-Morph Knob 8
slider25:0.5<0,1,0.001>-Morph Knob 9
slider26:0.5<0,1,0.001>-Morph Knob 10

slider27:0.5<0,1,0.001>-Morph Pad 1
slider28:0.5<0,1,0.001>-Morph Pad 2
slider29:0.5<0,1,0.001>-Morph Pad 3
slider30:0.5<0,1,0.001>-Morph Pad 4
slider31:0.5<0,1,0.001>-Morph Pad 5
slider32:0.5<0,1,0.001>-Morph Pad 6
slider33:0.5<0,1,0.001>-Morph Pad 7
slider34:0.5<0,1,0.001>-Morph Pad 8
slider35:0.5<0,1,0.001>-Morph Pad 9
slider36:0.5<0,1,0.001>-Morph Pad 10

slider37:0.5<0,1,0.001>-Morph Velocity Green
slider38:0.5<0,1,0.001>-Morph Velocity Red
slider39:0.5<0,1,0.001>-Morph Velocity Blue
slider40:0.5<0,1,0.001>-Morph Velocity Orange
slider41:0.5<0,1,0.001>-Morph Velocity Violet

slider42:0.5<0,1,0.001>-Morph Poly Aftertouch Green
slider43:0.5<0,1,0.001>-Morph Poly Aftertouch Red
slider44:0.5<0,1,0.001>-Morph Poly Aftertouch Blue
slider45:0.5<0,1,0.001>-Morph Poly Aftertouch Orange
slider46:0.5<0,1,0.001>-Morph Poly Aftertouch Violet

//===========================================//
//=============      INIT      ==============//
//===========================================//
@init

//////////////////////////
//  GLOBAL VARS/UTILS   //
//////////////////////////
function roundi(valf) (
  floor(valf+0.5) | 0;
);

///////////////
//  MEMORY   //
///////////////

// Helper function for memory allocation.
function malloc(msize)
  local(ret)
(
  ret = MEM_PTR;
  MEM_PTR += msize;
  ret;
);

function freeUnusedMem()
(
  freembuf(MEM_PTR);
);

// Same thing for gmem.
function galloc(msize)
  local(ret)
(
  ret = GMEM_PTR;
  GMEM_PTR += msize;
  ret;
);

function sharedGlobalVarInit()
(
  CURVESIZE                 = 128;
  PREVIEWSIZE               = 32;
  RESOLUTION                = 2;
);

function instanceGlobalVarInit()
(
  // Map PTR
  MEM_PTR                   = 0;

  // MIDI Messages according to MIDI spec
  MSG_NOTE_OFF              = 8;
  MSG_NOTE_ON               = 9;
  MSG_AT_POLY               = 10; // 0x0A
  MSG_CC                    = 11; // 0x0B
  MSG_PROGRAM_CHANGE        = 12; // 0x0C
  MSG_CHAN_PRESSURE         = 13; // 0x0D
  MSG_PITCH_BEND            = 14; // 0x0E

  // Plugin Controls parameters
  CONTROL_MOD_WHEEL         = 0;  // 1 wheel
  CONTROL_PEDALS_START      = 1;  // 4 peds
  CONTROL_FADERS_START      = 5;  // 10 faders
  CONTROL_KNOBS_START       = 15; // 10 sliders
  CONTROL_PADS_START        = 25; // 10 pads
  CONTROL_VELOCITY_START    = 35; // 5 velo
  CONTROL_AFTERTOUCH_START  = 40; // 5 after touch
  CONTROL_PITCH_BEND        = 45;
  CONTROL_COUNT             = 46;

  // Various UI dimensions
  KEYBOARD_FILTERING_TOP    = 0;
  KEYBOARD_PANEL_TOP        = 0;
  CONTROL_PANEL_TOP         = 130;
  GUI_CONTROL_PARAMS_TOP    = 260;
  KEYBOARD_PANEL_WIDTH      = 710;

  // Design pattern constants
  ANY                       = 0;
  AS_SRC                    = 0;
  KEEP                      = 0;
  DROP                      = -1;
  NONE                      = -1;

  // Current theme pseudo object
  TH                        = 0;

  // Theme nums
  DARK_THEME                = 0;
  LIGHT_THEME               = 1;

  // Number of color ranges
  KB_RANGE_COUNT            = 5;

  // Attribute cc 128 for channel pressure
  CHANNEL_PRESSURE_FAKE_CC_NUM = 128;
  TOOLTIP_DELAY = 0.7;
);


function gmemGlobalVarInit()
(
  // Map PTR
  GMEM_PTR                = 0;

  // FSETS : variables and offsets
  FSET_MAX_COUNT          = 21; // 3 lines of 7 tabs
  FSET_ROW_COUNT          = 5;
  FSET_COL_COUNT          = 6;

  FSET_ID_MAXLEN          = 10;
  FSET_TAB_MAXLEN         = 8;
  FSET_DESC_MAXLEN        = 50;

  // Define some ids for the parametric sets
  FSET_PARAMETRIC_LINEAR_ID = 40;
  FSET_PARAMETRIC_XN_ID     = 41;
  FSET_PARAMETRIC_EXPNX_ID  = 42;
  FSET_PARAMETRIC_CIRCN_ID  = 43;
);

/////////////////////////////////////////////////////////////
// GMEM Mapping : Shared memory between plugin instances   //
/////////////////////////////////////////////////////////////
function gmemMemoryMapInit()
(
  // Since strings are store in 32-bit word slots, these are the max allowed sizes
  FSET_ID_MAXSLOT         = roundi(FSET_ID_MAXLEN/4) + 1;
  FSET_TAB_MAXSLOT        = roundi(FSET_TAB_MAXLEN/4) + 1;
  FSET_DESC_MAXSLOT       = roundi(FSET_DESC_MAXLEN/4) + 1;

  // FSETS : Function set memory mapping
  FSET_OFFSET_ID            = 0;
  FSET_OFFSET_IS_PARAMETRIC = FSET_OFFSET_ID            + 1;
  FSET_OFFSET_PARAMETRIC_ID = FSET_OFFSET_IS_PARAMETRIC + 1;
  FSET_OFFSET_PARAM         = FSET_OFFSET_PARAMETRIC_ID + 1;
  FSET_OFFSET_TAB           = FSET_OFFSET_PARAM         + FSET_ID_MAXSLOT;
  FSET_OFFSET_DESC          = FSET_OFFSET_TAB           + FSET_TAB_MAXSLOT;
  FSET_OFFSET_FUNCTIONS     = FSET_OFFSET_DESC          + FSET_DESC_MAXSLOT;

  // FSETS : FSET Function memory mapping
  FSF_OFFSET_DEFINED      = 0;
  FSF_OFFSET_CURVE        = FSF_OFFSET_DEFINED + 1;
  FSF_OFFSET_PREVIEW      = FSF_OFFSET_CURVE   + CURVESIZE;
  // Sub-Total size       ------
  FSF_SIZE                = FSF_OFFSET_PREVIEW + PREVIEWSIZE;

  // Total size           -----
  FSET_SIZE               = FSET_OFFSET_FUNCTIONS + (FSET_ROW_COUNT * FSET_COL_COUNT * FSF_SIZE);

  // (galloc does not write memory so this will
  // not squash memory from an instance to the other)
  // But only realign the mem ptr
  GMEM_LOADER_ID        = galloc(1); // The ID of the instance that has filled gmem
  GMEM_CMD              = galloc(1); // Cmd num
  GMEM_CMD_STATUS       = galloc(1); // Cmd status : 0 no cmd, 1 cmd ready, 2 cmd being treated, 3 cmd success, 4 cmd error
  GMEM_CMD_ERROR        = galloc(1); // CMd Error code
  GMEM_RESERVED         = galloc(6);
  GMEM_DUMP_CURVE_BUF   = galloc(CURVESIZE);
  GMEM_LOAD_CURVE_BUF   = galloc(CURVESIZE);
  GMEM_FSET_COUNT       = galloc(1);
  GMEM_FSET_START       = GMEM_PTR;
);

//////////////////////////////////////////////////////
// Instance Mapping : Unshared, per instance memory //
//////////////////////////////////////////////////////
function instanceMemoryMapInit()
(
  /////////////////////////////////
  // Persistent data (user conf) //
  /////////////////////////////////
  LOADED_VERSION                      = malloc(1);

  CONTROL_ENABLED                     = malloc(CONTROL_COUNT);  // Per-control enabled flags
  CONTROL_SRCS                        = malloc(CONTROL_COUNT);  // CC srcs
  CONTROL_DSTS                        = malloc(CONTROL_COUNT);  // CC dsts
  CONTROL_HIGHRES_OUTPUT_ENABLED      = malloc(CONTROL_COUNT);  // Per-control option
  CURVES                              = malloc(CONTROL_COUNT*CURVESIZE);

  KEYBOARD_FILTERING_ENABLED          = malloc(1);
  _OBS_KEYBOARD_FILTERED_NOTES        = malloc(88); // Now 128 long, replaced
  KEYBOARD_TRANSPOSE_ENABLED          = malloc(1);
  _OBS_KEYBOARD_TRANSPOSE_8VA         = malloc(1);  // Was shared before between all ranges
  _OBS_KEYBOARD_TRANSPOSE_SEMI_TONES  = malloc(1);  // Was shared before between all ranges

  _OBS_HIGHRES_INPUT_ENABLED          = malloc(1); // Global option
  DROP_UNROUTED_CC_MESSAGES           = malloc(1); // Global option

  /////////////////////////////////
  // Buffers, used for computation
  /////////////////////////////////

  // Cosinus and sinus tables for all possible eleven angles
  KNOB_TICS_X                 = malloc(11); // This is not spinal tap... 0..10 == 11 tics!
  KNOB_TICS_Y                 = malloc(11);

  // Curve smoothing buffer
  SCURVE                      = malloc(CURVESIZE);

  // Control states memorization
  CONTROL_LAST_IN             = malloc(CONTROL_COUNT);
  CONTROL_LAST_OUT            = malloc(CONTROL_COUNT);

  // Various helpers for keyboard drawing
  OCTAVE_BLACK_KEY_LOOKUP     = malloc(12);
  OCTAVE_TOP_KEY_WIDTHS       = malloc(12);
  OCTAVE_TOP_KEY_OFFSETS      = malloc(12);
  OCTAVE_LOOKUP_BOTTOM        = malloc(7);

  _OBS_KEY_VELOCITIES         = malloc(88); // Replaced, now 128 long

  // CC state memorization
  CC_RECEIVED_VALUES          = malloc(128+1); // 128 CCs + Channel Pressure

  // Conf/Global settings mode
  GUI_MODE                    = malloc(1);

  // Current theme
  CURRENT_THEME_NUM           = malloc(1);

  // Added 3.3
  CONTROL_CHAN_SRCS                 = malloc(CONTROL_COUNT);  // Controls routing in
  CONTROL_CHAN_DSTS                 = malloc(CONTROL_COUNT);  // Controls routing out
  KB_INPUT_CHANNEL                  = malloc(1);              // Keyboard routing in
  _OBS_KBG_OUTPUT_CHANNEL           = malloc(1); // Green out : Now included in KB_RANGE_etc
  _OBS_KBR_OUTPUT_CHANNEL           = malloc(1); // Red out : Now included in KB_RANGE_etc
  _OBS_KEYBOARD_TRANSPOSE_APPLY_TO  = malloc(1); // Enable flag R/G : Now included in KB_RANGE_etc
  _OBS_KEYBOARD_VELOCITY_APPLY_TO   = malloc(1); // Enable flag R/G : Now included in each KB_RANGE widget
  CONTROL_MAXS_MSB                  = malloc(CONTROL_COUNT);  // Controls curve max limit (MSB)
  CONTROL_MAXS_LSB                  = malloc(CONTROL_COUNT);  // Controls curve min limit (LSB)
  CONTROL_MINS_MSB                  = malloc(CONTROL_COUNT);  // Controls curve max limit (MSB)
  CONTROL_MINS_LSB                  = malloc(CONTROL_COUNT);  // Controls curve min limit (LSB)
  DROP_UNROUTED_NOTE_MESSAGES       = malloc(1);

  // Added 3.4
  CURRENT_FSET                = malloc(1); // Selected FSet in the UI

  // Added 3.5
  // (these buffers have been extended but for update compatibility reasons
  // old ones are kept in the mem map)
  KEYBOARD_KEY_COLORS         = malloc(128);
  KEY_VELOCITIES              = malloc(128);
  _OBS_CURRENT_OCTAVA_OFFSET  = malloc(1); //  Removed, the full keyboard is shown now.

  // Added 3.6
  MIDI_BUS_INPUT              = malloc(1);
  MIDI_BUS_OUTPUT             = malloc(1);

  // Added 4.0
  KB_RANGE_TRANSPOSE_ENABLED              = malloc(KB_RANGE_COUNT);
  KB_RANGE_TRANSPOSE_8VA                  = malloc(KB_RANGE_COUNT);
  KB_RANGE_TRANSPOSE_SEMI_TONES           = malloc(KB_RANGE_COUNT);
  KB_RANGE_OUTPUT_CHANNEL                 = malloc(KB_RANGE_COUNT);
  DROP_UNROUTED_PITCH_BEND_MESSAGES       = malloc(1);
  _OBS_DROP_UNROUTED_CP_MESSAGES          = malloc(1);
  DROP_UNROUTED_AT_POLY_MESSAGES          = malloc(1);
  _OBS_CP_ASSOCIATED_KB_RANGE             = malloc(1);

  // Added 4.2
  CONTROL_PASS_THROUGH = malloc(CONTROL_COUNT);

  // Added 4.3
  CONTROL_HIGHRES_INPUT_ENABLED = malloc(CONTROL_COUNT);
  REVERSE_PITCH_BEND = malloc(1);

  // Added 5.0
  CONTROL_MORPH_ENABLED        = malloc(CONTROL_COUNT);
  CONTROL_MORPH_SELECTED       = malloc(CONTROL_COUNT);

  CONTROL_MORPH_MAXS_MSB       = malloc(CONTROL_COUNT);  // Controls curve max limit (MSB)
  CONTROL_MORPH_MAXS_LSB       = malloc(CONTROL_COUNT);  // Controls curve min limit (LSB)
  CONTROL_MORPH_MINS_MSB       = malloc(CONTROL_COUNT);  // Controls curve max limit (MSB)
  CONTROL_MORPH_MINS_LSB       = malloc(CONTROL_COUNT);  // Controls curve min limit (LSB)

  CONTROL_MORPH_CURVES             = malloc(CONTROL_COUNT*CURVESIZE);
  CONTROL_MORPH_AUTO_EMIT_ENABLED  = malloc(CONTROL_COUNT);

  // Track values for all morph sliders to detect changes.
  // Track slider activity since last handling.
  // Track output channels for each control.
  MORPH_SLIDER_TRACKING             = malloc(CONTROL_COUNT);
  MORPH_SLIDER_ACTIVITY             = malloc(CONTROL_COUNT);
  CONTROL_OUT_ACTIVITY_PER_CHANNEL  = malloc(CONTROL_COUNT * 16);

  // Added 5.1
  // Value conditional filtering
  CONTROL_VFILT_IN_INF_LSB      = malloc(CONTROL_COUNT);
  CONTROL_VFILT_IN_INF_MSB      = malloc(CONTROL_COUNT);
  CONTROL_VFILT_IN_INF_ENABLED  = malloc(CONTROL_COUNT);

  CONTROL_VFILT_IN_SUP_LSB      = malloc(CONTROL_COUNT);
  CONTROL_VFILT_IN_SUP_MSB      = malloc(CONTROL_COUNT);
  CONTROL_VFILT_IN_SUP_ENABLED  = malloc(CONTROL_COUNT);

  CONTROL_VFILT_OUT_INF_LSB     = malloc(CONTROL_COUNT);
  CONTROL_VFILT_OUT_INF_MSB     = malloc(CONTROL_COUNT);
  CONTROL_VFILT_OUT_INF_ENABLED = malloc(CONTROL_COUNT);

  CONTROL_VFILT_OUT_SUP_LSB     = malloc(CONTROL_COUNT);
  CONTROL_VFILT_OUT_SUP_MSB     = malloc(CONTROL_COUNT);
  CONTROL_VFILT_OUT_SUP_ENABLED = malloc(CONTROL_COUNT);

  CONTROL_VFILT_ENABLED         = malloc(CONTROL_COUNT);
  CONTROL_VFILT_DST_CHAN        = malloc(CONTROL_COUNT);

  // Added 5.2
  // Track output channels for velocity activity
  // To handle note off/after touch events destinations
  // When conditional filtering is on
  // This gives f(in_chan,note) --> out_chan
  VELOCITY_ACTIVITY_PER_CHANNEL = malloc(128 * 16);
  KB_RANGE_AT_FOLLOWS_VELOCITY  = malloc(KB_RANGE_COUNT);


  // Added 5.3
  // Display pressed key channel on the keyboard
  KEY_CHANNELS = malloc(128);

  freeUnusedMem();
);

function initMidiCCNames()
(
  strcpy(0,"Bank Select");
  strcpy(1,"Modulation Wheel");
  strcpy(2,"Breath");
  strcpy(3,"CC 3");
  strcpy(4,"Foot Controller");
  strcpy(5,"Portamento Time");
  strcpy(6,"Data Entry");
  strcpy(7,"Volume");
  strcpy(8,"Balance");
  strcpy(9,"CC 9");
  strcpy(10,"Pan");
  strcpy(11,"Expression");
  strcpy(12,"Effect Controller 1");
  strcpy(13,"Effect Controller 2");
  strcpy(14,"CC 14");
  strcpy(15,"CC 15");
  strcpy(16,"General Purpose Slider 1");
  strcpy(17,"General Purpose Slider 2");
  strcpy(18,"General Purpose Slider 3");
  strcpy(19,"General Purpose Slider 4");
  strcpy(20,"CC 20");
  strcpy(21,"CC 21");
  strcpy(22,"CC 22");
  strcpy(23,"CC 23");
  strcpy(24,"CC 24");
  strcpy(25,"CC 25");
  strcpy(26,"CC 26");
  strcpy(27,"CC 27");
  strcpy(28,"CC 28");
  strcpy(29,"CC 29");
  strcpy(30,"CC 30");
  strcpy(31,"CC 31");

  strcpy(32+0,"Bank Select");
  strcpy(32+1,"Modulation Wheel");
  strcpy(32+2,"Breath");
  strcpy(32+3,"CC 3");
  strcpy(32+4,"Foot Controller");
  strcpy(32+5,"Portamento Time");
  strcpy(32+6,"Data Entry");
  strcpy(32+7,"Volume");
  strcpy(32+8,"Balance");
  strcpy(32+9,"CC 14");
  strcpy(32+10,"Pan");
  strcpy(32+11,"Expression");
  strcpy(32+12,"Effect Controller 1");
  strcpy(32+13,"Effect Controller 2");
  strcpy(32+14,"CC 14");
  strcpy(32+15,"CC 15");
  strcpy(32+16,"General Purpose Slider 1");
  strcpy(32+17,"General Purpose Slider 2");
  strcpy(32+18,"General Purpose Slider 3");
  strcpy(32+19,"General Purpose Slider 4");
  strcpy(32+20,"CC 20");
  strcpy(32+21,"CC 21");
  strcpy(32+22,"CC 22");
  strcpy(32+23,"CC 23");
  strcpy(32+24,"CC 24");
  strcpy(32+25,"CC 25");
  strcpy(32+26,"CC 26");
  strcpy(32+27,"CC 27");
  strcpy(32+28,"CC 28");
  strcpy(32+29,"CC 29");
  strcpy(32+30,"CC 30");
  strcpy(32+31,"CC 31");

  strcpy(64,"Damper/Sustain Pedal (Hold1) On/Off");
  strcpy(65,"Portamento On/Off");
  strcpy(66,"Sostenuto On/Off");
  strcpy(67,"Soft Pedal On/Off");
  strcpy(68,"Legato Pedal On/Off");
  strcpy(69,"Damper/Sustain Pedal (Hold2) On/Off");
  strcpy(70,"Sound Variation");
  strcpy(71,"Sound Timbre/Resonance/Harmonics");
  strcpy(72,"Release");
  strcpy(73,"Attack");
  strcpy(74,"Cutoff/Brightness");
  strcpy(75,"Sound Controller 6");
  strcpy(76,"Sound Controller 7");
  strcpy(77,"Sound Controller 8");
  strcpy(78,"Sound Controller 9");
  strcpy(79,"Sound Controller 10");
  strcpy(80,"General Purpose On/Off 1");
  strcpy(81,"General Purpose On/Off 2");
  strcpy(82,"General Purpose On/Off 3");
  strcpy(83,"General Purpose On/Off 4");
  strcpy(83,"General Purpose On/Off 4");
  strcpy(84,"Portamento Amount");

  strcpy(88,"Keyboard velocity");

  strcpy(91,"Effect 1 Level (Reverb)");
  strcpy(92,"Effect 2 Level (Tremolo)");
  strcpy(93,"Effect 3 Level (Chorus)");
  strcpy(94,"Effect 4 Level (Detune/Celeste)");
  strcpy(95,"Effect 5 Level (Phaser)");
  strcpy(96,"NRPN/RPN Data +1");
  strcpy(97,"NRPN/RPN Data +1");
  strcpy(98,"NRPN LSB");
  strcpy(99,"NRPN MSB");
  strcpy(100,"RPN LSB");
  strcpy(101,"RPN MSB");
);

function initPluginControlNames()
(
  strcpy(128+CONTROL_MOD_WHEEL,"Modulation Wheel");

  strcpy(128+CONTROL_PEDALS_START+0,"Pedal Sustain");
  strcpy(128+CONTROL_PEDALS_START+1,"Pedal 2");
  strcpy(128+CONTROL_PEDALS_START+2,"Pedal 3");
  strcpy(128+CONTROL_PEDALS_START+3,"Pedal 4");

  strcpy(128+CONTROL_FADERS_START+0,"Fader 1");
  strcpy(128+CONTROL_FADERS_START+1,"Fader 2");
  strcpy(128+CONTROL_FADERS_START+2,"Fader 3");
  strcpy(128+CONTROL_FADERS_START+3,"Fader 4");
  strcpy(128+CONTROL_FADERS_START+4,"Fader 5");
  strcpy(128+CONTROL_FADERS_START+5,"Fader 6");
  strcpy(128+CONTROL_FADERS_START+6,"Fader 7");
  strcpy(128+CONTROL_FADERS_START+7,"Fader 8");
  strcpy(128+CONTROL_FADERS_START+8,"Fader 9");
  strcpy(128+CONTROL_FADERS_START+9,"Fader 10");

  strcpy(128+CONTROL_KNOBS_START+0,"Knob 1");
  strcpy(128+CONTROL_KNOBS_START+1,"Knob 2");
  strcpy(128+CONTROL_KNOBS_START+2,"Knob 3");
  strcpy(128+CONTROL_KNOBS_START+3,"Knob 4");
  strcpy(128+CONTROL_KNOBS_START+4,"Knob 5");
  strcpy(128+CONTROL_KNOBS_START+5,"Knob 6");
  strcpy(128+CONTROL_KNOBS_START+6,"Knob 7");
  strcpy(128+CONTROL_KNOBS_START+7,"Knob 8");
  strcpy(128+CONTROL_KNOBS_START+8,"Knob 9");
  strcpy(128+CONTROL_KNOBS_START+9,"Knob 10");

  strcpy(128+CONTROL_PADS_START+0,"Pad 1");
  strcpy(128+CONTROL_PADS_START+1,"Pad 2");
  strcpy(128+CONTROL_PADS_START+2,"Pad 3");
  strcpy(128+CONTROL_PADS_START+3,"Pad 4");
  strcpy(128+CONTROL_PADS_START+4,"Pad 5");
  strcpy(128+CONTROL_PADS_START+5,"Pad 6");
  strcpy(128+CONTROL_PADS_START+6,"Pad 7");
  strcpy(128+CONTROL_PADS_START+7,"Pad 8");
  strcpy(128+CONTROL_PADS_START+8,"Pad 9");
  strcpy(128+CONTROL_PADS_START+9,"Pad 10");

  strcpy(128+CONTROL_VELOCITY_START+0,"Keyboard velocity (Green)");
  strcpy(128+CONTROL_VELOCITY_START+1,"Keyboard velocity (Red)");
  strcpy(128+CONTROL_VELOCITY_START+2,"Keyboard velocity (Blue)");
  strcpy(128+CONTROL_VELOCITY_START+3,"Keyboard velocity (Orange)");
  strcpy(128+CONTROL_VELOCITY_START+4,"Keyboard velocity (Purple)");

  strcpy(128+CONTROL_AFTERTOUCH_START+0,"Keyboard aftertouch (Green)");
  strcpy(128+CONTROL_AFTERTOUCH_START+1,"Keyboard aftertouch (Red)");
  strcpy(128+CONTROL_AFTERTOUCH_START+2,"Keyboard aftertouch (Blue)");
  strcpy(128+CONTROL_AFTERTOUCH_START+3,"Keyboard aftertouch (Orange)");
  strcpy(128+CONTROL_AFTERTOUCH_START+4,"Keyboard aftertouch (Purple)");

  strcpy(128+CONTROL_PITCH_BEND,"Pitch Bend Wheel");
);

function initOctaveLookups() (

  OCTAVE_LOOKUP_BOTTOM[0] = 0; // C
  OCTAVE_LOOKUP_BOTTOM[1] = 2; // D
  OCTAVE_LOOKUP_BOTTOM[2] = 4; // E
  OCTAVE_LOOKUP_BOTTOM[3] = 5; // F
  OCTAVE_LOOKUP_BOTTOM[4] = 7; // G
  OCTAVE_LOOKUP_BOTTOM[5] = 9; // A
  OCTAVE_LOOKUP_BOTTOM[6] = 11; // B

  OCTAVE_BLACK_KEY_LOOKUP[ 0] = 0; // C
  OCTAVE_BLACK_KEY_LOOKUP[ 1] = 1; // C#/Db
  OCTAVE_BLACK_KEY_LOOKUP[ 2] = 0; // D
  OCTAVE_BLACK_KEY_LOOKUP[ 3] = 1; // D#/Eb
  OCTAVE_BLACK_KEY_LOOKUP[ 4] = 0; // E
  OCTAVE_BLACK_KEY_LOOKUP[ 5] = 0; // F
  OCTAVE_BLACK_KEY_LOOKUP[ 6] = 1; // F#/Gb
  OCTAVE_BLACK_KEY_LOOKUP[ 7] = 0; // G
  OCTAVE_BLACK_KEY_LOOKUP[ 8] = 1; // G#/Ab
  OCTAVE_BLACK_KEY_LOOKUP[ 9] = 0; // A
  OCTAVE_BLACK_KEY_LOOKUP[10] = 1; // A#/Bb
  OCTAVE_BLACK_KEY_LOOKUP[11] = 0; // B

  OCTAVE_TOP_KEY_WIDTHS[ 0]   = 0.5; // C
  OCTAVE_TOP_KEY_WIDTHS[ 1]   = 1;   // C#/Db
  OCTAVE_TOP_KEY_WIDTHS[ 2]   = 0;   // D
  OCTAVE_TOP_KEY_WIDTHS[ 3]   = 1;   // D#/Eb
  OCTAVE_TOP_KEY_WIDTHS[ 4]   = 0.5; // E
  OCTAVE_TOP_KEY_WIDTHS[ 5]   = 0.5; // F
  OCTAVE_TOP_KEY_WIDTHS[ 6]   = 1;   // F#/Gb
  OCTAVE_TOP_KEY_WIDTHS[ 7]   = 0;   // G
  OCTAVE_TOP_KEY_WIDTHS[ 8]   = 1;   // G#/Ab
  OCTAVE_TOP_KEY_WIDTHS[ 9]   = 0;   // A
  OCTAVE_TOP_KEY_WIDTHS[10]   = 1;   // A#/Bb
  OCTAVE_TOP_KEY_WIDTHS[11]   = 0.5; // B

  OCTAVE_TOP_KEY_OFFSETS[ 0]  = 0;   // C
  OCTAVE_TOP_KEY_OFFSETS[ 1]  = 0.5; // C#/Db
  OCTAVE_TOP_KEY_OFFSETS[ 2]  = 1.5; // D
  OCTAVE_TOP_KEY_OFFSETS[ 3]  = 1.5; // D#/Eb
  OCTAVE_TOP_KEY_OFFSETS[ 4]  = 2.5; // E
  OCTAVE_TOP_KEY_OFFSETS[ 5]  = 3;   // F
  OCTAVE_TOP_KEY_OFFSETS[ 6]  = 3.5; // F#/Gb
  OCTAVE_TOP_KEY_OFFSETS[ 7]  = 4.5; // G
  OCTAVE_TOP_KEY_OFFSETS[ 8]  = 4.5; // G#/Ab
  OCTAVE_TOP_KEY_OFFSETS[ 9]  = 5.5; // A
  OCTAVE_TOP_KEY_OFFSETS[10]  = 5.5; // A#/Bb
  OCTAVE_TOP_KEY_OFFSETS[11]  = 6.5;   // B
);

////////////
// THEMES //
////////////

function switchToDarkTheme() (

  TH.LIGHTGREEN = 0x80E580;
  TH.MIDGREEN   = 0x20A020;
  TH.LOWGREEN   = 0x10A010;

  TH.BACKGROUND          = 0x000000;
  TH.DEFAULT_FONT        = 0xCCCCCC; // Default font color

  TH.HEADER              = 0x202066;
  TH.HEADER_TEXT         = TH.DEFAULT_FONT;

  // Enable/Disable button colors (Green/Grey)
  TH.EN_B_ON             = TH.MIDGREEN; // Toggle button on
  TH.EN_B_ON_H           = TH.LIGHTGREEN; // Toggle button on+hover
  TH.EN_B_ON_TEXT        = 0xFFFFFF;
  TH.EN_B_OFF            = 0x202020; // Toggle button off
  TH.EN_B_OFF_H          = 0x606060; // Toggle button off+hover
  TH.EN_B_OFF_TEXT       = TH.DEFAULT_FONT;

  // Switch button (Bistate button, but does not change color)
  // Used for changing tabs for example
  TH.SW_B_ON             = 0x202020;
  TH.SW_B_ON_H           = 0x505050;
  TH.SW_B_ON_TEXT        = TH.DEFAULT_FONT;
  TH.SW_B_OFF            = 0x202020;
  TH.SW_B_OFF_H          = 0x505050;
  TH.SW_B_OFF_TEXT       = TH.DEFAULT_FONT;

  // Mono state button (cannot be toggled)
  TH.MONO_B              = 0x202020;
  TH.MONO_B_H            = 0x505050;
  TH.MONO_B_TEXT         = 0xAAAAFF;

  TH.CURVE_B             = 0x202020;
  TH.CURVE_B_H           = 0x505050;

  TH.CC_LEARN_ON         = 0x666600;
  TH.CC_LEARN_ON_H       = 0x888800;
  TH.CC_LEARN_ON_TEXT    = 0xFFFF00;

  // Dynamic labels (Control information display)
  TH.DYN_LABEL           = 0x8080FF;
  TH.DYN_LABEL_HIGHLIGHT = 0xFFFFFF;
  TH.DYN_LABEL_NEUTRAL   = 0x808080;
  TH.DYN_LABEL_DISABLED  = 0x505050;

  // Curve
  TH.CURVE               = 0x6060FF;
  TH.CURVE_MORPH_UNS     = 0x709070;
  TH.CURVE_MORPH_SEL     = 0x00FF00;
  TH.CURVE_BASE_UNS      = 0x886060;
  TH.CURVE_BASE_SEL      = 0xFF6060;

  TH.CURVE_BG            = 0xFFFFFF;
  TH.CURVE_BG_EXCL       = 0x090909;
  TH.CURVE_GRID          = 0x353535;
  TH.CURVE_BORDER        = 0x474747;
  TH.CURVE_CURRENT_VALUE = 0xFF4040;

  TH.CURVE_BG_FILTER_OUT = 0x201045;

  TH.CURVE_MORPH         = 0x4080FF;

  // Controls
  TH.CONTROL_HIGHLIGHT              = 0x7070F0;
  TH.CONTROL_HIGHLIGHT_H            = 0xA0A000;

  TH.CONTROL_ENABLED_CONTRAST_HIGH  = 0xF0F0F0;
  TH.CONTROL_ENABLED_CONTRAST_MID   = 0xB0B0B0;
  TH.CONTROL_ENABLED_CONTRAST_LOW   = 0x6C6C6C;

  TH.CONTROL_DISABLED_CONTRAST_HIGH = 0x505050;
  TH.CONTROL_DISABLED_CONTRAST_MID  = 0x454545;
  TH.CONTROL_DISABLED_CONTRAST_LOW  = 0x202020;

  // Edit input lines
  TH.INPUTLINE_BG        = TH.MONO_B;
  TH.INPUTLINE_BG_H      = TH.MONO_B_H;
  TH.INPUTLINE_TEXT      = TH.MONO_B_TEXT;

  TH.INPUTLINE_EDIT_BG   = TH.CC_LEARN_ON;
  TH.INPUTLINE_EDIT_BG_H = TH.CC_LEARN_ON_H;
  TH.INPUTLINE_EDIT_TEXT = TH.CC_LEARN_ON_TEXT;

  // Function tabs
  TH.TAB_BG     = 0x181818;
  TH.TAB_BG_H   = 0x303030;
  TH.TAB_BG_S   = 0x404040;
  TH.TAB_BG_S_H = 0x505050;
  TH.TAB_TEXT   = 0x909090;
  TH.TAB_TEXT_S = TH.DEFAULT_FONT;

  // Src/Dst labels
  TH.ROUTING_INFO_CCNAME = TH.DYN_LABEL;
  TH.ROUTING_INFO_NOT_OK = 0xFF5533;
  TH.ROUTING_INFO_OK     = 0x00FF00;

  // Keyboard
  TH.KEY_MARKER_BORDER  = 0x000000;
  TH.KEY_MARKER_BG      = 0xFFFFFF;

  TH.KEY_WHITE_DISABLED = 0x608060;
  TH.KEY_BLACK_DISABLED = 0x306030;

  TH.KEY_WHITE_COLOR_0    = TH.LIGHTGREEN;
  TH.KEY_BLACK_COLOR_0    = TH.MIDGREEN;
  TH.KEY_BLACK_COLOR_0_D  = 0x173017;

  TH.KEY_WHITE_COLOR_1    = 0xFF7070;
  TH.KEY_BLACK_COLOR_1    = 0xF34C4C;
  TH.KEY_BLACK_COLOR_1_D  = 0x381818;

  TH.KEY_WHITE_COLOR_2    = 0x7CC0FC;
  TH.KEY_BLACK_COLOR_2    = 0x1F85DE;
  TH.KEY_BLACK_COLOR_2_D  = 0x1F2838;

  TH.KEY_WHITE_COLOR_3    = 0xFFCA79;
  TH.KEY_BLACK_COLOR_3    = 0xFC990B;
  TH.KEY_BLACK_COLOR_3_D  = 0x403020;

  TH.KEY_WHITE_COLOR_4    = 0xCA6DFF;
  TH.KEY_BLACK_COLOR_4    = 0xB433FE;
  TH.KEY_BLACK_COLOR_4_D  = 0x403040;

  TH.KEY_OCTAVA_NUMBER    = 0x303030;
  TH.KEY_SEP_LINES        = TH.BACKGROUND;
  TH.KEY_COLOR_RANGE_TEXT = TH.BACKGROUND;

);

function switchToLightTheme() (

  TH.LIGHTGREEN = 0x50D050;
  TH.MIDGREEN   = 0x20A020;
  TH.LOWGREEN   = 0x10A010;

  TH.BACKGROUND          = 0xE0E0E0;
  TH.DEFAULT_FONT        = 0x101010; // Default font color

  TH.HEADER              = 0xC0C0C0;
  TH.HEADER_TEXT         = TH.DEFAULT_FONT;

  // Enable/Disable button colors (Green/Grey)
  TH.EN_B_ON             = TH.MIDGREEN; // Toggle button on
  TH.EN_B_ON_H           = TH.LIGHTGREEN; // Toggle button on+hover
  TH.EN_B_ON_TEXT        = 0xFFFFFF;
  TH.EN_B_OFF            = 0xA0A0A0; // Toggle button off
  TH.EN_B_OFF_H          = 0xD0D0D0; // Toggle button off+hover
  TH.EN_B_OFF_TEXT       = TH.DEFAULT_FONT;

  // Switch button (Bistate button, but does not change color)
  // Used for changing tabs for example
  TH.SW_B_ON             = 0xA0A0A0;
  TH.SW_B_ON_H           = 0xD0D0D0;
  TH.SW_B_ON_TEXT        = TH.DEFAULT_FONT;
  TH.SW_B_OFF            = 0xA0A0A0;
  TH.SW_B_OFF_H          = 0xD0D0D0;
  TH.SW_B_OFF_TEXT       = TH.DEFAULT_FONT;

  // Mono state button (cannot be toggled)
  TH.MONO_B              = 0xA0A0A0;
  TH.MONO_B_H            = 0xD0D0D0;
  TH.MONO_B_TEXT         = 0xFFFFFF;

  TH.CURVE_B             = 0xC0C0C0;
  TH.CURVE_B_H           = 0xE0E0E0;

  TH.CC_LEARN_ON         = 0x666600;
  TH.CC_LEARN_ON_H       = 0x888800;
  TH.CC_LEARN_ON_TEXT    = 0xFFFF00;

  // Dynamic labels (Control information display)
  TH.DYN_LABEL           = 0x6060FF;
  TH.DYN_LABEL_HIGHLIGHT = 0x000000;
  TH.DYN_LABEL_NEUTRAL   = 0x808080;
  TH.DYN_LABEL_DISABLED  = 0x505050;

  // Curve
  TH.CURVE               = 0x6060FF;
  TH.CURVE_MORPH_UNS     = 0x709070;
  TH.CURVE_MORPH_SEL     = 0x00A000;
  TH.CURVE_BASE_UNS      = 0x886060;
  TH.CURVE_BASE_SEL      = 0xFF6060;

  TH.CURVE_BG            = 0xFFFFFF;
  TH.CURVE_BG_EXCL       = 0x292929;
  TH.CURVE_GRID          = 0x555555;
  TH.CURVE_BORDER        = 0x676767;
  TH.CURVE_CURRENT_VALUE = 0xFF4040;

  TH.CURVE_BG_FILTER_OUT = 0x201045;

  TH.CURVE_MORPH         = 0x4080FF;

  // Controls
  TH.CONTROL_HIGHLIGHT              = 0xC7C7FF;
  TH.CONTROL_HIGHLIGHT_H            = 0xA0A000;

  TH.CONTROL_ENABLED_CONTRAST_HIGH  = 0xA0A0A0;//0xF0F0F0;
  TH.CONTROL_ENABLED_CONTRAST_MID   = 0x707070;//0x909090;
  TH.CONTROL_ENABLED_CONTRAST_LOW   = 0x606060;//0x4C4C4C;

  TH.CONTROL_DISABLED_CONTRAST_HIGH = 0xD3D3D3;
  TH.CONTROL_DISABLED_CONTRAST_MID  = 0xD3D3D3;
  TH.CONTROL_DISABLED_CONTRAST_LOW  = 0xC7C7C7;

  // Edit input lines
  TH.INPUTLINE_BG        = TH.MONO_B;
  TH.INPUTLINE_BG_H      = TH.MONO_B_H;
  TH.INPUTLINE_TEXT      = TH.MONO_B_TEXT;

  TH.INPUTLINE_EDIT_BG   = TH.CC_LEARN_ON;
  TH.INPUTLINE_EDIT_BG_H = TH.CC_LEARN_ON_H;
  TH.INPUTLINE_EDIT_TEXT = TH.CC_LEARN_ON_TEXT;

  // Function tabs
  TH.TAB_BG     = TH.MONO_B;
  TH.TAB_BG_H   = TH.MONO_B_H;
  TH.TAB_BG_S   = 0xC0C0C0;
  TH.TAB_BG_S_H = 0xD0D0D0;
  TH.TAB_TEXT   = TH.MONO_B_TEXT;
  TH.TAB_TEXT_S = 0xFFFFFF;

  // Src/Dst labels
  TH.ROUTING_INFO_CCNAME = TH.DYN_LABEL;
  TH.ROUTING_INFO_NOT_OK = 0xFF0000;
  TH.ROUTING_INFO_OK     = 0x008F00;

  // Keyboard
  TH.KEY_MARKER_BORDER  = 0x000000;
  TH.KEY_MARKER_BG      = 0xFFFFFF;

  TH.KEY_BLACK_DISABLED = 0x70A070;
  TH.KEY_WHITE_DISABLED = 0x90C090;

  TH.KEY_WHITE_COLOR_0    = TH.LIGHTGREEN;
  TH.KEY_BLACK_COLOR_0    = TH.MIDGREEN;
  TH.KEY_BLACK_COLOR_0_D  = 0xA0D0A0;

  TH.KEY_WHITE_COLOR_1    = 0xFF7070;
  TH.KEY_BLACK_COLOR_1    = 0xF34C4C;
  TH.KEY_BLACK_COLOR_1_D  = 0xE0B2B2;

  TH.KEY_WHITE_COLOR_2    = 0x7CC0FC;
  TH.KEY_BLACK_COLOR_2    = 0x1F85DE;
  TH.KEY_BLACK_COLOR_2_D  = 0xAFC8D8;

  TH.KEY_WHITE_COLOR_3    = 0xFFCA79;
  TH.KEY_BLACK_COLOR_3    = 0xFC990B;
  TH.KEY_BLACK_COLOR_3_D  = 0xDBCBA8;

  TH.KEY_WHITE_COLOR_4    = 0xCA6DFF;
  TH.KEY_BLACK_COLOR_4    = 0xB433FE;
  TH.KEY_BLACK_COLOR_4_D  = 0xD0B0D0;

  TH.KEY_OCTAVA_NUMBER    = 0x505050;
  TH.KEY_SEP_LINES        = 0x404040;
  TH.KEY_COLOR_RANGE_TEXT = 0xFFFFFF;
);

function switchToTheme(theme_num) (
  (theme_num == DARK_THEME)?(switchToDarkTheme()):(switchToLightTheme());
);

function updateTheme() (
  switchToTheme(CURRENT_THEME_NUM[0]);
);

function currentTheme() (
  CURRENT_THEME_NUM[0];
);

function initThemes() (
  CURRENT_THEME_NUM[0] = DARK_THEME;
  updateTheme();
);


////////////////////////
// FUNCTION SET TOOLS //
////////////////////////

// Applies a curve from gmem
function applyGmemCurve(curve_address, x01)
  local(x01, sample_num_f, sample_num_il, sample_num_ir, sample_l, sample_r, curve_interp, alpha)
(
  // Do some clamping cleanup first
  x01 = min(max(x01,0),1);

  // Normalize reference space > Curve space
  sample_num_f  = 127 * x01;
  sample_num_il = floor(sample_num_f);
  sample_num_ir = ceil(sample_num_f);

  // Get left sample, right sample, and linear interpolation factor
  sample_l      = gmem[curve_address+sample_num_il];
  sample_r      = gmem[curve_address+sample_num_ir];
  alpha         = sample_num_f - sample_num_il;

  // Lerp : this will return a value between 0 and 127
  curve_interp  = (1-alpha) * sample_l + alpha * sample_r;

  // Return a value between 0 and 1.
  (curve_interp);
);

function putStringInGmem(gmem_start_index, gmem_slots, str)
  local(slen, max_len, i, si, bi, c)
(
  // Limit to 32 bits to avoid problems on old architectures.
  slen    = strlen(str);        // We want to add \0
  max_len = gmem_slots * 4 - 1; // Keep one byte for \0

  si = 0;
  while(si < gmem_slots)
  (
    gmem[gmem_start_index + si] = 0;
    si += 1;
  );

  i = 0; bi = 0; si = gmem_start_index;
  while(i<slen && i<max_len)
  (
    c = str_getchar(str,i);

    // Write byte.
    gmem[si] = gmem[si] | (c<<bi);

    i   += 1;
    bi  += 8;
    (bi==32)?(
      bi = 0;
      si += 1;
    );
  );
);

function getStringFromGmem(gmem_start_index, gmem_slots)
  local(c, max_len, i, bi, si, str)
(
  // Beware! It's specified in the doc that the string
  // Initial value may be unpredictable. Initialize it!
  str = #; strcpy(str,"");

  max_len = gmem_slots * 4; // Keep one byte for \0

  i = 0; bi = 0; si = gmem_start_index; c = 1;

  while(i<max_len && c!=0)
  (
    c = (gmem[si]>>bi) & 0xFF;

    (c!=0)?(
      str_setchar(str,i,c);
    );

    i   += 1;
    bi  += 8;
    (bi==32)?(
      bi = 0;
      si += 1;
    );
  );

  str;
);

function getFSetAddress(set_num) (
  GMEM_FSET_START + (FSET_SIZE * set_num);
);
function getFSetCount() (
  gmem[GMEM_FSET_COUNT];
);

function getFSetId(set_num) (
  getStringFromGmem(getFSetAddress(set_num) + FSET_OFFSET_ID, FSET_ID_MAXSLOT);
);
function getFSetTab(set_num) (
  getStringFromGmem(getFSetAddress(set_num) + FSET_OFFSET_TAB, FSET_TAB_MAXSLOT);
);
function getFSetDescription(set_num) (
  getStringFromGmem(getFSetAddress(set_num) + FSET_OFFSET_DESC, FSET_DESC_MAXSLOT);
);

function isFSetParametric(set_num) (
 (gmem[getFSetAddress(set_num) + FSET_OFFSET_IS_PARAMETRIC] == 1);
);
function setFSetIsParametric(set_num, v) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_IS_PARAMETRIC] = v;
);
function getFSetParametricID(set_num) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_PARAMETRIC_ID];
);
function setFSetParametricID(set_num, id) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_PARAMETRIC_ID] = id;
);
function getFSetParameter(set_num) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_PARAM];
);
function setFSetParameter(set_num, param) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_PARAM] = param;
);


function getFSetFunctionAddress(set_num, row_num, col_num) (
  getFSetAddress(set_num) + FSET_OFFSET_FUNCTIONS + FSF_SIZE * (row_num * FSET_COL_COUNT + col_num);
);
function getFSetFunctionCurveAddress(set_num, row_num, col_num) (
  getFSetFunctionAddress(set_num, row_num, col_num) + FSF_OFFSET_CURVE;
);
function getFSetFunctionPreviewAddress(set_num, row_num, col_num) (
  getFSetFunctionAddress(set_num, row_num, col_num) + FSF_OFFSET_PREVIEW;
);
function isFSetFunctionDefined(set_num, row_num, col_num) (
  (gmem[getFSetFunctionAddress(set_num, row_num, col_num) + FSF_OFFSET_DEFINED] == 1);
);
function setFSetFunctionDefined(set_num, row_num, col_num, is_defined)(
  gmem[getFSetFunctionAddress(set_num, row_num, col_num) + FSF_OFFSET_DEFINED] = is_defined;
);

// Iterates on fsets to find the one with id "set_id"
function findFSetById(set_id)
  local(s,sn,si,found,fset_addr)
(
  s = #;
  strncpy(s,set_id,FSET_ID_MAXLEN); // Clamp to max chars

  si    = 0;
  found = NONE;

  while(si<gmem[GMEM_FSET_COUNT] && found == NONE)
  (

    fset_addr = getFSetAddress(si);
    sn        = getStringFromGmem(fset_addr + FSET_OFFSET_ID, 2);

    (strcmp(sn,s) == 0)?(
      found = si;
    );

    si += 1;
  );

  found;
);

// Creates a new FSet
function createFSet(fset_id, fset_tab, fset_desc)
  local(fset_addr, fset_num, s, mi)
(
  // Allocate set
  fset_addr     = galloc(FSET_SIZE);

  // Update counts
  fset_num = gmem[GMEM_FSET_COUNT];
  gmem[GMEM_FSET_COUNT] += 1;

  // Nullify everything. Full memory cleanup.
  mi = 0;
  while(mi < FSET_SIZE) (
    gmem[fset_addr+mi]=0;
    mi+=1;
  );

  // Initialize name/tab/desc limit to max chars
  s = #;
  strncpy(s, fset_id, FSET_ID_MAXLEN);
  putStringInGmem(fset_addr + FSET_OFFSET_ID, FSET_ID_MAXSLOT, s);
  strncpy(s, fset_tab, FSET_TAB_MAXLEN);
  putStringInGmem(fset_addr + FSET_OFFSET_TAB, FSET_TAB_MAXSLOT, s);
  strncpy(s,fset_desc, FSET_DESC_MAXLEN);
  putStringInGmem(fset_addr + FSET_OFFSET_DESC, FSET_DESC_MAXSLOT, s);

  fset_num;
);

function getCurrentFSet() (
  CURRENT_FSET[0];
);
function setCurrentFSet(set_num) (
  CURRENT_FSET[0] = set_num;
);

function getParametricFSetParamRounding(pid) (
  (pid == FSET_PARAMETRIC_XN_ID || pid == FSET_PARAMETRIC_EXPNX_ID)?(
    5;
  ):(
    1;
  );
);

function getParametricFSetParameterName(pid)
  local(param_label)
(
  // Draw slider
  param_label = "";

  (pid == FSET_PARAMETRIC_LINEAR_ID)?(param_label = "Cut");
  (pid == FSET_PARAMETRIC_EXPNX_ID)?(param_label = "N");
  (pid == FSET_PARAMETRIC_XN_ID)?(param_label = "N");
  (pid == FSET_PARAMETRIC_CIRCN_ID)?(param_label = "R");

  param_label;
);

function getParametricFSetParameterMin(pid)
  local(mv)
(
  mv = 0;

  (pid == FSET_PARAMETRIC_LINEAR_ID)?(mv = 0);
  (pid == FSET_PARAMETRIC_EXPNX_ID)?(mv = 1);
  (pid == FSET_PARAMETRIC_XN_ID)?(mv = 1);
  (pid == FSET_PARAMETRIC_CIRCN_ID)?(mv = 0);

  mv;
);

function getParametricFSetParameterMax(pid)
  local(mv)
(
  mv = 0;

  (pid == FSET_PARAMETRIC_LINEAR_ID)?(mv = 1);
  (pid == FSET_PARAMETRIC_EXPNX_ID)?(mv = 10);
  (pid == FSET_PARAMETRIC_XN_ID)?(mv = 10);
  (pid == FSET_PARAMETRIC_CIRCN_ID)?(mv = 1);

  mv;
);


/////////////////////
//  Parsing tools  //
/////////////////////

function isBlankChar(char)
(
  (char == 0x20 || char == 0x0A || char == 0x0D || char == 0x09);
);

// Call on a ctx
function FSCTX_EatBlank()
  local(is_space, c)
(
  is_space = 1;

  while(is_space && this.cursor < this.len)
  (
    c         = str_getchar(this.str, this.cursor);
    is_space  = isBlankChar(c);
    (is_space)?(
      this.cursor += 1;
    );
  );
);

// Call on a ctx
function FSCTX_NextChar()
(
  str_getchar(this.str, this.cursor);
);

// Call on a ctx
function FSCTX_AtEnd()
(
  (this.cursor >= this.len);
);

// Call on a ctx
function FSCTX_EatNextToken()
  local()
(
  ctx.tok_start = this.cursor;

  // 0x7C == '|', it's the pipe character
  while(!ctx.FSCTX_AtEnd() && ctx.FSCTX_NextChar() != 0x7C)
  (
    this.cursor += 1;
  );

  ctx.tok_len = this.cursor - ctx.tok_start;

  // Also eat separator
  (ctx.FSCTX_NextChar() == 0x7C)?(
    this.cursor += 1;
  )
);

function FSCTX_BuildFromLine(str)
  local(c, trimmed)
(
  this.str    = str;
  this.len    = strlen(str);
  this.cursor = 0;

  // Trim the line end
  (this.len > 0)?(

    trimmed = 0;
    while(this.len > 0 && !trimmed)
    (
      c = str_getchar(this.str, this.len-1);
      (isBlankChar(c))?(
        this.len -= 1;
      ):(
        trimmed = 1;
      );
    );
  );

  // Trim the line start
  this.FSCTX_EatBlank();
);

function FSCTX_ReadLibParam(p)
(
  (this.FSCTX_AtEnd())?(
    // Refuse to read
    strcpy(p,"");
    -1;
  ):(
    this.FSCTX_EatNextToken();
    strcpy_substr(p,this.str,this.tok_start,this.tok_len);
    this.tok_len;
  );
);

// Precalculates thumbnail for FSet function curve
// By sub-sampling / applying master curve
function precalcFSetFunctionPreview(set_num, row_num, col_num)
  local(vi, off, curve_addr, preview_addr)
(
  vi = 0;
  curve_addr    = getFSetFunctionCurveAddress(set_num, row_num, col_num);
  preview_addr  = getFSetFunctionPreviewAddress(set_num, row_num, col_num);
  while(vi < PREVIEWSIZE)
  (
    gmem[preview_addr+vi] = applyGmemCurve(curve_addr, vi/(PREVIEWSIZE-1));
    vi += 1;
  );
);

function addFunctionToFSet(set_num, row_num, col_num, func_path)
  local(handle, ctx, set_addr, curve_addr, preview_addr, set_name, val, vcount, vi, fname, cnum, p1, str)
(
  set_addr = getFSetAddress(set_num);

  fname = #;
  sprintf(fname,"talagan_MIDI CC Mapper X/func/%s.txt",func_path);

  handle = file_open(fname);

  (handle != -1)?(
    vcount = 0;

    while(file_avail(handle)>0)
    (
      str = #;
      file_string(handle,str);

      ctx = 0;
      ctx.FSCTX_BuildFromLine(str);

      // Coments are available through # or @, ignore these lines.
      // Also ignore blank lines.
      // (reapack uses @ for some directives).
      (!ctx.FSCTX_AtEnd() && ctx.FSCTX_NextChar() != 0x23 && ctx.FSCTX_NextChar() != 0x40)?(

        p1 = #;
        ctx.FSCTX_ReadLibParam(p1);
        match("%f",p1,val);

        (vcount < CURVESIZE)?(
          gmem[GMEM_LOAD_CURVE_BUF + vcount] = val;
        );

        vcount += 1;
      );
    );

    (vcount == CURVESIZE)?(

      // File is OK, accept curve
      // Copy to destination.
      vi         = 0;
      curve_addr = getFSetFunctionCurveAddress(set_num, row_num, col_num);

      while(vi < CURVESIZE)
      (
        // Copy
        gmem[curve_addr+vi] = gmem[GMEM_LOAD_CURVE_BUF+vi];
        vi+=1;
      );

      precalcFSetFunctionPreview(set_num, row_num, col_num);
      setFSetFunctionDefined(set_num, row_num, col_num, 1);
    );

    file_close(handle);
  );
);

function xn(x01,n) (
  pow(x01,n);
);
function ixn(x01,n) (
  pow(x01, 1.0/n);
);
function expnx(x01,n) (
  (exp(n * x01) - 1)/(exp(n)-1);
);
function iexpnx(x01, n) (
  log( x01 * (exp(n) - 1) + 1)/n;
);
function circr(x01,r)
  local(alpha)
(
  alpha   = 0.5 * (1 - sqrt(2*r*r - 1));
  (1 - alpha) - sqrt(r*r - (x01-alpha)*(x01-alpha));
);


function xf(pid, x01, n) (
  (pid == FSET_PARAMETRIC_XN_ID)?(xn(x01,n)):(expnx(x01,n));
);
function ixf(pid, x01, n) (
  (pid == FSET_PARAMETRIC_XN_ID)?(ixn(x01,n)):(iexpnx(x01,n));
);

function xfStepBL(pid, x01, n) (
  (x01 <= 0.5)?(
    x01 = 2 * x01;
    xf(pid, x01 , n)/2;
  ):(
    x01 = 2 * (1 - x01);
    1 - xf(pid, x01, n)/2;
  );
);

function xfStepBR(pid, x01, n) (
  (x01 <= 0.5)?(
    x01 = 2 * x01;
    (1 - ixf(pid, 1 - x01, n))/2;
  ):(
    x01 = 2 * (1 - x01);
    1 - (1 - ixf(pid, 1 - x01, n))/2;
  );
);

function xfStepTR(pid, x01, n) (
  (x01 <= 0.5)?(
    x01 = 2 * x01;
    (1 - xf(pid, 1 - x01, n))/2;
  ):(
    x01 = 2 * (1 - x01);
    1 - (1 - xf(pid, 1 - x01, n))/2;
  );
);

function xfStepTL(pid, x01, n) (
  (x01 <= 0.5)?(
    ixf(pid, 2 * x01, n)/2;
  ):(
    1 - ixf(pid, 2 * (1 - x01), n)/2;
  );
);

function circStepBL(x01, n) (
  (x01 <= 0.5)?(
    x01 = 2 * x01;
    circr(x01 , n)/2;
  ):(
    x01 = 2 * (1 - x01);
    1 - circr(x01, n)/2;
  );
);
function circStepTR(x01, n) (
  (x01 <= 0.5)?(
    x01 = 2 * x01;
    (1 - circr(1 - x01, n))/2;
  ):(
    x01 = 2 * (1 - x01);
    1 - (1 - circr(1 - x01, n))/2;
  );
);


function xnExpnxFamilyVal(pid, row_num, col_num, x01, n, point_count)
  local(ret)
(
  ret = -1;
  (row_num == 0)?(
    (col_num == 0)?(
      ret = xf(pid, x01, n);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = xf(pid, x01, n);
    );
    (col_num == 3)?(
      x01 = 1 - x01;
      ret = 1 - ixf(pid, x01, n);
    );
    (col_num == 4)?(
      ret = 1 - ixf(pid, x01, n);
    );
  );
  (row_num == 1)?(
    (col_num == 0)?(
      x01 = 1 - x01;
      ret = 1 - xf(pid, x01, n);
    );
    (col_num == 1)?(
      ret = 1 - xf(pid, x01, n);
    );
    (col_num == 3)?(
      ret = ixf(pid, x01, n);
    );
    (col_num == 4)?(
      x01 = 1 - x01;
      ret = ixf(pid, x01, n);
    );
  );
  (row_num == 2)?(
    (col_num == 0)?(
      ret = xfStepBL(pid, x01, n);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = xfStepBL(pid, x01, n);
    );
    (col_num == 3)?(
      ret = xfStepBR(pid, x01, n);
    );
    (col_num == 4)?(
      x01 = 1 - x01;
      ret = xfStepBR(pid, x01, n);
    );
  );
  (row_num == 3)?(
    (col_num == 0)?(
      ret = xfStepTR(pid, x01, n);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = xfStepTR(pid, x01, n);
    );

    (col_num == 3)?(
      ret = xfStepTL(pid, x01, n);
    );
    (col_num == 4)?(
      x01 = 1 - x01;
      ret = xfStepTL(pid, x01, n);
    );
  );
  (row_num == 4)?(
    (col_num == 0)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        xf(pid, 1 - x01, n);
      ):(
        x01 = 2 * (1 - x01);
        xf(pid, 1 - x01, n);
      );
    );
    (col_num == 1)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        1 - xf(pid, 1 - x01, n);
      ):(
        x01 = 2 * (1 - x01);
        1 - xf(pid, 1 - x01, n);
      );
    );
    (col_num == 2)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        xfStepBL(pid, x01, n);
      ):(
        x01 = 2 * (1 - x01);
        xfStepBL(pid, x01, n);
      );
    );
    (col_num == 3)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        1 - xfStepBL(pid, x01, n);
      ):(
        x01 = 2 * (1 - x01);
        1 - xfStepBL(pid, x01, n);
      );
    );
  );
  ret;
);


function circFamilyVal(pid, row_num, col_num, x01, n, point_count)
  local(r, d, ret)
(
  // Convert the parameter to a radius

  // The equation that gives the relation between the circle radius
  // And the distance from the circle to f(x) = 1 - x is
  //
  // (d*d + 0.5)/2d
  //
  // - The max distance possible is (sqrt(2)-1)/sqrt(2) = 0.29289321881345254 and
  //   is obtained for the unit circle
  // - The min distance possible is 0 but is obtained for r = +infinity
  //   so we'll stop at d = 0.001
  //
  // We thus map our parameter scale like this :
  //
  // n = 0 ----> d = 0.29289321881345254
  // n = 1 ----> d = 0.001

  d = n * (0.29289321881345254 - 0.001) + 0.001;
  r = (d*d + 0.5)/(2*d);

  ret = -1;
  (row_num == 0)?(
    (col_num == 0)?(
      ret = circr(x01, r);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = circr(x01, r);
    );
  );
  (row_num == 1)?(
    (col_num == 0)?(
      x01 = 1 - x01;
      ret = 1 - circr(x01, r);
    );
    (col_num == 1)?(
      ret = 1 - circr(x01, r);
    );
  );
  (row_num == 2)?(
    (col_num == 0)?(
      ret = circStepBL(x01, r);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = circStepBL(x01, r);
    );
  );
  (row_num == 3)?(
    (col_num == 0)?(
      ret = circStepTR(x01, r);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = circStepTR(x01, r);
    );
  );
  (row_num == 4)?(
    (col_num == 0)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        circr(1 - x01, r);
      ):(
        x01 = 2 * (1 - x01);
        circr(1 - x01, r);
      );
    );
    (col_num == 1)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        1 - circr(1 - x01, r);
      ):(
        x01 = 2 * (1 - x01);
        1 - circr(1 - x01, r);
      );
    );
    (col_num == 2)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        circStepBL(x01, r);
      ):(
        x01 = 2 * (1 - x01);
        circStepBL(x01, r);
      );
    );
    (col_num == 3)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        1 - circStepBL(x01, r);
      ):(
        x01 = 2 * (1 - x01);
        1 - circStepBL(x01, r);
      );
    );
  );
  ret;
);


function linFamilyVal(row_num, col_num, x01, cut, point_count)
  local(ret, granu)
(
  // Because we generate some discontinuous functions
  // Handle special cases where the "cut" param is very close to 0 or 1
  granu = 1/(point_count-1);
  (cut != 0 && cut !=1)?(
    (cut < granu)?(
      // Force rounding to first non-zero slot
      cut = granu;
    ):(
      (cut > (1 - granu))?(
        // Force rounding to last non-1 slot
        cut = 1-granu;
      ):(
        ( (row_num == 1 && (col_num == 2 || col_num == 3)) ||
          (row_num == 2 && (col_num == 2 || col_num == 3)) ||
          (row_num == 3 && (col_num == 0 || col_num == 1 || col_num == 2 || col_num == 3)) ||
          (row_num == 4 && (col_num == 0 || col_num == 1 || col_num == 2 || col_num == 3))
        )?(
          // There are situations (peeks) where we want to be sure that the max is always reached
          // And that the cut matches a slot.

          cut = granu * (roundi(cut*(point_count-1)));
        );
      );
    );
  );

  ret = -1;
  (row_num == 0)?(

    (col_num == 0)?(
      ret = x01;
    );
    (col_num == 1)?(
      ret = 1 - x01;
    );
  );

  (row_num == 1)?(
    (col_num == 0)?(
      ret = (cut == 0)?(1):( (x01<cut || x01==cut)?(x01/cut):(1));
    );
    (col_num == 1)?(
      ret = (cut == 1)?(1):( (x01<cut || x01==cut)?(1):(1 - (x01-cut)/(1-cut)));
    );
    (col_num == 2)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = (x01<cut)?( x01/cut ):( (x01 > 1 - cut)?( (1 - x01)/cut ):( 1 ) );
    );
    (col_num == 3)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = ( (x01<cut-0.00001) || (x01>(1-cut) )?(0):(1));
    );
    (col_num == 4)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = (x01<cut)?(0):( (x01>(1-cut))?(1):( (x01-cut)/(1-2*cut)));
    );
    (col_num == 5)?(
      ret = (cut == 1)?(0):( (x01<cut)?(0):(1));
    );
  );

  (row_num == 2)?(
    (col_num == 1)?(
      ret = (x01>cut || x01 == cut)?((x01-cut)/(1-cut)):(0);
    );
    (col_num == 0)?(
      ret = (cut == 0)?(0):((x01<cut || x01==cut)?(1-(x01/cut)):(0) );
    );
    (col_num == 2)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = 1 -((x01<cut)?( x01/cut ):( (x01 > 1 - cut)?( (1 - x01)/cut ):( 1 )));
    );
    (col_num == 3)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = ((x01<cut-0.00001 || x01>(1-cut))?(1):(0));
    );
    (col_num == 4)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = 1 - ((x01<cut)?(0):((x01>(1-cut))?(1):( (x01-cut)/(1-2*cut))));
    );
    (col_num == 5)?(
      ret = (cut == 1)?(1):((x01>cut || x01 == cut)?(0):(1));
    );
  );

  (row_num == 3)?(

    (col_num == 0)?(
      ret = (cut == 0)?(0):((x01<cut || x01==cut)?(x01/cut):(0));
    );
    (col_num == 1)?(
      ret = (cut == 1)?(0):((x01>cut || x01==cut)?(1 - (x01-cut)/(1-cut)):(0));
    );
    (col_num == 2)?(
      ret = (cut == 0)?(0):((x01<cut || x01==cut)?(x01):(0));
    );
    (col_num == 3)?(
      ret = (cut == 1)?(0):((x01>cut || x01==cut)?(1-x01):(0));
    );
    (col_num == 4)?(
      ret = (cut == 1)?(0):((x01>cut || x01==cut)?(x01):(0));
    );
    (col_num == 5)?(
      ret = (cut == 0)?(0):((x01<cut || x01==cut)?(1-x01):(0));
    );
  );

  (row_num == 4)?(
    (col_num == 0)?(
      ret = 1 - ((cut == 0)?(0):((x01<cut || x01==cut)?(x01/cut):(0)));
    );
    (col_num == 1)?(
      ret = 1 - ((cut == 1)?(0):((x01>cut || x01==cut)?(1 - (x01-cut)/(1-cut)):(0)));
    );
    (col_num == 2)?(
      ret = 1 - ((cut == 0)?(0):((x01<cut || x01==cut)?(x01):(0)));
    );
    (col_num == 3)?(
      ret = 1 - ((cut == 1)?(0):((x01>cut || x01==cut)?(1-x01):(0)));
    );
    (col_num == 4)?(
      ret = 1 - ((cut == 1)?(0):((x01>cut || x01==cut)?(x01):(0)));
    );
    (col_num == 5)?(
      ret = 1 - ((cut == 0)?(0):((x01<cut || x01==cut)?(1-x01):(0)));
    );
  );

  ret;
);

function parametricSetVal(pid, row_num, col_num, x01, n, point_count) (
  (pid == FSET_PARAMETRIC_XN_ID || pid == FSET_PARAMETRIC_EXPNX_ID)?(
    xnExpnxFamilyVal(pid, row_num, col_num, x01, n, point_count);
  ):(pid == FSET_PARAMETRIC_CIRCN_ID)?(
    circFamilyVal(pid, row_num, col_num, x01, n, point_count);
  ):(
    linFamilyVal(row_num, col_num, x01, n, point_count);
  );
);

function precalcParametricSet(set_num)
  local(pid, ri, ci, si, param, x01, func_address, preview_address)
(
  param = getFSetParameter(set_num);
  pid   = getFSetParametricID(set_num);

  ri = 0;
  while(ri < FSET_ROW_COUNT)
  (
    ci = 0;
    while(ci < FSET_COL_COUNT)
    (
      // Calculate value at 0. If -1, the col/row is not supported.
      (parametricSetVal(pid, ri, ci, 0, param, CURVESIZE) != -1)?(

        // Compute CURVE and PREVIEW.

        // For the preview, use fine-grained computation
        // instead of sub-sampling algorithm.
        // results will benefit from the visual "hacks"

        // CURVE
        func_address = getFSetFunctionCurveAddress(set_num, ri, ci);
        si = 0;
        while(si < CURVESIZE)
        (
          x01 = si/(CURVESIZE - 1);
          gmem[func_address + si] = parametricSetVal(pid, ri, ci, x01, param, CURVESIZE);
          si += 1;
        );

        // PREVIEW
        preview_address = getFSetFunctionPreviewAddress(set_num, ri, ci);
        si = 0;
        while(si < PREVIEWSIZE)
        (
          x01 = si/(PREVIEWSIZE - 1);
          gmem[preview_address + si] = parametricSetVal(pid, ri, ci, x01, param, PREVIEWSIZE);
          si += 1;
        );

        setFSetFunctionDefined(set_num, ri, ci, 1);
      );
      ci += 1;
    );
    ri += 1;
  );
);

function createLinearParametricFSet()
  local(set_num)
(
  set_num = createFSet("|lin|",   "Linear",   "A set of linear curves with adjustable cut.");
  setFSetIsParametric(set_num,1);
  setFSetParametricID(set_num, FSET_PARAMETRIC_LINEAR_ID);
  setFSetParameter(set_num, 0.5);
  precalcParametricSet(set_num);
);

function createExpNXParametricFSet()
  local(set_num)
(
  set_num = createFSet("|expnx|", "exp(n.x)", "A set of functions based on the exp(n^x) family.");
  setFSetIsParametric(set_num,1);
  setFSetParametricID(set_num, FSET_PARAMETRIC_EXPNX_ID);
  setFSetParameter(set_num, 2);
  precalcParametricSet(set_num);
);

function createXNParametricFset()
  local(set_num)
(
  set_num = createFSet("|xn|",    "x^n",      "A set of functions based on the x^n family.");
  setFSetIsParametric(set_num,1);
  setFSetParametricID(set_num, FSET_PARAMETRIC_XN_ID);
  setFSetParameter(set_num, 2);
  precalcParametricSet(set_num);
);

function createCircNParametricFset()
  local(set_num)
(
  set_num = createFSet("|circn|", "Circle",  "A set of functions based on circles.");
  setFSetIsParametric(set_num,1);
  setFSetParametricID(set_num, FSET_PARAMETRIC_CIRCN_ID);
  setFSetParameter(set_num, 1);
  precalcParametricSet(set_num);
);


// Reads functions library from file file 'file_name'
function readLibFile(lib_name)
  local(handle, lc, str, fset_num, p1, p2, p3, p4, p5, p6, row_num, col_num, file_ok)
(
  handle  = file_open(lib_name);
  file_ok = (handle != -1);

  lc = 0;

  while(file_avail(handle)>0)
  (
    str = #;
    file_string(handle,str);

    ctx = 0;
    ctx.FSCTX_BuildFromLine(str);

    // Comments are available through # or @
    // (reapack uses @ for some directives)
    (!ctx.FSCTX_AtEnd() && ctx.FSCTX_NextChar() != 0x23 && ctx.FSCTX_NextChar() != 0x40)?(

      // Ok, we have a non commented line. Parse it.
      p1 = #; p2 = #; p3 = #; p4 = #; p5 = #; p6 = #;

      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p1));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p2));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p3));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p4));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p5));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p6));

      // Parametric sets commands
      (strcmp(p1, "addpset") == 0)?(
        (strcmp(p2,"linear")  == 0)?( createLinearParametricFSet() );
        (strcmp(p2,"expnx")   == 0)?( createExpNXParametricFSet() );
        (strcmp(p2,"xn")      == 0)?( createXNParametricFset() );
        (strcmp(p2,"circn")   == 0)?( createCircNParametricFset() );
      );

      // Non parametric set command
      (strcmp(p1, "addset") == 0)?(
        (strlen(p2)>0)?(
          fset_num = findFSetById(p2);
          (fset_num == -1)?(
            createFSet(p2, p3, p4);
          );
        );
      );

      // Add function file to non-parametric set
      (strcmp(p1, "addfunc") == 0)?(
        // p2 : set
        // p3 : row
        // p4 : col
        // p5 : subpath
        (strlen(p2)>0 && strlen(p3)>0 && strlen(p4)>0 && strlen(p5)>0)?(

          fset_num = findFSetById(p2);
          (fset_num != -1)?(

            row_num = 0;
            col_num = 0;
            match("%d",p3,row_num);
            match("%d",p4,col_num);

            (row_num >= 1 && row_num <= FSET_ROW_COUNT && col_num >= 1 && col_num <= FSET_COL_COUNT)?(
              row_num -= 1; // Human > Index
              col_num -= 1; // Human > Index

              addFunctionToFset(fset_num, row_num, col_num, p5);
            );
          );
        );
      );

    );

    lc+=1;
  );
  file_close(handle);

  (file_ok);
);

// Reset loaded libs (put back pointer to 0)
function clearLoadedLibs()
(
  gmem[GMEM_FSET_COUNT] = 0;
  GMEM_PTR              = GMEM_FSET_START;
  setCurrentFSet(NONE);
);

// Read lib files
function readLibFiles()
  local(success)
(
  clearLoadedLibs();

  // Try 'user_lib.txt'
  success = readLibFile("talagan_MIDI CC Mapper X/user_lib.txt");
  (!success)?(
    // If not present, try 'lib.txt'
    readLibFile("talagan_MIDI CC Mapper X/lib.txt");
  );

  (getFsetCount()>0)?(
    setCurrentFSet(0);
  );
);

/////////////////////////////////
//  MIDI Conversion functions  //
/////////////////////////////////

g_hres_h = 0;
g_hres_l = 0;

// Converts a floating value of a CC **between 0 and 1**
// To high/low parts of a 14-bit hres
// For CC #0 to #31 (with respective #32 to #63).
function midiCCHresF012I(f01)
  local(ival)
(
  // Clamp to 0..1 for safety
  f01  = max(min(f01,1),0);

  // Convert to 14-bit space
  ival = roundi(f01 * 16383);

  // Floor to int for the high part
  g_hres_h  = (ival >> 7);
  g_hres_l  = ival & 0x7F;
);

// Inverse of midiCCHresF012I
function midiCCHresI2F01(high,low)
  local(val01, high, low, ival)
(

  // Sanitize
  high = max(min(high,127),0);
  low  = max(min(low,127),0);

  // 14-bit value
  ival = (high << 7) + low;

  // Put it in 0-1 space
  val01 = ival/16383;
);

// Converts a floating value of a key velocity **between 0 and 1**
// To high/low parts of a 14-bit hres
//
// Specification for this
// https://forum.cockos.com/showthread.php?t=83782
function midiVelocityHresF012I(f01)
  local(ival)
(

  // Clamp to 0..1 for safety
  f01  = max(min(f01,1),0);

  // Convert to 14-bit space
  // Caution : only 16256+1 values are possible (127*128 non zero values + the zero case)
  // (All LSB values for MSB=0 NOTE OFF are not allowed)
  ival = roundi(f01 * 16256);

  (ival==0)?(
    g_hres_h = 0;
    g_hres_l = 0;
  ):(
    // ival is in [1..16256] so put it in [0..16255]
    ival -= 1;
    // Floor to int for the high part
    // Add 1 for NOTE_ON
    g_hres_h  = (ival >> 7)+1;
    g_hres_l  = ival & 0x7F;
  )
);

// Inverse of midiVelocityHresF012I
function midiVelocityHresI2F01(high,low)
  local(val01, ival)
(

  // Sanitize
  high = max(min(high,127),0);
  low  = max(min(low,127),0);

  high==0?(
    // If high is equal to 0
    // Low = 0 is not allowed for NOTE OFF compatibility
    // So just return 0, it's a NOTE OFF, period.
    0;
  ):(

    // This said, we can start at 0.
    high = high-1;

    // 14-bit value
    ival = (high << 7) + low;

    // Avoid the zero case, ival is between [0..16255] so put all between [1..16256]
    ival += 1;

    // Put it in 0-1 space
    // Only 16256+1 values are available since we rejected all LSB values for MSB=0
    val01 = ival/16256;
    val01 = max(min(val01,1),0);
  );
);

////////////////////////////////////
//  Keyboard geography functions  //
////////////////////////////////////

// Octave number for a floating x axis of white keys
function octaveForBottomPos(keyboard_floating_pos) (
  floor(keyboard_floating_pos/7);
);

// Octave note for a floating x axis of white keys
// For the bottom row of the keyboard (only white keys here)
function octaveNoteForBottomPos(keyboard_bottom_floating_pos) (
  OCTAVE_LOOKUP_BOTTOM[floor(keyboard_bottom_floating_pos) % 7];
);

// Is key black?
function keyIsBlack(key_num) (
  OCTAVE_BLACK_KEY_LOOKUP[key_num % 12] == 1;
);

// Key octave
function octaveForKey(key_num) (
  floor(key_num / 12);
);

// Key for midi note
function midiNoteToKey(midi_note) (
  midi_note; // A0
);

// Midi note to key
function keyToMidiNote(key) (
  key; // A0
);

///////////////////
// CC Functions  //
///////////////////

function midiCCName(midi_cnum) (
  (midi_cnum == 128)?("Channel Pressure (virtual CC)"):(midi_cnum);
);

// For a #CC, returns LSB counterpart or -1 if it hasn't.
function ccLsbCounterpart(ccnum) local(ret) (
  ret = NONE;

  (ccnum>=0 && ccnum < 32)?(
    ret = ccnum + 32;
  );

  ret;
);

// For a #CC, returns MSB counterpart or -1 if it hasn't.
function ccMsbCounterpart(ccnum) local(ret) (
  ret = NONE;

  (ccnum>=32 && ccnum < 64)?(
    ret = ccnum - 32;
  );

  ret;
);

function msbCCForAggregatedHRCC(ccnum) (
  (ccnum >= 32 && ccnum < 64)?(ccnum - 32):(ccnum);
);
function lsbCCForAggregatedHRCC(ccnum) (
  (ccnum >= 0 && ccnum < 32)?(ccnum + 32):(ccnum);
);
function isAMsbCC(ccnum) (
  (ccnum >= 0 && ccnum < 32);
);
function isALsbCC(ccnum) (
  (ccnum >= 32 && ccnum < 64);
);
function isAHighResComponentCC(ccnum) (
  (ccnum >= 0 && ccnum < 64); // MSB or LSB
);

function isHighResPrefixCC(ccnum) (
  (ccnum == 88);
);


////////////////////////////
// GLOBAL SETTINGS ACCESS //
////////////////////////////

// Midi BUS
function midiBusInput() (
  (MIDI_BUS_INPUT[0]);
);
function midiBusOutput() (
  (MIDI_BUS_OUTPUT[0]);
);

function isKeyboardFilteringEnabled() (
  (KEYBOARD_FILTERING_ENABLED[0] == 1);
);

function isKeyboardTranspositionEnabled() (
  (KEYBOARD_TRANSPOSE_ENABLED[0] == 1);
);
function keyboardInputChannel() (
  KB_INPUT_CHANNEL[0];
);
function shouldDropUnroutedCCMessages() (
  (DROP_UNROUTED_CC_MESSAGES[0] == 1);
);
function shouldDropUnroutedNoteMessages() (
  (DROP_UNROUTED_NOTE_MESSAGES[0] == 1);
);
function shouldDropUnroutedPitchBendMessages() (
  (DROP_UNROUTED_PITCH_BEND_MESSAGES[0] == 1);
);
function shouldDropUnroutedPolyphonicAfterTouchMessages() (
  (DROP_UNROUTED_AT_POLY_MESSAGES[0] == 1);
);

//////////////
// CONTROLS //
//////////////

function baseCurveAddress(cnum)
(
  (cnum <0 || cnum >= CONTROL_COUNT)?(NONE):(
    CURVES + (cnum * CURVESIZE)
  );
);

function morphCurveAddress(cnum)
(
  (cnum <0 || cnum >= CONTROL_COUNT)?(NONE):(
    CONTROL_MORPH_CURVES + (cnum * CURVESIZE)
  );
);

function controlInputChannel(control) (
  CONTROL_CHAN_SRCS[control];
);
function controlOutputChannel(control) (
  CONTROL_CHAN_DSTS[control];
);

function isControlEnabled(control) (
  (CONTROL_ENABLED[control] == 1);
);
function isControlForRealCC(control) (
  (control >=0 && control<CONTROL_VELOCITY_START);
);
function isControlVelocity(control) (
  (control >= CONTROL_VELOCITY_START && control < CONTROL_VELOCITY_START + KB_RANGE_COUNT);
);
function isControlAfterTouch(control) (
  (control >= CONTROL_AFTERTOUCH_START && control < CONTROL_AFTERTOUCH_START + KB_RANGE_COUNT);
);
function isControlPitchBend(control) (
  (control == CONTROL_PITCH_BEND);
);

function isControlHighResCapableForInput(control) (
  (isControlVelocity(control) || (isControlForRealCC(control) && isAHighResComponentCC(CONTROL_SRCS[control])));
);
function isControlHighResCapableForOutput(control) (
  (isControlVelocity(control) || (isControlForRealCC(control) && isAHighResComponentCC(CONTROL_DSTS[control])));
);

function isMorphingEnabledForControl(cnum) (
  CONTROL_MORPH_ENABLED[cnum];
);
function isMorphCurveSelectedForControl(cnum) (
  CONTROL_MORPH_SELECTED[cnum];
);

function controlKBRange(control) (
  (isControlVelocity(control))?(control - CONTROL_VELOCITY_START):(
  (isControlAfterTouch(control))?(control - CONTROL_AFTERTOUCH_START):(
    NONE;
  ));
);
function velocityControlForKBRange(kbr) (
  CONTROL_VELOCITY_START + kbr;
);
function afterTouchControlForKBRange(kbr) (
  CONTROL_AFTERTOUCH_START + kbr;
);

// High res output? (it's a local param)
function isHighResMidiOutputEnabledForControl(control) (
  (CONTROL_HIGHRES_OUTPUT_ENABLED[control] == 1);
);
function isHighResMidiInputEnabledForControl(control) (
  (CONTROL_HIGHRES_INPUT_ENABLED[control] == 1);
);

function controlHasOperationalHighResOutput(control)
  local(hr_is_legit_for_control, hr_is_enabled)
(
  hr_is_legit_for_control = isControlHighResCapableForOutput(control);
  hr_is_enabled           = isHighResMidiOutputEnabledForControl(control);

  (hr_is_legit_for_control && hr_is_enabled);
);

function controlHasOperationalHighResInput(control)
  local(hr_is_legit_for_control, hr_is_enabled)
(
  hr_is_legit_for_control = isControlHighResCapableForInput(control);
  hr_is_enabled           = isHighResMidiInputEnabledForControl(control);

  (hr_is_legit_for_control && hr_is_enabled);
);

function value01ForControl(control, msb, lsb, input_not_output)
(
  ((input_not_output)?(controlHasOperationalHighResInput(control)):(controlHasOperationalHighResOutput(control)))?(
    (isControlVelocity(control))?(
      midiVelocityHresI2F01(msb,lsb);
    ):(
      midiCCHresI2F01(msb,lsb);
    );
  ):(
    (control == CONTROL_PITCH_BEND)?(msb/8191.0):(msb/127.0);
  );
);

function controlCurrentDrawingBound01(control,is_min)
  local(lsb, msb, mins_lsb_address, maxs_lsb_address, mins_msb_address, maxs_msb_address)
(
  (isMorphingEnabledForControl(control) && isMorphCurveSelectedForControl(control))?(
    mins_lsb_address = CONTROL_MORPH_MINS_LSB;
    maxs_lsb_address = CONTROL_MORPH_MAXS_LSB;
    mins_msb_address = CONTROL_MORPH_MINS_MSB;
    maxs_msb_address = CONTROL_MORPH_MAXS_MSB;
  ):(
    mins_lsb_address = CONTROL_MINS_LSB;
    maxs_lsb_address = CONTROL_MAXS_LSB;
    mins_msb_address = CONTROL_MINS_MSB;
    maxs_msb_address = CONTROL_MAXS_MSB;
  );

  msb = (is_min)?(mins_msb_address[control]):(maxs_msb_address[control]);
  lsb = (is_min)?(mins_lsb_address[control]):(maxs_lsb_address[control]);

  // Drawing limits are applied to output
  value01ForControl(control, msb, lsb, 0);
);

function controlCurrentMinDrawingBound01(control) (
  controlCurrentDrawingBound01(control,1);
);
function controlCurrentMaxDrawingBound01(control) (
  controlCurrentDrawingBound01(control,0);
);

function controlConditionalFilteringInInf01(control) (
  value01ForControl(control, CONTROL_VFILT_IN_INF_MSB[control], CONTROL_VFILT_IN_INF_LSB[control],1);
);
function controlConditionalFilteringInSup01(control) (
  value01ForControl(control, CONTROL_VFILT_IN_SUP_MSB[control], CONTROL_VFILT_IN_SUP_LSB[control],1);
);
function controlConditionalFilteringOutInf01(control) (
  value01ForControl(control, CONTROL_VFILT_OUT_INF_MSB[control], CONTROL_VFILT_OUT_INF_LSB[control],0);
);
function controlConditionalFilteringOutSup01(control) (
  value01ForControl(control, CONTROL_VFILT_OUT_SUP_MSB[control], CONTROL_VFILT_OUT_SUP_LSB[control],0);
);

function controlShouldPassThrough(control) (
  (CONTROL_PASS_THROUGH[control] == KEEP)
);

function controlName(cnum) (
  128+cnum;
);
function controlDescription(cnum) (
  128+CONTROL_COUNT+cnum;
);
function controlLabel(cnum) (
  128+CONTROL_COUNT+CONTROL_COUNT+cnum;
);
function controlLabelWithFallback(cnum) local(str) (
  str = controlLabel(cnum);
  (strlen(str)==0)?(str="?");
  str;
);

function selectedControlBaseCurveAddress() (
  baseCurveAddress(g_selected_control);
);

function selectedControlMorphCurveAddress() (
  morphCurveAddress(g_selected_control);
);

function selectedControlEditedCurveAddress() (
  (isMorphingEnabledForControl(g_selected_control) && isMorphCurveSelectedForControl(g_selected_control))?
  (selectedControlMorphCurveAddress()):
  (selectedControlBaseCurveAddress());
);
function morphSliderNumForControl(cnum) (

  // Slider num starts at 1, but cnum starts at 0.
  // 1,2 ... etc.

  (cnum == CONTROL_PITCH_BEND)?(1):(
  (cnum == CONTROL_MOD_WHEEL)?(2):(
    cnum + 2;
  ));
);
function morphValueForControl(cnum) (
  slider(morphSliderNumForControl(cnum));
);
function morphValueForCurrentControl() (
  morphValueForControl(g_selected_control);
);

function isMorphAutoEmitAvailableForControl(cnum) (
  (isControlForRealCC(cnum) || isControlPitchBend(cnum));
);

function isMorphAutoEmitEnabledForControl(cnum) (
  CONTROL_MORPH_AUTO_EMIT_ENABLED[cnum];
);

function resultCurveValueAt(cnum, i)
  local(base_curve, morph_curve, alpha)
(
  base_curve  = baseCurveAddress(cnum);

  (isMorphingEnabledForControl(cnum))?(
    alpha       = morphValueForControl(cnum);
    morph_curve = morphCurveAddress(cnum);

    base_curve[i] * (1 - alpha) + alpha * morph_curve[i];
  ):(
    base_curve[i];
  );
);

function outputActivityForControlStartAddress(cnum) (
  CONTROL_OUT_ACTIVITY_PER_CHANNEL + (cnum * 16);
);
function outputActivityForControlOnChannel(cnum, chan) (
  outputActivityForControlStartAddress(cnum)[chan];
);
function setOutputActivityForControlOnChannel(cnum, chan, val) (
  outputActivityForControlStartAddress(cnum)[chan] = val;
);

// Applies a curve, returns a value from 0 to 1.
function applyCurve(blk_control, x01)
  local(x01, sample_num_f, sample_num_il, sample_num_ir, sample_l, sample_r, curve_interp, alpha)
(
  // Do some clamping cleanup first
  x01 = min(max(x01,0),1);

  // Normalize reference space > Curve space
  sample_num_f  = 127 * x01;
  sample_num_il = floor(sample_num_f);
  sample_num_ir = ceil(sample_num_f);

  // Get left sample, right sample, and linear interpolation factor
  sample_l      = resultCurveValueAt(blk_control, sample_num_il);
  sample_r      = resultCurveValueAt(blk_control, sample_num_ir);
  alpha         = sample_num_f - sample_num_il;

  // Lerp : this will return a value between 0 and 127
  curve_interp  = (1-alpha) * sample_l + alpha * sample_r;

  // Return a value between 0 and 1.
  (curve_interp/127.0);
);


/////////////////////
// KEYBOARD RANGES //
/////////////////////

function isKBRangeTranspositionEnabled(k) (
  (KB_RANGE_TRANSPOSE_ENABLED[k] == 1);
);
function shouldTransposeKBRange(k) (
  isKeyboardTranspositionEnabled() && isKBRangeTranspositionEnabled(k)
);
function keyKBRange(k) (
  (KEYBOARD_KEY_COLORS[k])
);
function keyKBRangeResolved(k) (
  (!isKeyboardFilteringEnabled())?(0):(keyKBRange(k));
);
function kbRangeTranspose8VA(cr) (
  KB_RANGE_TRANSPOSE_8VA[cr];
);
function kbRangeTransposeSemiTones(cr) (
  KB_RANGE_TRANSPOSE_SEMI_TONES[cr];
);
function kbRangeTransposition(cr) (
  kbRangeTranspose8VA(cr)*12 + kbRangeTransposeSemiTones(cr)
);
function kbRangeOutputChannel(cr) (
  KB_RANGE_OUTPUT_CHANNEL[cr];
);
function setVelocityActivityDstChan(src_chan, key, dst_chan) (
  VELOCITY_ACTIVITY_PER_CHANNEL[src_chan * 128 + key] = dst_chan;
);
function getVelocityActivityDstChan(src_chan, key) (
  VELOCITY_ACTIVITY_PER_CHANNEL[src_chan * 128 + key];
);
function doesKbRangeAfterTouchFollowVelocity(k) (
  KB_RANGE_AT_FOLLOWS_VELOCITY[k];
);

///////////////////////////
// CONDITIONAL FILTERING //
///////////////////////////

function isConditionalFilteringAvailableForControl(cnum) (
  //(isControlForRealCC(cnum) || isControlPitchBend(cnum) || isControlAfterTouch(cnum));
  1;
);
function isConditionalFilteringEnabledForControl(cnum) (
  CONTROL_VFILT_ENABLED[cnum];
);
function isConditionalFilteringOperationalForControl(cnum) (
  isConditionalFilteringAvailableForControl(cnum) && isConditionalFilteringEnabledForControl(cnum);
);

function isConditionalFilteringInInfEnabledForControl(cnum) (
  CONTROL_VFILT_IN_INF_ENABLED[cnum];
);
function isConditionalFilteringOutInfEnabledForControl(cnum) (
  CONTROL_VFILT_OUT_INF_ENABLED[cnum];
);
function isConditionalFilteringInSupEnabledForControl(cnum) (
  CONTROL_VFILT_IN_SUP_ENABLED[cnum];
);
function isConditionalFilteringOutSupEnabledForControl(cnum) (
  CONTROL_VFILT_OUT_SUP_ENABLED[cnum];
);

function conditionalFilteringDstChanForControl(cnum) (
  CONTROL_VFILT_DST_CHAN[cnum];
);

/////////////////////
//     CC LEARN    //
/////////////////////

// Is the CC learnable? (in high res, we don't allow
// MSB controls to be learnable)
function isCCLearnableForControl(control, ccnum) (
  //(!isHighResMidiInputEnabledForControl(control))?(1):(!isAMsbCC(ccnum););
  // A CC is always learnable.
  // But we will lock the learn function on MSB if HR is enabled (MSB -> MSB, LSB -> MSB)
  // To avoid jittering
  1;
);
function enableCCLearn() (
  g_cc_learn = 1;
);
function disableCCLearn() (
  g_cc_learn = 0;
);
function isCCLearning() (
  (g_cc_learn == 1);
);

////////////////////////////
//  MAIN INIT FUNCTIONS   //
////////////////////////////

// Pre-calc knob tic positions
function initKnobTics() local(t, angle)
(
  t = 0;
  while(t<11)
  (
    angle = 90 + 30 + t*(36-6);
    angle *= $pi / 180;
    KNOB_TICS_X[t] = cos(angle);
    KNOB_TICS_Y[t] = sin(angle);
    t += 1;
  );
);

function knobTic(val, x_or_y)
  local(ret, v1, v2)
(
  // Clamp val between 0 and 1
  val = min(val,0.99999);
  val = max(0,val);

  val = 10*val;

  v1 = floor(val) | 0; // intify, v1 between 0 and 9
  v2 = (v1 + 1) | 0;

  (x_or_y == 1)?
  (
    ret = KNOB_TICS_X[v1] + (val-v1)*(KNOB_TICS_X[v2]-KNOB_TICS_X[v1]);
  ):
  (
    ret = KNOB_TICS_Y[v1] + (val-v1)*(KNOB_TICS_Y[v2]-KNOB_TICS_Y[v1]);
  );
);

function definitionInit()
(
  sharedGlobalVarInit();
  instanceGlobalVarInit();
  gmemGlobalVarInit();
  instanceMemoryMapInit();
  gmemMemoryMapInit();
);

function firstInit()
  local(c, curve, morph_curve, i)
(
  // Draw actor id
  g_actor_id = rand();

  // Load lib files if not loaded.
  (gmem[GMEM_LOADER_ID] == 0)?(
    gmem[GMEM_LOADER_ID] = g_actor_id;
    readLibFiles();
  );

  // Init midi control names
  initMidiCCNames();
  initPluginControlNames();

  // Init theme colors
  initThemes();

  // Init knob tics
  initKnobTics();

  // Init octave lookups
  initOctaveLookups();

  // Init curves for each control
  c = 0;
  while(c<CONTROL_COUNT) (

    // Init curves to identity
    CONTROL_ENABLED[c] = 1;

    curve       = baseCurveAddress(c);
    morph_curve = morphCurveAddress(c);
    i = 0;
    while(i<CURVESIZE) (
      curve[i] = i;
      morph_curve[i] = i;
      i+=1;
    );

    c += 1;
  );

  // Init channel options
  KB_INPUT_CHANNEL[0]     = 0;

  // Init controls
  c = 0; while(c<CONTROL_COUNT) (
    CONTROL_LAST_IN[c]                  = 0;
    CONTROL_LAST_OUT[c]                 = 0;
    CONTROL_ENABLED[c]                  = 0;
    CONTROL_SRCS[c]                     = 127;
    CONTROL_DSTS[c]                     = 127;
    CONTROL_CHAN_SRCS[c]                = ANY;
    CONTROL_CHAN_DSTS[c]                = AS_SRC;
    CONTROL_HIGHRES_OUTPUT_ENABLED[c]   = 0;

    CONTROL_MINS_LSB[c]                 = 0;
    CONTROL_MINS_MSB[c]                 = 0;
    CONTROL_MAXS_LSB[c]                 = 127;
    CONTROL_MAXS_MSB[c]                 = 127;

    CONTROL_MORPH_MINS_LSB[c]           = 0;
    CONTROL_MORPH_MINS_MSB[c]           = 0;
    CONTROL_MORPH_MAXS_LSB[c]           = 127;
    CONTROL_MORPH_MAXS_MSB[c]           = 127;

    (c == CONTROL_PITCH_BEND)?(
      // For pitch bend use msb+lsb with max val = 8191
      CONTROL_MAXS_MSB[c]               = 8191;
      CONTROL_MORPH_MAXS_MSB[c]         = 8191;
    );

    CONTROL_MORPH_SELECTED[c]           = 0;

    CONTROL_PASS_THROUGH[c]             = DROP;

    CONTROL_VFILT_IN_INF_LSB[c]         = 127;
    CONTROL_VFILT_IN_INF_MSB[c]         = 127;

    CONTROL_VFILT_IN_SUP_LSB[c]         = 0;
    CONTROL_VFILT_IN_SUP_MSB[c]         = 0;

    CONTROL_VFILT_OUT_INF_LSB[c]        = 127;
    CONTROL_VFILT_OUT_INF_MSB[c]        = 127;

    CONTROL_VFILT_OUT_SUP_LSB[c]        = 0;
    CONTROL_VFILT_OUT_SUP_MSB[c]        = 0;

    (isControlVelocity(c))?(
      CONTROL_VFILT_IN_SUP_MSB[c] = 1;
      CONTROL_VFILT_OUT_SUP_MSB[c] = 1;
    );

    (c == CONTROL_PITCH_BEND)?(
      // For pitch bend use msb+lsb with max val = 8191
      CONTROL_VFILT_IN_INF_MSB[c]       = 8191;
      CONTROL_VFILT_OUT_INF_MSB[c]      = 8191;
    );

    CONTROL_VFILT_IN_INF_ENABLED[c]     = 0;
    CONTROL_VFILT_IN_SUP_ENABLED[c]     = 0;
    CONTROL_VFILT_OUT_INF_ENABLED[c]    = 0;
    CONTROL_VFILT_OUT_SUP_ENABLED[c]    = 0;

    CONTROL_VFILT_ENABLED[c]            = 0;
    CONTROL_VFILT_DST_CHAN[c]           = DROP;

    c+=1
  );

  // Init kb range params
  c=0; while(c<KB_RANGE_COUNT) (
    KB_RANGE_TRANSPOSE_ENABLED[c]     = 1; // Enable by default, we already have a global switch
    KB_RANGE_TRANSPOSE_8VA[c]         = 0;
    KB_RANGE_TRANSPOSE_SEMI_TONES[c]  = 0;
    KB_RANGE_OUTPUT_CHANNEL[c]        = 0;
    c+=1;
  );

  // Init channel pressure range
  _OBS_CP_ASSOCIATED_KB_RANGE[0] = NONE;

  // Init other global params
  _OBS_HIGHRES_INPUT_ENABLED[0]               = 0;
  DROP_UNROUTED_CC_MESSAGES[0]                = 0;
  DROP_UNROUTED_NOTE_MESSAGES[0]              = 0;
  _OBS_DROP_UNROUTED_CP_MESSAGES[0]           = 0;
  DROP_UNROUTED_PITCH_BEND_MESSAGES[0]        = 0;
  DROP_UNROUTED_AT_POLY_MESSAGES[0]           = 0;

  // Init BUS Routing options
  MIDI_BUS_INPUT[0]   = 1;      // Set to 1, because it's what REAPER does by default
  MIDI_BUS_OUTPUT[0]  = AS_SRC;

  // Init mod wheel (don't enable by default anymore)
  CONTROL_SRCS[CONTROL_MOD_WHEEL]       = 1; // Midi mod wheel
  CONTROL_DSTS[CONTROL_MOD_WHEEL]       = 1; // Midi mod wheel

  // Init sustain pedal (don't enable by default anymore)
  CONTROL_SRCS[CONTROL_PEDALS_START]    = 64; // Midi sustain pedal
  CONTROL_DSTS[CONTROL_PEDALS_START]    = 64; // Midi sustain pedal

  GUI_MODE[0] = 1;
);

function fontInit() (
  gfx_setfont(2,"Arial",10,'b');  // Configure font number 2
  gfx_setfont(1,"Arial",10,'b');  // Configure font number 1
  gfx_setfont(0);
);

// Resets all sliders activity
// To be called on every initialisation (load/play/stop etc)
function reinitSliderActivity()
  local(cnum, sindex) (

  cnum = 0;
  g_slider_activity_this_block = 0;
  while(cnum < CONTROL_COUNT) (
    sindex                      = morphSliderNumForControl(cnum);
    MORPH_SLIDER_ACTIVITY[cnum] = 0;
    MORPH_SLIDER_TRACKING[cnum] = slider(sindex);
    cnum += 1;
  );
);

// Resets activity tracking for every output channel per control
// To be called on every initialisation (load/play/stop etc)
function reinitControlOutActivity()
  local(i, stop) (

  i    = 0;
  stop = 16 * CONTROL_COUNT; // 16 channels per control (46 controls)
  while(i < stop) (
    CONTROL_OUT_ACTIVITY_PER_CHANNEL[i] = -1;
    i += 1;
  );
);

// Enabled midi bus support
ext_midi_bus=1;

// Normally, the plugin gets resetted
// on effect load / sample playrate change / play / stop
// We need to detect a play/stop event for the auto-emit feature.
// So we have no other choice than putting ext_noinit to zero.
ext_noinit=0;

// Reload memory map each time.
// This may allow hot plug of new fx versions when developing.
// This will realloc and redefine quite a large number of vars, but will not clear their values because
// The initialization of those VALUES are done in firstInit ONLY and they are left untouched afterwards.
// It should be noted that the zeroing of the whole memory that could happen in @init by REAPER
// is prevented by the presence of a serialize block (that's what the doc says)
definitionInit();

// Reset slider morph activity on every init
// This is really important for play/stop to avoid cluttering the plugin
// With unuseful memorized states
reinitSliderActivity();
reinitControlOutActivity();

(LOADED_VERSION[0] == 0) ? (

  // Only do this once or reaper will destroy user data
  // On each init
  firstInit();
  fontInit();

  g_last_pen_modified_x = -1;
  g_selected_control    = NONE;
  LOADED_VERSION[0]     = 5.01;
);

//===========================================//
//==============    SLIDER     ==============//
//===========================================//
@slider

// Track morph sliders for changes.
function trackSliders()
  local(cnum, sindex, newval, oldval) (

  cnum = 0;
  while(cnum < CONTROL_COUNT) (
    sindex                      = morphSliderNumForControl(cnum);
    newval                      = slider(sindex);
    oldval                      = MORPH_SLIDER_TRACKING[cnum];

    // Slider activity detected ?
    // Mark morph slider for control as dirty
    // And also mark global slider activity as dirty
    (oldval != newval)?(
      MORPH_SLIDER_ACTIVITY[cnum]  = 1;
      g_slider_activity_this_block = 1;
    );

    MORPH_SLIDER_TRACKING[cnum] = newval;
    cnum += 1;
  );
);

trackSliders();

//===========================================//
//==============   SERIALIZE   ==============//
//===========================================//
@serialize

// CURRENT FILE FORMAT
FILE_FORMAT_1_0             = (1<<8)+0; // 1.0 (==256)
FILE_FORMAT_5_1             = (5<<8)+1; // 5.1
FILE_FORMAT_5_2             = (5<<8)+2; // 5.2

CURRENT_FILE_FORMAT_VERSION = FILE_FORMAT_5_2;

// ver : version used for loading/saving
function memwr(is_saving, ver)
  local(ccount,s,avail,obsolval, is_loading,
    green_vel_ctrl,red_vel_ctrl,green_curve,red_curve,
    maxs_lsb_were_present
  )
(
  is_loading = !is_saving;

  // Retro compatibility flag
  maxs_lsb_were_present = 0;

  ccount = (is_saving)?(CONTROL_COUNT):(0);

  // version and control count bytes introduced in V3.1a
  (ver>0)?(
    // Version number already managed
    // Now the control count.
    // Read it if we're reading, or save it if we're writing
    file_var(0,ccount);
    // And the first curve
    file_mem(0,CURVES+0,CURVESIZE);
  ):(
    is_loading?(
      // In that version there were 35 controls
      ccount = 35;
    );

    // Version number was in fact the first sample of the first curve.
    // There are still n-1 samples to read afterwards.
    file_mem(0,CURVES+1,CURVESIZE-1);
  );

  // Read/Write other (ccount-1) curves (first one handled separately for bw compatibility)
  file_mem(0,CURVES+CURVESIZE , (ccount-1) * CURVESIZE);

  // Flags
  file_mem(0,CONTROL_ENABLED  , ccount);

  // Srcs and dests
  file_mem(0,CONTROL_SRCS     , ccount);
  file_mem(0,CONTROL_DSTS     , ccount);

  // Descriptions
  s=0;while(s<ccount)
  (
    file_string(0,controlDescription(s));
    s+=1;
  );

  // Short descriptions
  s=0;while(s<ccount)
  (
    file_string(0,controlLabel(s));
    s+=1;
  );

  // Introduced in V3 (keyboard filtering)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,KEYBOARD_FILTERING_ENABLED,1);
    file_mem(0,KEYBOARD_KEY_COLORS+21,88);
  );

  // Introduced in V3.1a (transpose green / high res)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CONTROL_HIGHRES_OUTPUT_ENABLED, ccount);
    file_mem(0,KEYBOARD_TRANSPOSE_ENABLED,1);
    file_mem(0,_OBS_KEYBOARD_TRANSPOSE_8VA,1);
    file_mem(0,_OBS_KEYBOARD_TRANSPOSE_SEMI_TONES,1);
    file_mem(0,_OBS_HIGHRES_INPUT_ENABLED,1);
    file_mem(0,DROP_UNROUTED_CC_MESSAGES,1);

    (!is_saving)?(
      // RETRO COMPATIBILITY
      // Copy old global params to green range.
      // If newer params are available in the file data
      // They will be loaded right after and they will squash this.
      KB_RANGE_TRANSPOSE_ENABLED[0]     = KEYBOARD_TRANSPOSE_ENABLED[0]; // Deduce from global conf
      KB_RANGE_TRANSPOSE_8VA[0]         = _OBS_KEYBOARD_TRANSPOSE_8VA[0];
      KB_RANGE_TRANSPOSE_SEMI_TONES[0]  = _OBS_KEYBOARD_TRANSPOSE_SEMI_TONES[0];

      // HR MIDI Moved in 4.3 to individual params per control.
      // So convert the global option to individual option
      // For any control that would match.
      (_OBS_HIGHRES_INPUT_ENABLED[0] == 1)?(
        s=0;while(s<ccount)
        (
          ( isControlHighResCapableForInput(s) )?(
            CONTROL_HIGHRES_INPUT_ENABLED[s] = 1;
          );
          s+=1;
        );
      );
    );
  );

  // Introduced in V3.1d (theme selection)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CURRENT_THEME_NUM,1);
  );

  // Introduced in V3.3 (channel routing + min/max)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CONTROL_CHAN_SRCS, ccount);
    file_mem(0,CONTROL_CHAN_DSTS, ccount);
    file_mem(0,KB_INPUT_CHANNEL,1);
    file_mem(0,_OBS_KBG_OUTPUT_CHANNEL,   1); // Green
    file_mem(0,_OBS_KBR_OUTPUT_CHANNEL,   1); // Red
    file_mem(0,_OBS_KEYBOARD_VELOCITY_APPLY_TO, 1);
    file_mem(0,_OBS_KEYBOARD_TRANSPOSE_APPLY_TO,1);
    file_mem(0,CONTROL_MINS_MSB, ccount);
    file_mem(0,CONTROL_MINS_LSB, ccount);
    file_mem(0,CONTROL_MAXS_MSB, ccount);
    file_mem(0,CONTROL_MAXS_LSB, ccount);
    file_mem(0,DROP_UNROUTED_NOTE_MESSAGES,1);

    (!is_saving)?(
      (ccount <= 36)?(

        // Retro-compatibility for >= 3.3 and < 4.0
        // At that time there were only 36 controls (hence the test on ccount)
        // Only one velocity control (velocity was # 35)
        // So if ccount <= 36 it means there is no per-kbrange velocity handling
        // We have to reflect these settings to the new split structure

        // Loading old params : convert to new ones.
        KB_RANGE_OUTPUT_CHANNEL[0]        = _OBS_KBG_OUTPUT_CHANNEL[0]; // Green
        KB_RANGE_OUTPUT_CHANNEL[1]        = _OBS_KBR_OUTPUT_CHANNEL[0]; // Red

        // Copy green to red since that was shared at the time of 3.3.
        KB_RANGE_TRANSPOSE_8VA[1]         = KB_RANGE_TRANSPOSE_8VA[0];
        KB_RANGE_TRANSPOSE_SEMI_TONES[1]  = KB_RANGE_TRANSPOSE_SEMI_TONES[0];

        green_vel_ctrl = velocityControlForKBRange(0);
        red_vel_ctrl   = velocityControlForKBRange(1);

        // If val == 0, G and R are enabled
        obsolval = _OBS_KEYBOARD_TRANSPOSE_APPLY_TO[0];
        KB_RANGE_TRANSPOSE_ENABLED[0] = (obsolval == ANY || obsolval == 1); // Green
        KB_RANGE_TRANSPOSE_ENABLED[1] = (obsolval == ANY || obsolval == 2); // Red

        // Apply to => G/R ctrl enabled or not
        obsolval = _OBS_KEYBOARD_VELOCITY_APPLY_TO[0];
        CONTROL_ENABLED[green_vel_ctrl] = (obsolval == ANY || obsolval == 1); // Green
        CONTROL_ENABLED[red_vel_ctrl]   = (obsolval == ANY || obsolval == 2); // Red

        // Copy highres param
        CONTROL_HIGHRES_OUTPUT_ENABLED[red_vel_ctrl] = CONTROL_HIGHRES_OUTPUT_ENABLED[green_vel_ctrl];

        // Copy min/max
        CONTROL_MINS_LSB[red_vel_ctrl] = CONTROL_MINS_LSB[green_vel_ctrl];
        CONTROL_MINS_MSB[red_vel_ctrl] = CONTROL_MINS_MSB[green_vel_ctrl];
        CONTROL_MAXS_LSB[red_vel_ctrl] = CONTROL_MAXS_LSB[green_vel_ctrl];
        CONTROL_MAXS_MSB[red_vel_ctrl] = CONTROL_MAXS_MSB[green_vel_ctrl];

        // Curve was shared, so copy G to R.
        green_curve = baseCurveAddress(green_vel_ctrl);
        red_curve   = baseCurveAddress(red_vel_ctrl);
        s = 0; while(s < CURVESIZE) (
          red_curve[s] = green_curve[s];
          s += 1;
        );
      );
    );

    (is_loading && ver < FILE_FORMAT_5_1)?(
      // In 5.1, the max msb for pitch bend was converted to 8191 instead of 127.
      CONTROL_MAXS_MSB[CONTROL_PITCH_BEND] *= 8191/127.0;
    );
  );


  // Introduced in V3.5 (full keyboard filtering)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,KEYBOARD_KEY_COLORS,21);       //
    file_mem(0,KEYBOARD_KEY_COLORS+109,19);   // Skipped 21+88
    file_mem(0,_OBS_CURRENT_OCTAVA_OFFSET,1); // Was : octava offset (kb vis), removed and ignored.
  );

  // Introduced in V3.6
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,MIDI_BUS_INPUT,1);
    file_mem(0,MIDI_BUS_OUTPUT,1);
  );

  // Introduced in V4.0
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,KB_RANGE_TRANSPOSE_ENABLED, KB_RANGE_COUNT);
    file_mem(0,KB_RANGE_TRANSPOSE_8VA, KB_RANGE_COUNT);
    file_mem(0,KB_RANGE_TRANSPOSE_SEMI_TONES, KB_RANGE_COUNT);
    file_mem(0,KB_RANGE_OUTPUT_CHANNEL, KB_RANGE_COUNT);
    file_mem(0,DROP_UNROUTED_PITCH_BEND_MESSAGES, 1);
    file_mem(0,_OBS_DROP_UNROUTED_CP_MESSAGES, 1);
    file_mem(0,DROP_UNROUTED_AT_POLY_MESSAGES, 1);
    file_mem(0,_OBS_CP_ASSOCIATED_KB_RANGE, 1);
  );

  // Introduced in V4.2
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0, CONTROL_PASS_THROUGH, ccount);
  );

  // Introduced in V4.3
  avail = file_avail(0);
  (is_saving || avail>0)?(
    file_mem(0, CONTROL_HIGHRES_INPUT_ENABLED, ccount);
    file_mem(0, REVERSE_PITCH_BEND, 1);
  );

  // Introduced in V5.0
  avail = file_avail(0);
  (is_saving || avail > 0)?(
    file_mem(0,CONTROL_MORPH_ENABLED,  ccount);

    file_mem(0,CONTROL_MORPH_MINS_MSB, ccount);
    file_mem(0,CONTROL_MORPH_MINS_LSB, ccount);
    file_mem(0,CONTROL_MORPH_MAXS_MSB, ccount);
    file_mem(0,CONTROL_MORPH_MAXS_LSB, ccount);

    file_mem(0,CONTROL_MORPH_CURVES,   ccount * CURVESIZE);
    file_mem(0,CONTROL_MORPH_AUTO_EMIT_ENABLED, ccount);

    // It is not necessary to save morph parameter values.
    // Since they are linked to the sliders, reaper will save their values
    // As parameters of the JSFX instance.

    (is_loading && ver < FILE_FORMAT_5_1)?(
      // In 5.1, the max msb for pitch bend was converted to 8191 instead of 127.
      CONTROL_MORPH_MAXS_MSB[CONTROL_PITCH_BEND] *= 8191/127.0;
    );
  );

  // Introduced in V5.1
  avail = file_avail(0);
  (is_saving || avail > 0)?(

    file_mem(0,CONTROL_VFILT_IN_INF_LSB,  ccount);
    file_mem(0,CONTROL_VFILT_IN_INF_MSB,  ccount);
    file_mem(0,CONTROL_VFILT_IN_SUP_LSB,  ccount);
    file_mem(0,CONTROL_VFILT_IN_SUP_MSB,  ccount);

    file_mem(0,CONTROL_VFILT_OUT_INF_LSB, ccount);
    file_mem(0,CONTROL_VFILT_OUT_INF_MSB, ccount);
    file_mem(0,CONTROL_VFILT_OUT_SUP_LSB, ccount);
    file_mem(0,CONTROL_VFILT_OUT_SUP_MSB, ccount);

    file_mem(0,CONTROL_VFILT_IN_INF_ENABLED,  ccount);
    file_mem(0,CONTROL_VFILT_IN_SUP_ENABLED,  ccount);
    file_mem(0,CONTROL_VFILT_OUT_INF_ENABLED, ccount);
    file_mem(0,CONTROL_VFILT_OUT_SUP_ENABLED, ccount);

    file_mem(0,CONTROL_VFILT_ENABLED,   ccount);
    file_mem(0,CONTROL_VFILT_DST_CHAN,  ccount);

    (is_loading && ver < FILE_FORMAT_5_2)?(
      // Retro compatibility, before 5.2 the memory for these params were allocated but not used for velocity.
      // Initialize to the default value (1)
      s=0;while(s<ccount)
      (
        (isControlVelocity(s) )?(
          CONTROL_VFILT_IN_SUP_MSB[s]  = 1;
          CONTROL_VFILT_OUT_SUP_MSB[s] = 1;
        );
        s+=1;
      );
    );
  );

  // Introduced in V5.2
  avail = file_avail(0);
  (is_saving || avail > 0)?(
    file_mem(0,KB_RANGE_AT_FOLLOWS_VELOCITY, KB_RANGE_COUNT);
  );
);

function backupOrRestore() local(is_saving, check_ver, old_format) (

  is_saving  = (file_avail(0)<0);

  (is_saving)?(
    // SAVING ...
    // Always save to new format.
    file_var(0, CURRENT_FILE_FORMAT_VERSION);
    memwr(1, CURRENT_FILE_FORMAT_VERSION);
  ):
  (
    // LOADING ...
    // Reading the file
    // Have to manage the very old format ...
    check_ver = 0;
    file_var(0,check_ver);

    // Now, we put a version number >= 256.
    // The old format had a curve point on the first slot, so < 256 (between 0 and 127).
    old_format = (check_ver < 256);

    (old_format)?(
      // Repair first curve
      // The "ver" would not exist and is in fact the first sample of the first curve
      CURVES[0] = check_ver; // Yuuuk!!
      // Force the file format to 0.0
      memwr(0, 0);
    ):(
      // Format is > 1.0. Use standard loading.
      memwr(0, check_ver);
    );
  )
);

backupOrRestore();

//===========================================//
//===============     GFX     ===============//
//===========================================//
@gfx 970 705

//////////////////////////
// GENERIC UI FUNCTIONS //
//////////////////////////

function gfx_rgb(hex_col) (
  gfx_r = ((hex_col>>16)&0xFF)/255;
  gfx_g = ((hex_col>>8)&0xFF)/255;
  gfx_b = ((hex_col>>0)&0xFF)/255;
);

function gfx_xy(x,y) (
  gfx_x = x;
  gfx_y = y;
);
function pr(x,y) (
  gfx_x = x;
  gfx_y = y;
);
function px(v) (
  (!v)?(gfx_setpixel(gfx_r,gfx_g,gfx_b));
  gfx_x += 1;
);
function drawIconCopy(x,y) (
  pr(x,y+0);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+1);  px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);px(1);px(1);px(1);
  pr(x,y+2);  px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);
  pr(x,y+3);  px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);
  pr(x,y+4);  px(1);px(0);px(1);px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);
  pr(x,y+5);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+6);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(0);px(1);
  pr(x,y+7);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(0);px(1);
  pr(x,y+8);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+9);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+10); px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+11); px(1);px(0);px(1);px(1);px(0);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+12); px(1);px(0);px(0);px(0);px(0);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+13); px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+14); px(1);px(1);px(1);px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);
  pr(x,y+15); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
);
function drawIconPen(x,y) (
  pr(x,y+0);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);
  pr(x,y+1);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(0);px(1);px(1);px(1);
  pr(x,y+2);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+3);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);
  pr(x,y+4);  px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);
  pr(x,y+5);  px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);
  pr(x,y+6);  px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+7);  px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+8);  px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+9);  px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+10); px(1);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+11); px(1);px(0);px(0);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+12); px(1);px(0);px(0);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+13); px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+14); px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+15); px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);
);
function drawIconSmooth(x,y) (
  pr(x,y+0);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+1);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+2);  px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+3);  px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+4);  px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+5);  px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+6);  px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);
  pr(x,y+7);  px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);
  pr(x,y+8);  px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);
  pr(x,y+9);  px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);
  pr(x,y+10); px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);
  pr(x,y+11); px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);
  pr(x,y+12); px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(0);px(1);px(1);px(1);
  pr(x,y+13); px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(0);px(1);px(1);px(1);
  pr(x,y+14); px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);
  pr(x,y+15); px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(1);px(1);px(1);px(1);px(1);
);
function drawIconPaste(x,y) (
  pr(x,y+0);  px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+1);  px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+2);  px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);
  pr(x,y+3);  px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+4);  px(1);px(0);px(1);px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);
  pr(x,y+5);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+6);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(0);px(1);
  pr(x,y+7);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(0);px(1);
  pr(x,y+8);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+9);  px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+10); px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+11); px(1);px(0);px(1);px(1);px(0);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+12); px(1);px(0);px(1);px(1);px(0);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+13); px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+14); px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);
  pr(x,y+15); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
);
function drawIconVsym(x,y) (
  pr(x,y+0);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+1);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+2);  px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+3);  px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+4);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+5);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+6);  px(1);px(1);px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);
  pr(x,y+7);  px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+8);  px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+9);  px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);px(1);px(1);
  pr(x,y+10); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+11); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+12); px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+13); px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+14); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+15); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
);
function drawIconHsym(x,y) (
  pr(x,y+0);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+1);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+2);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+3);  px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+4);  px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+5);  px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);
  pr(x,y+6);  px(1);px(1);px(0);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+7);  px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+8);  px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(1);
  pr(x,y+9);  px(1);px(1);px(0);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+10); px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);
  pr(x,y+11); px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+12); px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+13); px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+14); px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+15); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
);
function drawIconMembuf(x,y) (
  pr(x,y+0);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+1);  px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+2);  px(1);px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);px(1);
  pr(x,y+3);  px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+4);  px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(0);px(1);px(1);
  pr(x,y+5);  px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(0);px(1);px(1);
  pr(x,y+6);  px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+7);  px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+8);  px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+9);  px(1);px(1);px(0);px(1);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+10); px(1);px(1);px(0);px(1);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+11); px(1);px(1);px(0);px(1);px(0);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+12); px(1);px(1);px(0);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(0);px(1);px(1);
  pr(x,y+13); px(1);px(1);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(0);px(1);px(1);
  pr(x,y+14); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
  pr(x,y+15); px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);px(1);
);
function editingCurveColor() (
  (isMorphingEnabledForControl(g_selected_control))?(
    (isMorphCurveSelectedForControl(g_selected_control))?(
      TH.CURVE_MORPH_SEL;
    ):(
      TH.CURVE_BASE_SEL;
    )
  ):(
    TH.CURVE;
  );
);
function tooltip(text,x,y)
  local(w,h,padding)
(
  padding = 4;
  gfx_rgb(0xFFFFAA);
  gfx_measurestr(text,w,h);
  gfx_rect(x-padding,y-padding,w+padding*2,h+padding*2);
  gfx_xy(x,y);
  gfx_rgb(0xAA7700);
  gfx_drawstr(text);
);

function gfx_rgb_control_high(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_HIGH):(TH.CONTROL_DISABLED_CONTRAST_HIGH) );
);
function gfx_rgb_control_mid(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_MID):(TH.CONTROL_DISABLED_CONTRAST_MID) );
);
function gfx_rgb_control_low(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_LOW):(TH.CONTROL_DISABLED_CONTRAST_LOW) );
);

function gfx_rgb_kbr_low(kbr,enabled)
  local(col)
(
  col = (enabled)?(TH.SW_B_OFF_H):(TH.SW_B_OFF);
  (enabled)?(
    (kbr==0)?(col = TH.KEY_BLACK_COLOR_0);
    (kbr==1)?(col = TH.KEY_BLACK_COLOR_1);
    (kbr==2)?(col = TH.KEY_BLACK_COLOR_2);
    (kbr==3)?(col = TH.KEY_BLACK_COLOR_3);
    (kbr==4)?(col = TH.KEY_BLACK_COLOR_4);
  ):(
    (kbr==0)?(col = TH.KEY_BLACK_COLOR_0_D);
    (kbr==1)?(col = TH.KEY_BLACK_COLOR_1_D);
    (kbr==2)?(col = TH.KEY_BLACK_COLOR_2_D);
    (kbr==3)?(col = TH.KEY_BLACK_COLOR_3_D);
    (kbr==4)?(col = TH.KEY_BLACK_COLOR_4_D);
  );

  gfx_rgb(col);
);


function bgColorForComboBox(combo_id)
  local(ret)
(
  ret = TH.BACKGROUND;

  (combo_id == "chan_out_range_0_spinbox" || combo_id == "kr_0_8va" || combo_id == "kr_0_st")?(ret = TH.KEY_BLACK_COLOR_0);
  (combo_id == "chan_out_range_1_spinbox" || combo_id == "kr_1_8va" || combo_id == "kr_1_st")?(ret = TH.KEY_BLACK_COLOR_1);
  (combo_id == "chan_out_range_2_spinbox" || combo_id == "kr_2_8va" || combo_id == "kr_2_st")?(ret = TH.KEY_BLACK_COLOR_2);
  (combo_id == "chan_out_range_3_spinbox" || combo_id == "kr_3_8va" || combo_id == "kr_3_st")?(ret = TH.KEY_BLACK_COLOR_3);
  (combo_id == "chan_out_range_4_spinbox" || combo_id == "kr_4_8va" || combo_id == "kr_4_st")?(ret = TH.KEY_BLACK_COLOR_4);

  ret;
);

function txtColorForComboBox(combo_id)
  local(ret)
(
  ret = TH.DYN_LABEL;

  (combo_id == "chan_out_range_0_spinbox" || combo_id == "kr_0_8va" || combo_id == "kr_0_st")?(ret = TH.KEY_COLOR_RANGE_TEXT);
  (combo_id == "chan_out_range_1_spinbox" || combo_id == "kr_1_8va" || combo_id == "kr_1_st")?(ret = TH.KEY_COLOR_RANGE_TEXT);
  (combo_id == "chan_out_range_2_spinbox" || combo_id == "kr_2_8va" || combo_id == "kr_2_st")?(ret = TH.KEY_COLOR_RANGE_TEXT);
  (combo_id == "chan_out_range_3_spinbox" || combo_id == "kr_3_8va" || combo_id == "kr_3_st")?(ret = TH.KEY_COLOR_RANGE_TEXT);
  (combo_id == "chan_out_range_4_spinbox" || combo_id == "kr_4_8va" || combo_id == "kr_4_st")?(ret = TH.KEY_COLOR_RANGE_TEXT);

  (combo_id == "min_spinbox_msb" || combo_id == "min_spinbox_lsb" || combo_id == "max_spinbox_msb" || combo_id == "max_spinbox_lsb")?(
    (isMorphingEnabledForControl(g_selected_control))?(
      (isMorphCurveSelectedForControl(g_selected_control))?(
        ret = TH.CURVE_MORPH_SEL;
      ):(
        ret = TH.CURVE_BASE_SEL;
      )
    );
  );

  ret;
);

function defaultTextForCombo(val)
  local(tmp)
(
  tmp = #;
  sprintf(tmp, "%d", val);
  tmp;
);

function textForChannelIn(val)
(
  (val == ANY)?("Any"):(
    defaultTextForCombo(val);
  );
);

function textForPassThrough(val)
(
  (val == KEEP)?("Yes (Keep)"):("No (Drop)");
);

function textForChannelOut(val)
(
  (val == AS_SRC)?("= In"):(
  (val == DROP)?("Drop"):(
    defaultTextForCombo(val);
  ));
);

function textForCC(val) (
  (val == CHANNEL_PRESSURE_FAKE_CC_NUM)?("CP"):(defaultTextForCombo(val));
);

function isInputChannelSpinbox(combo_id)
(
  ( combo_id == "chan_src_spinbox" ||
    combo_id == "midi_bus_input_widget" ||
    combo_id == "chan_in_keyboard_spinbox"
  );
);

function isOutputChannelSpinbox(combo_id)
(
  (
    combo_id == "chan_dst_spinbox" ||
    combo_id == "midi_bus_output_widget" ||
    combo_id == "chan_out_range_0_spinbox" ||
    combo_id == "chan_out_range_1_spinbox" ||
    combo_id == "chan_out_range_2_spinbox" ||
    combo_id == "chan_out_range_3_spinbox" ||
    combo_id == "chan_out_range_4_spinbox" ||
    combo_id == "chan_out_vfilt"
  );
);

function isPassThroughSpinbox(combo_id)
(
  combo_id == "pt_spinbox";
);

function isCCSpinbox(combo_id) (
  (combo_id == "cc_src_spinbox" || combo_id == "cc_dst_spinbox");
);

function textForComboBox(combo_id, val)
(
  (isInputChannelSpinbox(combo_id)?(textForChannelIn(val)):(
  (isOutputChannelSpinbox(combo_id)?(textForChannelOut(val)):(
  (isCCSpinbox(combo_id)?(textForCC(val)):(
  (isPassThroughSpinbox(combo_id)?(textForPassThrough(val)):(
    defaultTextForCombo(val);
  ))))))));
);

// Draws a enable/disable button
// This button is linked to an adress in memory : flag_address[flag_local_address].
// The only way I had found in EEL to use "pointers" was an array trick.
// I've just discovered pseudo objects, it could be a solution too.
function drawBistateButton(flag_address,flag_local_address,t,l,ontext,offtext,color_on,color_off,color_on_hover,color_off_hover,text_color_on,text_color_off)
  local(tmp, ontextw, offtextw, minitick,
        bb, br, bw, bh, bl, bt,
        in_rect, enabled)
(
  minitick = 0;

  tmp = 0; ontextw = 0; offtextw = 0;
  (ontext == "")?(
    minitick = 1;
  ):(
    gfx_measurestr(ontext, ontextw, tmp);
  );

  (offtext == "")?(
    minitick = 1;
  ):(
    gfx_measurestr(offtext, offtextw, tmp);
  );

  (minitick)?(
    bh = 10;
    bw = 10;
  ):(
    bh = 15;
    bw = max(ontextw,offtextw) + 10;
  );

  bl = l;
  bt = t;

  br = bl + bw;
  bb = bt + bh;

  enabled = flag_address[flag_local_address];
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y >= bt && mouse_y <= bb;

  in_rect ?(
    // Hover color
    gfx_rgb((enabled)?(color_on_hover):(color_off_hover));

    // Click
    mouse_click == 1 ? (
      flag_address[flag_local_address] = !flag_address[flag_local_address];
    );
  ):(
    // Not-hovered color
    gfx_rgb((enabled)?(color_on):(color_off));
  );
  gfx_rect(bl,bt,bw,bh);

  // Text color
  gfx_rgb((enabled)?(text_color_on):(text_color_off));
  gfx_y = t + 4;
  enabled?(
    gfx_x = l+(bw-ontextw)/2;
    gfx_drawstr(ontext);
  ):(
    gfx_x = l+(bw-offtextw)/2;
    gfx_drawstr(offtext)
  );
);

function drawStandardBistateButton(flag_address,flag_local_address,t,l,on_text,off_text) (
  drawBistateButton(flag_address,flag_local_address,t,l,on_text,off_text, TH.EN_B_ON ,TH.EN_B_OFF, TH.EN_B_ON_H, TH.EN_B_OFF_H, TH.EN_B_ON_TEXT, TH.EN_B_OFF_TEXT);
);

function drawSwitchButton(flag_address,flag_local_address,t,l,on_text,off_text) (
 drawBistateButton (flag_address,flag_local_address,t,l,on_text,off_text, TH.SW_B_ON ,TH.SW_B_OFF, TH.SW_B_ON_H, TH.SW_B_OFF_H, TH.SW_B_ON_TEXT, TH.SW_B_OFF_TEXT);
);


// ShortCut for a OnOff button with "Enabled"/"Bypass" texts
function drawEnableDisableButton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"Enabled","Disabled");
);

// ShortCut for a OnOff button with "Yes"/"No" texts
function drawYesNobutton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"Yes","No");
);

// ShortCut for a OnOff button with "On"/"Off" texts
function drawOnOffButton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"On","Off");
);

// - or + button for a spinbox
function drawAddOrSubButton(button_id,val_address,val_local_address,l,t,add_or_sub,minval,maxval,should_wrap)
   local(bl ,bt, br, bb, in_rect, val_shift, val_shift_abs, got_event, new_srcdstbtn_time, last_srcdstbtn_time, long_time_spent_on_button)
(
  got_event = 0;

  bl = l;
  bt = t;

  br = bl + 15;
  bb = bt + 15;

  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt);

  (mouse_click == 1 && in_rect)?(
    mouse_capturator = button_id;
    g_start_add_or_sub_time = time_precise();
  );

  in_rect  ?
  (
    gfx_rgb(TH.MONO_B_H);
    val_shift = 0;

    mouse_cap == 1 && mouse_capturator == button_id ? (
      // Limit this to 20 calls / seconds
      new_srcdstbtn_time = time_precise();
      (new_srcdstbtn_time - last_srcdstbtn_time > 0.03 || mouse_click) ? (

        val_shift_abs               = 1;
        long_time_spent_on_button   = new_srcdstbtn_time - g_start_add_or_sub_time - 1;

        (long_time_spent_on_button > 0)?(
          // This starts at 1.
          val_shift_abs = exp(long_time_spent_on_button);
        );

        val_shift = (add_or_sub)?(val_shift_abs):(-val_shift_abs);
        last_srcdstbtn_time = new_srcdstbtn_time;

        // Force immediate first pressure
        mouse_click == 1 ? (last_srcdstbtn_time += 0.3);
      );
    );
    /*
      // maybe too dangerous ?
      mouse_wheeli != 0 ? (
        val_shift = mouse_wheeli;
      );
    */
    val_shift != 0 ? (
      val_address[val_local_address] += val_shift;
      // Be sure to have a valid int after.
      val_address[val_local_address] = roundi(val_address[val_local_address]);

      (should_wrap)?(
        (val_address[val_local_address]>maxval)?(val_address[val_local_address]=minval);
        (val_address[val_local_address]<minval)?(val_address[val_local_address]=maxval);
      ):(
        val_address[val_local_address] = min(max(val_address[val_local_address],minval),maxval);
      );

      // Dirty hack to skip value 0 (= In) for chan_out_vfilt,
      // as this value is not used for conditional filtering.
      //(button_id == "chan_out_vfilt" && val_address[val_local_address] == 0)?(
      //  val_address[val_local_address] = (val_shift > 0)?(1):(-1);
      //);

      got_event = val_shift;
    );

  ):( gfx_rgb(TH.MONO_B) );

  // Button background
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);

  // Button text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb(TH.MONO_B_TEXT);

  (should_wrap)?(
    add_or_sub == 0?(gfx_drawstr("<")):(gfx_drawstr(">"));
  ):(
    add_or_sub == 0?(gfx_drawstr("-")):(gfx_drawstr("+"));
  );

  got_event;
);

// A Spinbox, with a int value and two +/- buttons
function drawAddOrSubWidget(widget_id, val_address, val_local_address, l, t, minval, maxval, labelwidth, should_wrap)
   local(tmp, roffset, got_event, w, h, loff, bt, bl, bb, br)
(
  // Offset of the right button
  roffset = labelwidth + 15;

  got_event = 0;

  // Buttons -/+
  got_event |= drawAddOrSubButton(widget_id,val_address,val_local_address,l,t,0,minval,maxval,should_wrap);
  got_event |= drawAddOrSubButton(widget_id,val_address,val_local_address,l+roffset,t,1,minval,maxval,should_wrap);

  (labelwidth > 0)?(

    gfx_rgb(bgColorForComboBox(widget_id));
    bt = t; bl=l+15; br=bl+labelwidth; bb = bt+15;
    gfx_rect(bl,bt,br-bl,bb-bt);

    g_add_or_sub_hover = (mouse_x >= bl && mouse_x <= br && mouse_y >= bt && mouse_y <= bb);

    // Inner text
    gfx_rgb(txtColorForComboBox(widget_id));
    tmp = textForComboBox(widget_id, val_address[val_local_address]);

    w = 0; h = 0; gfx_measurestr(tmp,w,h);
    loff = (labelwidth - w) / 2;
    gfx_xy(l+16+loff, t+4);
    gfx_drawStr(tmp);
  );

  got_event;
);

function drawInputLine(input_id, bl, bt, br, bb, str)
  local(in_rect,new_char,dstr) (

  in_rect = ( mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt );
  in_rect ?
  (
    gfx_rgb( (g_edited_input==input_id)?(TH.INPUTLINE_EDIT_BG_H):(TH.INPUTLINE_BG_H));

    mouse_click == 1 ? (
      (g_edited_input != input_id)?(
        g_edited_input = input_id;
        while(gfx_getChar()>0); // Empty the queue
      )
      :(
        g_edited_input = "";
      );
    );
  ):(
    gfx_rgb( (g_edited_input==input_id)?(TH.INPUTLINE_EDIT_BG):(TH.INPUTLINE_BG) )
  );

  g_edited_input == input_id?
  (
    new_char = gfx_getchar();

    // Alpha num
    new_char >= 32 && new_char <= 126 ?
    (
      sprintf(str,"%s%c",str,new_char);
    );
    // Del
    new_char == 8?
    (
      strncpy(str, str, max(strlen(str)-1,0));
    );
    // Return / Esc
    new_char == 13 || new_char == 27?
    (
      g_edited_input = "";
    );
  );

  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb((g_edited_input==input_id)?(TH.INPUTLINE_EDIT_TEXT):(TH.INPUTLINE_TEXT));

  g_edited_input == input_id?
  (
    // If in edition, show a caret
    dstr = #;
    sprintf(dstr,"%s_",str);
    gfx_drawstr(dstr);
  ):(
    gfx_drawstr(str);
  );

);

/////////////////////
//    CURVE ZONE   //
/////////////////////

function mousePenCallback(gzone)
   local(curve,in_rect,px,py,x1,x2,y1,y2,alpha,i,min_bound,max_bound,str,strw,strh)
(
  curve = selectedControlEditedCurveAddress();

  in_rect = (mouse_x >= gzone.l && mouse_x < gzone.r && mouse_y >= gzone.t && mouse_y < gzone.b);

  // Remember that first click was in drawing zone (click focus)
  (mouse_click == 1 && in_rect)?(
    mouse_capturator = "curvezone";
  );

  (in_rect && g_pen_is_active)?(
    gfx_setcursor(185);
  ):(
    gfx_setcursor(0);
  );


  // Only handle events if we have click focus
  g_pen_is_active ? (
    // Drawing callback
    in_rect ?
    (
      px = (mouse_x-gzone.il)/(RESOLUTION);
      py = (gzone.ib-mouse_y+2)/(RESOLUTION);

      min_bound = controlCurrentMinDrawingBound01(g_selected_control);
      max_bound = controlCurrentMaxDrawingBound01(g_selected_control);

      // If inside the margin around the draw zone, clamp
      px < 0 ? px = 0;
      px > CURVESIZE - 1 ? px = CURVESIZE-1;
      (py < min_bound * (CURVESIZE - 1)) ? (py = min_bound * (CURVESIZE-1));
      (py > max_bound * (CURVESIZE - 1)) ? (py = max_bound * (CURVESIZE-1));
      px = roundi(px);
      py = roundi(py);

      gfx_setcursor(185);
      gfx_rgb(editingCurveColor());
      str = #;
      sprintf(str, "X: %.01f Y: %.01f", px, py);
      gfx_measurestr(str,strw,strh);
      gfx_xy(gzone.ir - strw, gzone.ib + 6);
      gfx_drawstr(str);

      (mouse_cap == 1 && mouse_capturator == "curvezone")?(
        // Clicking
        (g_last_pen_modified_x == -1 || g_last_pen_modified_x == px) ? (
          // Was not clicking yet, or was clicking but did not move
          curve[px]     = py;
          g_last_pen_modified_x = px;
        ):
        (
          // Was already clicking, and now moving
          // Perform some interpolation since mouse positions are not continuous
          // Try to fill the gap with a linear interpolation
          x1=x2=y1=y2=0;

          (px <= g_last_pen_modified_x)?(
            x1 = px;
            x2 = g_last_pen_modified_x;
            y1 = py;
            y2 = curve[g_last_pen_modified_x];
          ):(
            x1 = g_last_pen_modified_x;
            x2 = px;
            y1 = curve[g_last_pen_modified_x];
            y2 = py;
          );

          i = x1;
          while(i <= x2) (
            alpha  = (i-x1)/(x2-x1);
            curve[i] = y1 + alpha * (y2-y1);
            i += 1;
          );
          g_last_pen_modified_x = px;
        )
      ):(
        // Not clicking, reset interpolator reference
        g_last_pen_modified_x = -1
      );
    );
  );
);

function smoothButtonCallback()
  local(curve, i, new_smooth_time, last_smooth_time)
(
  curve = selectedControlEditedCurveAddress();

  // Limit this to 20 calls / seconds
  new_smooth_time = time_precise();
  (new_smooth_time - last_smooth_time > 0.05) ? (

    SCURVE[0]           = curve[0];
    SCURVE[CURVESIZE-1] = curve[CURVESIZE-1];

    // Blur the curve
    i = 1;
    while(i<CURVESIZE-1)
    (
      SCURVE[i] = (CURVE[i-1] + CURVE[i] + CURVE[i+1])/3;
      i+=1;
    );

    i=0; while(i<CURVESIZE) ( CURVE[i] = SCURVE[i]; i+=1 );
    last_smooth_time = new_smooth_time;
  );
);


function drawMousePenButton(gzone)
  local(in_rect,bl,bt,br,bb, xs)
(
  xs = 26;
  bl = gzone.l+xs;
  bt = gzone.b;
  br = bl + 22;
  bb = bt + 22;

  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;

  (in_rect && mouse_click == 1 && !g_pen_is_active)?(
    g_pen_is_active = 1;
  ):(
    (mouse_click == 1 && mouse_capturator != "curvezone")?(
      g_pen_is_active = 0;
    );
  );

  in_rect ?
  (
   (g_mouse_stall > TOOLTIP_DELAY)?(tooltip("Toggle free hand drawing mode",bl+10,bt-20););
    gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON_H):(TH.CURVE_B_H) );
  ):(
    gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON):(TH.CURVE_B) );
  );
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);


  gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON_TEXT):(editingCurveColor()) );

  drawIconPen(bl+3, bt+3);
);


// Smooth button
function drawSmoothButton(gzone)
  local(bl,bt,br,bb, in_rect, xs)
(
  xs = 50;
  bl = gzone.l+xs;
  bt = gzone.b;
  br = bl + 22;
  bb = bt + 22;

  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;
  in_rect ?
  (
   (g_mouse_stall > TOOLTIP_DELAY)?(tooltip("Smooth current curve",bl+10,bt-20));
   gfx_rgb(TH.CURVE_B_H);

   mouse_click == 1 ? ( mouse_capturator = "smoothbutton" );

   mouse_cap == 1 && mouse_capturator == "smoothbutton" ? (
     smoothButtonCallback();
   );
  ):(gfx_rgb(TH.CURVE_B));

  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_x   = bl+10;
  gfx_y   = bt+7;
  gfx_rgb(editingCurveColor());
  drawIconSmooth(bl+3, bt+3);
);
function drawVsymButton(gzone)
  local(bl,bt,br,bb, xs, tooltip_text, in_rect, i, curve, min_bound, max_bound, oc01)
(
  tooltip_text = "Symmetrize vertically";
  xs = 84;
  bl = gzone.l+xs;
  bt = gzone.b;
  br = bl + 22;
  bb = bt + 22;
  curve       = selectedControlEditedCurveAddress();
  min_bound   = controlCurrentMinDrawingBound01(g_selected_control);
  max_bound   = controlCurrentMaxDrawingBound01(g_selected_control);
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;
  in_rect ?
  (
    (g_mouse_stall > TOOLTIP_DELAY)?( tooltip(tooltip_text,bl+10,bt-20) );
    gfx_rgb( TH.CURVE_B_H );
    (mouse_click == 1)?(
      i=0;
      while(i<CURVESIZE) (
        oc01      = (max_bound == min_bound)?(0):((curve[i]/(CURVESIZE-1) - min_bound)/(max_bound - min_bound));
        oc01      = 1 - oc01;
        curve[i]  = (CURVESIZE-1) * (min_bound + oc01 * (max_bound - min_bound));
        i+=1
      );
    );
  ):(
    gfx_rgb(TH.CURVE_B);
  );
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_rgb( editingCurveColor() );
  drawIconVsym(bl+3,bt+3);
);
function drawHsymButton(gzone)
  local(bl,bt,br,bb, xs, tooltip_text, in_rect, i, curve, min_bound, max_bound)
(
  tooltip_text = "Symmetrize horizontally";
  xs = 108;
  bl = gzone.l+xs;
  bt = gzone.b;
  br = bl + 22;
  bb = bt + 22;
  curve       = selectedControlEditedCurveAddress();
  min_bound   = controlCurrentMinDrawingBound01(g_selected_control);
  max_bound   = controlCurrentMaxDrawingBound01(g_selected_control);
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;
  in_rect ?
  (
    (g_mouse_stall > TOOLTIP_DELAY)?( tooltip(tooltip_text,bl+10,bt-20) );
    gfx_rgb( TH.CURVE_B_H );
    (mouse_click == 1)?(
      // First bufferize
      i=0;
      while(i<CURVESIZE) (
        SCURVE[i] = CURVE[i];
        i+= 1
      );
      // Then apply
      i=0;
      while(i<CURVESIZE) (
        CURVE[i] = SCURVE[CURVESIZE-1-i];
        i+= 1
      );
    );
  ):(
    gfx_rgb(TH.CURVE_B);
  );
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_rgb( editingCurveColor() );
  drawIconHsym(bl+3,bt+3);
);

/*
function drawOperationButton(gzone, xs, text, tooltip_text, opnum)
  local(bl,bt,br,bb, in_rect)
(
  bl = gzone.l+xs;
  bt = gzone.b;
  br = bl + 22;
  bb = bt + 22;
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;
  in_rect ?
  (
    (g_mouse_stall > TOOLTIP_DELAY)?( tooltip(tooltip_text,bl+10,bt-20) );
    gfx_rgb( (g_operation_mode ==  opnum)?(TH.CC_LEARN_ON_H):(TH.CURVE_B_H) );
    (mouse_click == 1)?(
      g_operation_mode = (g_operation_mode != opnum) ? (opnum) : (0);
    );
  ):(
    gfx_rgb( (g_operation_mode == opnum)?(TH.CC_LEARN_ON):(TH.CURVE_B) );
  );
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_x   = bl+7;
  gfx_y   = bt+8;
  gfx_rgb( (g_operation_mode == opnum)?(TH.CC_LEARN_ON_TEXT):(editingCurveColor()) );
  gfx_drawstr(text);
);

// Smooth button
function drawPlusButton(gzone) (
  drawOperationButton(gzone, 118, "+", "Toggle addition mode", 1);
);
function drawMinusButton(gzone) (
  drawOperationButton(gzone, 142, "-", "Toggle substraction mode", 2);
);
function drawMultButton(gzone) (
  drawOperationButton(gzone, 166, "x", "Toggle multiplication mode", 3);
);
*/
function drawCopyCurveButton(gzone)
  local(bl,bt,br,bb,xs, in_rect, cad,i,copied_timer,recently_copied)
(
  xs = 222;
  bl = gzone.l+xs;
  bt = gzone.b;
  br = bl + 22;
  bb = bt + 22;

  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;

  (in_rect && g_mouse_stall > TOOLTIP_DELAY)?( tooltip("Copy current curve",bl+10,bt-20) );
  recently_copied = (time_precise() - copied_timer < 0.2);
  (recently_copied)?(
    gfx_rgb(in_rect ? TH.KEY_BLACK_COLOR_0 : TH.KEY_BLACK_COLOR_0_D);
  ):(
    gfx_rgb(in_rect ? TH.CURVE_B_H : TH.CURVE_B);
  );
  gfx_rect(bl,bt,br-bl,bb-bt);

  (recently_copied)?(
    gfx_rgb(TH.KEY_COLOR_RANGE_TEXT);
  ):(
    gfx_rgb(editingCurveColor());
  );
  gfx_xy(bl+10,bt+7);
  drawIconCopy(bl+3, bt+3);

  cad = selectedControlEditedCurveAddress();
  (in_rect && mouse_click == 1) ? (
    i=0;while(i<CURVESIZE) (
      gmem[GMEM_DUMP_CURVE_BUF+i] = cad[i];
      i+=1;
    );
    copied_timer = time_precise();
  );
);

function drawPasteCurveButton(gzone)
  local(bl,bt,br,bb,xs,in_rect,cad,i,recently_pasted,paste_timer)
(
  xs = 246;
  bl = gzone.l+xs;
  bt = gzone.b;
  br = bl + 22;
  bb = bt + 22;

  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;

  (in_rect && g_mouse_stall > TOOLTIP_DELAY)?( tooltip("Paste copied curve",bl+10,bt-20) );
  recently_pasted = (time_precise() - paste_timer < 0.2);
  (recently_pasted)?(
    gfx_rgb(in_rect ? TH.KEY_BLACK_COLOR_1 : TH.KEY_BLACK_COLOR_1_D);
  ):(
    gfx_rgb(in_rect ? TH.CURVE_B_H : TH.CURVE_B);
  );
  gfx_rect(bl,bt,br-bl,bb-bt);


  (recently_pasted)?(
    gfx_rgb(TH.KEY_COLOR_RANGE_TEXT);
  ):(
    gfx_rgb(editingCurveColor());
  );
  gfx_xy(bl+10,bt+7);
  drawIconPaste(bl+3,bt+3);

  cad = selectedControlEditedCurveAddress();

  (in_rect && mouse_click == 1) ? (
      i=0;while(i<CURVESIZE) (
        cad[i] = gmem[GMEM_DUMP_CURVE_BUF+i];
        i+=1;
      );
    paste_timer = time_precise();
  );
);


function operateButtonCallback(curve, curve_addr, should_normalize)
   local(i,min_bound,max_bound,oc01,nc01)
(
  min_bound   = controlCurrentMinDrawingBound01(g_selected_control);
  max_bound   = controlCurrentMaxDrawingBound01(g_selected_control);
  i = 0;
  while(i<CURVESIZE) (
    nc01 = gmem[curve_addr+i];
    (should_normalize)?(
      nc01 /= (CURVESIZE-1);
    );

    /*
    (g_operation_mode != 0)?(
      // Put back the current curve in 0-1 and rescale using the current bounds
      oc01  = (max_bound == min_bound)?(0):((curve[i]/(CURVESIZE-1) - min_bound)/(max_bound - min_bound));
      (g_operation_mode == 1)?(
        nc01 = oc01 + nc01;
      );
      (g_operation_mode == 2)?(
        nc01 = oc01 - nc01;
      );
      (g_operation_mode == 3)?(
        nc01 = oc01 * nc01;
      );
    );
    */

    nc01 = (min_bound + (max_bound-min_bound) * nc01);
    (nc01 < min_bound)?(nc01 = min_bound);
    (nc01 > max_bound)?(nc01 = max_bound);
    // First bufferize
    SCURVE[i] = (CURVESIZE-1) * nc01;
    i+=1;
  );
  i=0;
  while(i<CURVESIZE) (
    curve[i] = SCURVE[i];
    i+=1;
  );
  // g_operation_mode = 0;
);


// Gets the curve in GMEM cooresponding to button
// And builds a curve for the user.
function fsetCurveButtonCallback(set_num, row_num, col_num)
  local(i,curve,curve_addr,min_bound,max_bound,oc01,nc01)
(
  curve       = selectedControlEditedCurveAddress();
  curve_addr  = getFsetFunctionCurveAddress(set_num, row_num, col_num);

  operateButtonCallback(curve, curve_addr, 0);
);

function drawOperateWithCopyButton(gzone)
  local(bl,bt,br,bb,xs, in_rect,  curve, curve_addr)
(
  xs = 194;
  bl = gzone.l+xs;
  bt = gzone.b;
  br = bl + 22;
  bb = bt + 22;
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;
  in_rect ?
  (
    (g_mouse_stall > TOOLTIP_DELAY)?( tooltip("Use copied curve for selected operation",bl+10,bt-20) );
    gfx_rgb( TH.CURVE_B_H );
    (mouse_click == 1)?(
      curve       = selectedControlEditedCurveAddress();
      curve_addr  = GMEM_DUMP_CURVE_BUF;
      operateButtonCallback(curve, curve_addr, 1);
    );
  ):(
    gfx_rgb( TH.CURVE_B );
  );
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_x   = bl+7;
  gfx_y   = bt+8;
  gfx_rgb( editingCurveColor() );
  drawIconMembuf(bl+3,bt+3);
);

function drawFsetCurveButton(bzone, voffset, set_num, row_num, col_num)
  local(preview_address,bl,bt,br,bb,i,curve_addr)
(
  preview_address = getFSetFunctionPreviewAddress(set_num, row_num, col_num);

  bl = bzone.margin + 5 + bzone.l + col_num*41;
  bt = bzone.margin + bzone.t + row_num*42 + voffset + 10;
  br = bl + 32;
  bb = bt + 32;

  mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt ?
  (
   gfx_rgb(TH.CURVE_B_H);
   // Handle the callback in the draw function... erm
   (mouse_click==1) ? (
      fsetCurveButtonCallback(set_num, row_num, col_num);
   );
  ):
  (
    gfx_rgb(TH.CURVE_B);
  );

  // Draw the button rect
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);

  // Draw the button points
  gfx_rgb(editingCurveColor());

  gfx_x = bl; gfx_y = bb -31*gmem[preview_address+0] - 0.5;

  i = 1;
  while(i<PREVIEWSIZE)
  (
    gfx_lineto(bl+i, bb - 31*gmem[preview_address+i] - 0.5);
    i+=1;
  );
);


// Curve buttons
function drawCurveButtons(bzone)
  local(bt, bb, bl, br, by, r, c,
    has_sets, cur_set_num, is_selected,
    cur_set_adr, cur_set_desc, got_event, ri, ci, in_rect,
    w, h, bww, bwx, bwy, si, sc, loff, offx, offy, offr,
    slider_l, slider_w, slider_t, sli_l, sli_r, sli_t, sli_b,
    tabs_per_row, tab_width, tab_height, loff,
    param_label, str, tab_text, to, voff,
    pos, new_pos, pval, new_val, vmin, vmax, pid, rounding)
(
  sc = getFSetCount();
  cur_set_num = getCurrentFSet();

  tabs_per_row  = 7;
  tab_width     = 70;
  tab_height    = 16;
  loff          = 6;

  (sc == 0)?(
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_xy(bzone.l, bzone.t + bzone.margin + 50);
    gfx_drawstr("Oops... It looks like your function");
    gfx_x = bzone.l; gfx_y += 20;
    gfx_drawstr("lib is empty. Be sure to install this");
    gfx_x = bzone.l; gfx_y += 20;
    gfx_drawstr("plugin through ReaPack and read the");
    gfx_x = bzone.l; gfx_y += 20;
    gfx_drawstr("README.md file in the Data folder of");
    gfx_x = bzone.l; gfx_y += 20;
    gfx_drawstr("MIDI CC Mapper X located here :");
    gfx_x = bzone.l; gfx_y += 40;
    gfx_drawstr("<RSRC>/Data/talagan_MIDI CC Mapper X");
  );

  // Function sets tabs
  si    = 0;
  offy  = 0;
  while(si < sc)
  (
    is_selected = (si == cur_set_num);

    offx  = 10 + (si % tabs_per_row) * (tab_width + 1);
    offy  = floor(si / tabs_per_row) * (tab_height + 1);
    offr  = floor(si / tabs_per_row) * loff;

    bl = bzone.l + offx + offr;
    br = bl + tab_width;
    bt = bzone.t + bzone.margin + offy;
    bb = bt + tab_height;

    in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt);

    (in_rect)? (
      gfx_rgb((is_selected)?(TH.TAB_BG_S_H):(TH.TAB_BG_H));
      (mouse_click == 1)?(
        setCurrentFset(si);
      );
    ):(
      gfx_rgb((is_selected)?(TH.TAB_BG_S):(TH.TAB_BG));
    );

    gfx_rect(bl,bt,br-bl,bb-bt);

    // Create a tab
    gfx_rgb((is_selected)?(TH.TAB_TEXT_S):(TH.TAB_TEXT));

    tab_text = getFSetTab(si);
    w = 0; h = 0; gfx_measurestr(tab_text,w,h);
    to = (tab_width - w)/2;
    gfx_x = bl+to+1;
    gfx_y = bt+4;
    gfx_drawstr(tab_text);
    si += 1;
  );

  voff = offy+20;
  bzone.voff = voff;

  (sc > 0)?(

    // Curve buttons
    ri = 0;
    while(ri < FSET_ROW_COUNT) (
      ci = 0;
      while(ci < FSET_COL_COUNT) (
        (isFSetFunctionDefined(cur_set_num,ri,ci))?(
          drawFSetCurveButton(bzone, voff, cur_set_num, ri, ci);
        );
        ci += 1;
      );
      ri += 1;
    );

    (isFSetParametric(cur_set_num))?(

      // Parametric slider
      pid         = getFSetParametricID(cur_set_num);

      param_label = getParametricFSetParameterName(pid);
      vmin        = getParametricFSetParameterMin(pid);
      vmax        = getParametricFSetParameterMax(pid);
      rounding    = getParametricFSetParamRounding(pid);

      bwx = bzone.l + 10;
      bwy = bzone.t + voff + 5*50;
      bww = 220;

      gfx_measurestr(param_label,w,h);
      gfx_rgb(TH.DEFAULT_FONT);
      gfx_x   = bwx; gfx_y = bwy;
      gfx_drawstr(param_label);

      slider_w = bww - w;
      slider_l = bwx + w + 10;
      slider_t = bwy + 2;

      gfx_rgb(TH.MONO_B);
      gfx_rect(slider_l, slider_t, slider_w, 3);

      gfx_rgb(TH.DEFAULT_FONT);

      pval = getFSetParameter(cur_set_num);

      pos = (pval - vmin)/(vmax - vmin);

      gfx_rect(slider_l + (pos * slider_w) - 4, slider_t - 4, 7, 11);

      sli_l = slider_l;
      sli_r = slider_l + slider_w;
      sli_t = slider_t - 4;
      sli_b = slider_t + 7;

      in_rect = (mouse_x >= sli_l-5 && mouse_x <= sli_r+5 && mouse_y >= sli_t-5 && mouse_y <= sli_b+5);

      (in_rect)?(
        (mouse_click == 1)?(
          mouse_capturator = "fset_param_slider";
        );
      );

      (mouse_cap == 1 && mouse_capturator == "fset_param_slider")?(
        new_pos = (mouse_x - sli_l)/(sli_r - sli_l);
        new_val = vmin + new_pos * (vmax - vmin);
        (new_val < vmin)?(new_val = vmin);
        (new_val > vmax)?(new_val = vmax);

        new_val = (rounding * roundi((new_val * 100)/rounding))/100.0;
        setFSetParameter(cur_set_num, new_val);
        precalcParametricSet(cur_set_num);
      );

      gfx_xy(slider_l + slider_w + 10, bwy);
      str = #;
      sprintf(str, "%.2f", pval+0.0001);
      gfx_drawstr(str);
    );

    gfx_rgb(TH.DEFAULT_FONT);
    gfx_x   = bzone.l+10; gfx_y = bzone.t + voff + 5*50 + 31;
    gfx_drawstr(getFSetDescription(cur_set_num));
  );
);

function drawBoundariesPanel()
  local(got_event,i,min_bound,max_bound,
    kbr, matching_velocity_control,
    with_lsb,with_lsb_in,with_lsb_out,
    curve,left, top,
    mins_lsb_address,maxs_lsb_address,mins_msb_address,maxs_msb_address,
    msb_lab_left, msb_spin_left, lsb_spin_left, filter_top,
    min_reachable_msb,max_reachable_msb
  )
(
  (isMorphingEnabledForControl(g_selected_control) && isMorphCurveSelectedForControl(g_selected_control))?(
    mins_lsb_address = CONTROL_MORPH_MINS_LSB;
    maxs_lsb_address = CONTROL_MORPH_MAXS_LSB;
    mins_msb_address = CONTROL_MORPH_MINS_MSB;
    maxs_msb_address = CONTROL_MORPH_MAXS_MSB;
  ):(
    mins_lsb_address = CONTROL_MINS_LSB;
    maxs_lsb_address = CONTROL_MAXS_LSB;
    mins_msb_address = CONTROL_MINS_MSB;
    maxs_msb_address = CONTROL_MAXS_MSB;
  );

  gfx_rgb(TH.DEFAULT_FONT);

  with_lsb = controlHasOperationalHighResOutput(g_selected_control);

  left = 735;
  top  = (isConditionalFilteringAvailableForControl(g_selected_control))?(82 + bzone.voff):(152 + bzone.voff);

  gfx_xy(left-100, GUI_CONTROL_PARAMS_TOP + top + 80);
  gfx_drawStr("Drawing\n\n  limits");

  gfx_xy(left+93, GUI_CONTROL_PARAMS_TOP + top + 50);
  gfx_drawStr((with_lsb)?("MSB"):("Val"));

  (with_lsb)?(
    gfx_xy(left+172, GUI_CONTROL_PARAMS_TOP + top + 50);
    gfx_drawStr("LSB");
  );

  msb_lab_left  = left+20;
  msb_spin_left = left+70;
  lsb_spin_left = left+150;

  gfx_xy(msb_lab_left, GUI_CONTROL_PARAMS_TOP + top + 72);
  gfx_drawStr("Min");

  gfx_xy(msb_lab_left, GUI_CONTROL_PARAMS_TOP + top + 102);
  gfx_drawStr("Max");

  got_event = 0;

  max_reachable_msb = (g_selected_control == CONTROL_PITCH_BEND)?(8191):(127);

  got_event |= drawAddOrSubWidget("min_spinbox_msb",mins_msb_address,g_selected_control,msb_spin_left,GUI_CONTROL_PARAMS_TOP+top+70, 0,max_reachable_msb,40,0);
  got_event |= drawAddOrSubWidget("max_spinbox_msb",maxs_msb_address,g_selected_control,msb_spin_left,GUI_CONTROL_PARAMS_TOP+top+100,0,max_reachable_msb,40,0);

  (with_lsb)?(
    got_event |= drawAddOrSubWidget("min_spinbox_lsb",mins_lsb_address,g_selected_control,lsb_spin_left,GUI_CONTROL_PARAMS_TOP+top+70,0,127,40,0);
    got_event |= drawAddOrSubWidget("max_spinbox_lsb",maxs_lsb_address,g_selected_control,lsb_spin_left,GUI_CONTROL_PARAMS_TOP+top+100,0,127,40,0);
  );

  got_event?(
    // Clamp the curves if we got an event on those buttons

    min_bound = controlCurrentMinDrawingBound01(g_selected_control)*127;
    max_bound = controlCurrentMaxDrawingBound01(g_selected_control)*127;

    curve = selectedControlEditedCurveAddress();

    // Reclamp the curve.
    i = 0;
    while(i<CURVESIZE) (

      (curve[i]<min_bound)?(curve[i] = min_bound);
      (curve[i]>max_bound)?(curve[i] = max_bound);

      i+=1;
    );
  );

  filter_top   = GUI_CONTROL_PARAMS_TOP + top + 150;

  (isConditionalFilteringAvailableForControl(g_selected_control))?(
  (isConditionalFilteringEnabledForControl(g_selected_control))?(

    with_lsb_in  = controlHasOperationalHighResInput(g_selected_control);
    with_lsb_out = controlHasOperationalHighResOutput(g_selected_control);
    with_lsb     = (with_lsb_in || with_lsb_out);

    gfx_rgb(TH.DEFAULT_FONT);
    gfx_xy(left+94, filter_top - 18);
    gfx_drawStr((with_lsb)?("MSB"):("Val"));

    (with_lsb)?(
      gfx_xy(left+172, filter_top - 18);
      gfx_drawStr("LSB");
    );

    drawStandardBistateButton(CONTROL_VFILT_ENABLED,g_selected_control,filter_top,left-100,"Route","Off");

    gfx_rgb(TH.DEFAULT_FONT);
    gfx_xy(left-40, filter_top+4);
    gfx_drawStr("if");
    gfx_xy(left-65, filter_top + 32);
    gfx_drawStr("|");
    gfx_xy(left-91, filter_top + 46);
    gfx_drawStr("to chan");
    gfx_xy(left-65, filter_top + 62);
    gfx_drawStr("|");
    gfx_xy(left-69, filter_top + 68);
    gfx_drawStr("\\/");

    drawAddOrSubWidget("chan_out_vfilt",CONTROL_VFILT_DST_CHAN,g_selected_control,left-100,filter_top+90,-1,16,46,0);

    drawStandardBistateButton(CONTROL_VFILT_IN_SUP_ENABLED ,g_selected_control,filter_top+ 3,msb_lab_left-31,"","");
    drawStandardBistateButton(CONTROL_VFILT_IN_INF_ENABLED, g_selected_control,filter_top+33,msb_lab_left-31,"","");
    drawStandardBistateButton(CONTROL_VFILT_OUT_SUP_ENABLED,g_selected_control,filter_top+63,msb_lab_left-31,"","");
    drawStandardBistateButton(CONTROL_VFILT_OUT_INF_ENABLED,g_selected_control,filter_top+93,msb_lab_left-31,"","");

    gfx_xy(msb_lab_left-11, filter_top + 4);
    gfx_rgb( (isConditionalFilteringInSupEnabledForControl(g_selected_control))?(TH.DEFAULT_FONT):(TH.SW_B_OFF));
    gfx_drawStr("In  >=");

    gfx_xy(msb_lab_left-11, filter_top + 34);
    gfx_rgb( (isConditionalFilteringInInfEnabledForControl(g_selected_control))?(TH.DEFAULT_FONT):(TH.SW_B_OFF));
    gfx_drawStr("In  <=");

    (isConditionalFilteringInSupEnabledForControl(g_selected_control) && isConditionalFilteringInInfEnabledForControl(g_selected_control))?(
      gfx_xy(msb_lab_left+5, filter_top + 19);
      gfx_rgb(TH.DYN_LABEL);
      (controlConditionalFilteringInSup01(g_selected_control) < controlConditionalFilteringInInf01(g_selected_control))?(
        gfx_drawStr("and");
      ):(
        gfx_drawStr("or");
      );
    );

    gfx_xy(msb_lab_left-11, filter_top + 64);
    gfx_rgb( (isConditionalFilteringOutSupEnabledForControl(g_selected_control))?(TH.DEFAULT_FONT):(TH.SW_B_OFF));
    gfx_drawStr("Out >=");

    gfx_xy(msb_lab_left-11, filter_top + 94);
    gfx_rgb( (isConditionalFilteringOutInfEnabledForControl(g_selected_control))?(TH.DEFAULT_FONT):(TH.SW_B_OFF));
    gfx_drawStr("Out <=");

    (isConditionalFilteringOutSupEnabledForControl(g_selected_control) && isConditionalFilteringOutInfEnabledForControl(g_selected_control))?(
      gfx_xy(msb_lab_left+5, filter_top + 79);
      gfx_rgb(TH.DYN_LABEL);
      (controlConditionalFilteringOutSup01(g_selected_control) < controlConditionalFilteringOutInf01(g_selected_control))?(
        gfx_drawStr("and");
      ):(
        gfx_drawStr("or");
      );
    );

    min_reachable_msb = (isControlVelocity(g_selected_control))?(1):(0);

    drawAddOrSubWidget("vfilt_in_sup_msb", CONTROL_VFILT_IN_SUP_MSB,  g_selected_control,msb_spin_left,filter_top+0, min_reachable_msb,max_reachable_msb,40,0);
    drawAddOrSubWidget("vfilt_in_inf_msb", CONTROL_VFILT_IN_INF_MSB,  g_selected_control,msb_spin_left,filter_top+30,min_reachable_msb,max_reachable_msb,40,0);
    drawAddOrSubWidget("vfilt_out_sup_msb",CONTROL_VFILT_OUT_SUP_MSB, g_selected_control,msb_spin_left,filter_top+60,min_reachable_msb,max_reachable_msb,40,0);
    drawAddOrSubWidget("vfilt_out_inf_msb",CONTROL_VFILT_OUT_INF_MSB, g_selected_control,msb_spin_left,filter_top+90,min_reachable_msb,max_reachable_msb,40,0);

    (with_lsb_in)?(
      drawAddOrSubWidget("vfilt_in_sup_lsb", CONTROL_VFILT_IN_SUP_LSB, g_selected_control,lsb_spin_left,filter_top+0, 0,127,40,0);
      drawAddOrSubWidget("vfilt_in_inf_lsb", CONTROL_VFILT_IN_INF_LSB, g_selected_control,lsb_spin_left,filter_top+30,0,127,40,0);
    );
    (with_lsb_out)?(
      drawAddOrSubWidget("vfilt_out_sup_lsb",CONTROL_VFILT_OUT_SUP_LSB,g_selected_control,lsb_spin_left,filter_top+60,0,127,40,0);
      drawAddOrSubWidget("vfilt_out_inf_lsb",CONTROL_VFILT_OUT_INF_LSB,g_selected_control,lsb_spin_left,filter_top+90,0,127,40,0);
    );

    (isControlAfterTouch(g_selected_control))?(

      kbr = controlKBRange(g_selected_control);
      matching_velocity_control = velocityControlForKBRange(kbr);

      (isControlEnabled(matching_velocity_control) && isConditionalFilteringOperationalForControl(matching_velocity_control))?(
        drawStandardBistateButton(KB_RANGE_AT_FOLLOWS_VELOCITY, kbr, filter_top+123,msb_lab_left-31,"","");

        gfx_xy(msb_lab_left-11, filter_top + 124);
        gfx_rgb( (doesKbRangeAfterTouchFollowVelocity(kbr))?(TH.DEFAULT_FONT):(TH.SW_B_OFF) );
        gfx_drawStr("else, follow Note ON");
      );
    );

  ):(
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_xy(left-50, filter_top+3);
    gfx_drawStr("Conditional routing/filtering");

    drawStandardBistateButton(CONTROL_VFILT_ENABLED,g_selected_control,filter_top,left-100,"if","Off");
  );
  );
);


function drawCurvezone()
  local(curve, morph_curve, curve_panel_top,
  left, top, right, bottom,
  gridstep, gzone, bzone,
  i, t1,t2,t3,t4,
  en_inf,en_sup,inf,sup,inf01,sup01,
  alpha, inter, str)
(
   // Curve zone
    curve_panel_top = GUI_CONTROL_PARAMS_TOP+100;

    gzone = 0;
    gzone.margin = 20;

    gzone.l   = 10;
    gzone.t   = curve_panel_top;
    gzone.ih  = (CURVESIZE-1)*RESOLUTION;
    gzone.iw  = (CURVESIZE-1)*RESOLUTION;
    gzone.it  = gzone.t  + gzone.margin;
    gzone.il  = gzone.l  + gzone.margin;
    gzone.ir  = gzone.il + gzone.iw;
    gzone.ib  = gzone.it + gzone.ih;
    gzone.r   = gzone.ir + gzone.margin;
    gzone.b   = gzone.ib + gzone.margin;

    left   = gzone.il;
    right  = gzone.ir;
    top    = gzone.it;
    bottom = gzone.ib;

    bzone         = 0;
    bzone.margin  = 20;
    bzone.l       = gzone.r;
    bzone.t       = gzone.t;

    t1        = top;
    t2        = bottom - gzone.ih * controlCurrentMaxDrawingBound01(g_selected_control);
    t3        = bottom - gzone.ih * controlCurrentMinDrawingBound01(g_selected_control);
    t4        = bottom;

    // Draw background
    gfx_rgb(TH.CURVE_BG_EXCL);
    gfx_rect(gzone.l+10,gzone.t+10,gzone.r-gzone.l-20,gzone.b-gzone.t-20);

    (isConditionalFilteringEnabledForControl(g_selected_control))?(
      // Draw drop conditions
     // gfx_rgb(0x300000);
      gfx_rgb(TH.CURVE_BG_FILTER_OUT);

      en_sup = isConditionalFilteringInSupEnabledForControl(g_selected_control);
      en_inf = isConditionalFilteringInInfEnabledForControl(g_selected_control);
      sup01  = controlConditionalFilteringInSup01(g_selected_control);
      inf01  = controlConditionalFilteringInInf01(g_selected_control);
      sup    = roundi(sup01 * gzone.iw);
      inf    = roundi(inf01 * gzone.iw);

      (en_sup && en_inf && (sup01 <= inf01) )?(
        // Intersection
        gfx_rect(left + sup, top, max(2, inf - sup +2), bottom-top + 1);
      ):(
        (en_sup)?(
          gfx_rect(left + sup, top, gzone.iw - sup + 2, bottom-top + 1);
        );

        (en_inf)?(
          gfx_rect(left, top, inf + 2, bottom-top + 1);
        );
      );

      en_sup = isConditionalFilteringOutSupEnabledForControl(g_selected_control);
      en_inf = isConditionalFilteringOutInfEnabledForControl(g_selected_control);
      sup01  = controlConditionalFilteringOutSup01(g_selected_control);
      inf01  = controlConditionalFilteringOutInf01(g_selected_control);
      sup    = roundi(sup01 * gzone.ih);
      inf    = roundi(inf01 * gzone.ih);

      (en_sup && en_inf && (sup01 <= inf01) )?(
        // Intersection
        gfx_rect(left, bottom - inf, right - left + 1, max(2, inf -sup+2));
      ):(
        (en_sup)?(
          gfx_rect(left, top, right - left + 1, gzone.ih - sup + 2);
        );

        (en_inf)?(
          gfx_rect(left, bottom - inf, right - left + 1, inf + 2);

        );
      );
    );

    // Draw inclusion zone
    gfx_a = 0.07;
    gfx_rgb(TH.CURVE_BG);
    gfx_rect(left,t2,right-left+1,t3-t2+1);
    gfx_a = 1.0;

    // Draw grid
    gfx_rgb(TH.CURVE_GRID);
    gridstep = (CURVESIZE/4)*RESOLUTION;
    gfx_line(left+1*gridstep,top,left+1*gridstep,bottom);
    gfx_line(left+2*gridstep,top,left+2*gridstep,bottom);
    gfx_line(left+3*gridstep,top,left+3*gridstep,bottom);
    gfx_line(left,top+1*gridstep,right,top+1*gridstep);
    gfx_line(left,top+2*gridstep,right,top+2*gridstep);
    gfx_line(left,top+3*gridstep,right,top+3*gridstep);

    // Draw border
    gfx_rgb(TH.CURVE_BORDER);
    gfx_x = left;
    gfx_y = top;
    gfx_lineto(right+1, top);
    gfx_lineto(right+1, bottom+1);
    gfx_lineto(left,    bottom+1);
    gfx_lineto(left,    top);

    // Draw curve
    curve = selectedControlBaseCurveAddress();

    (isMorphingEnabledForControl(g_selected_control))?(
      gfx_rgb(TH.CURVE_BASE_UNS)
    ):(
      gfx_rgb(TH.CURVE);
    );

    gfx_x = left;
    gfx_y = bottom-roundi(RESOLUTION*curve[0]);

    i = 1; while(i<CURVESIZE)(
      gfx_lineto(left+i*RESOLUTION, bottom - roundi(RESOLUTION*curve[i]));
      i+=1;
    );

    (isMorphingEnabledForControl(g_selected_control))?(
      morph_curve = selectedControlMorphCurveAddress();

      gfx_rgb(TH.CURVE_MORPH_UNS);

      gfx_x = left;
      gfx_y = bottom-roundi(RESOLUTION*morph_curve[0]);

      i = 1; while(i<CURVESIZE)(
        gfx_lineto(left+i*RESOLUTION, bottom - roundi(RESOLUTION*morph_curve[i]));
        i+=1;
      );

      gfx_rgb(TH.CURVE);

      alpha = morphValueForCurrentControl();

      inter = curve[0] * (1 - alpha) + alpha * morph_curve[0];
      gfx_x = left;
      gfx_y = bottom-roundi(RESOLUTION*inter);

      i = 1; while(i<CURVESIZE)(
        inter = curve[i] * (1 - alpha) + alpha * morph_curve[i];
        gfx_lineto(left+i*RESOLUTION, bottom - roundi(RESOLUTION * inter));
        i+=1;
      );
    );

    gfx_rgb(TH.CURVE_CURRENT_VALUE);
    // Draw last event
    // Use abs because the wheel may use negative value here
    gfx_circle(left + abs(CONTROL_LAST_IN[g_selected_control])*RESOLUTION ,bottom-floor(1.5 + RESOLUTION*CONTROL_LAST_OUT[g_selected_control]),3);

    mousePenCallback(gzone);

    drawCurveButtons(bzone);
    drawMousePenButton(bzone);
    drawSmoothButton(bzone);

    drawVsymButton(bzone);
    drawHsymButton(bzone);
    // drawPlusButton(bzone);
    // drawMinusButton(bzone);
    // drawMultButton(bzone);
    (isMorphingEnabledForControl(g_selected_control))?(
      drawbistateButton(CONTROL_MORPH_SELECTED,g_selected_control,gzone.b+3,180,"E","S",TH.CURVE_MORPH_SEL,TH.CURVE_BASE_SEL,TH.CURVE_MORPH_UNS,TH.CURVE_BASE_UNS,0,0);
    );

    // (g_operation_mode == 0)?(
    drawCopyCurveButton(bzone);
    drawPasteCurveButton(bzone);
    // ):(
    //  drawOperateWithCopyButton(bzone);
    // );

    drawBoundariesPanel();
);

//////////////////////
//  ASSIGN PANEL   //
//////////////////////

// Enable/Disable button for a CC control
function drawEnableDisableButtonForControl(control_num) (
  drawEnableDisableButton(CONTROL_ENABLED,control_num,CONTROL_PANEL_TOP+3,10);
);

function onControlSelect()
(
  disableCCLearn();
  g_edited_input = "";
);

function drawWheel(wh_num)
  local(control_num, in_rect, slider_zone_x_offset, slider_zone_y_offset,
        slider_h, slider_w, slider_l, slider_t, slider_b, slider_r,
        slider_zone_x_offset, slider_zone_y_offset,
        rect_x, rect_y,
        cval)
(
  control_num = (wh_num == 0)?(CONTROL_MOD_WHEEL):(CONTROL_PITCH_BEND);

  slider_zone_x_offset = (wh_num == 0)?(45):(20);
  slider_zone_y_offset = CONTROL_PANEL_TOP + 32;

  slider_h     = 70 + 5;
  slider_w     = 15;
  slider_t     = slider_zone_y_offset;
  slider_l     = slider_zone_x_offset;
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;

  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);

  // Click event
  mouse_click == 1 && in_rect ?
  (
    g_selected_control == control_num?(g_selected_control = NONE):(g_selected_control = control_num);
    onControlSelect();
  );

  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);
    gfx_rect(slider_l-5,slider_t-5,slider_w+10,slider_h+10);
  );

  // Draw wheel body
  gfx_rgb_control_high(control_num);
  gfx_rect(slider_l,slider_t,slider_w,slider_h);

  // Draw Cursor
  cval = CONTROL_LAST_IN[control_num]/127.0;
  gfx_rgb_control_low(control_num);

  rect_x = slider_l;

  (wh_num == 0)?(
    // Mod wheel
    rect_y = slider_b - cval*65 - 10;
    gfx_rect(rect_x, rect_y, slider_w,10);
  );
  (wh_num == 1)?(
    // Pitch wheel
    cval = cval * 0.5 + 0.5;
    rect_y = slider_b - cval*64 - 10;
    gfx_circle(rect_x+7,rect_y+4,4,1);
  );

);

function drawPad(pad_num, is_pedal)
   local(in_rect, control_num, cval,
         slider_t, slider_l, slider_b, slider_r, slider_h, slider_w,
         slider_h_inner, slider_t_inner, slider_l_inner, slider_w_inner,
         slider_zone_x_offset, slider_zone_y_offset,
         str, str_h, str_w)
(
  control_num = (is_pedal==1)?(CONTROL_PEDALS_START + pad_num):(CONTROL_PADS_START + pad_num);

  slider_h     = is_pedal == 1?(12):(22);
  slider_w     = is_pedal == 1?(15):(32);

  slider_zone_x_offset = (is_pedal==1)?(77):(
    537 + (pad_num % 5) * (slider_w+9);
  );
  slider_zone_y_offset =(is_pedal==1)?(32 + pad_num*21):
  (
    30 + floor(pad_num / 5) * (slider_h+23);
  );

  slider_t     = CONTROL_PANEL_TOP + slider_zone_y_offset;
  slider_l     = slider_zone_x_offset;
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;

  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);

  // Handle events
  mouse_click == 1 && in_rect ?
  (
    g_selected_control == control_num?(g_selected_control = NONE):(g_selected_control = control_num);
    onControlSelect();
  );

  // Draw highlight
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);
    gfx_rect(slider_l-3,slider_t-3,slider_w+6,slider_h+((is_pedal==1)?(7):(17)) );
  );

  cval = CONTROL_LAST_IN[control_num]/127.0;

  // Draw body
  (is_pedal)?(
    (CONTROL_ENABLED[control_num] == 1)?(
      (cval>0.5)?(
        gfx_rgb_control_high(control_num);
      ):(
        gfx_rgb_control_mid(control_num);
      );
    ):(
      gfx_rgb_control_mid(control_num);
    );
    gfx_rect(slider_l,slider_t,slider_w,slider_h);

    // Draw small line pattern that make this look like a pedal
    gfx_rgb( (g_selected_control == control_num)?(TH.CONTROL_HIGHLIGHT):(TH.BACKGROUND) );
    gfx_line(slider_l,slider_t+4,slider_r,slider_t+4);
    gfx_line(slider_l+3,slider_t,slider_l+3,slider_t+4);
    gfx_line(slider_l+7,slider_t,slider_l+7,slider_t+4);
    gfx_line(slider_l+11,slider_t,slider_l+11,slider_t+4);

  ):(

    gfx_rgb_control_mid(control_num);
    gfx_rect(slider_l,slider_t,slider_w,slider_h);

    // Growing center rect
    (CONTROL_ENABLED[control_num] == 1)?(
      slider_w_inner = roundi(slider_w * cval / 2)*2;
      slider_h_inner = roundi(slider_h * cval / 2)*2;
      slider_l_inner = slider_l + (slider_w - slider_w_inner) * 0.5;
      slider_t_inner = slider_t + (slider_h - slider_h_inner) * 0.5;

      gfx_rgb_control_high(control_num);
      gfx_rect(slider_l_inner,slider_t_inner,slider_w_inner,slider_h_inner);
    );

    // Draw Label
    gfx_rgb_control_high(control_num);
    gfx_setfont(1);
    str_w = 0; str_h = 0;
    str = controlLabelWithFallback(control_num);
    gfx_measurestr(str,str_w,str_h);
    gfx_x = slider_l + slider_w/2 - str_w/2; gfx_y = slider_b+1;
    gfx_drawstr(str);
    gfx_setfont(0);
  );
);

function drawPedal(ped_num)
(
  drawPad(ped_num,1);
);

function drawFader(sl_num)
   local(control_num, cval, rect_x, rect_y,
         str, str_w, str_h,
         slider_zone_x_offset, slider_zone_y_offset,
         slider_inter,
         slider_w, slider_h, slider_t, slider_l, slider_b, slider_r, s)
(
  control_num = CONTROL_FADERS_START + sl_num;

  slider_zone_x_offset = 110;
  slider_zone_y_offset = 32;

  slider_inter = 6;
  slider_w     = 15;
  slider_h     = slider_inter*10 + 5;
  slider_t     = CONTROL_PANEL_TOP + slider_zone_y_offset;
  slider_l     = slider_zone_x_offset + sl_num * 20;
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;

  // Handle events
  mouse_click == 1 && mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t ?
  (
    g_selected_control == control_num?(g_selected_control = NONE):(g_selected_control = control_num);
    onControlSelect();
  );

  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);
    gfx_rect(slider_l-2,slider_t-6,slider_w+4,slider_h+20);
  );

  // Draw tics
  gfx_rgb_control_mid(control_num);
  s = 0;
  while(s<11)
  (
    gfx_line(slider_l + 3, 2 + slider_t + s*slider_inter, slider_r - 4, 2 + slider_t + s*slider_inter);
    s += 1;
  );

  // Draw Cursor
  cval = CONTROL_LAST_IN[control_num]/127.0;
  gfx_rgb_control_high(control_num);
  rect_x = slider_l;
  rect_y = slider_b - cval*slider_inter*10-5;
  gfx_rect(rect_x, rect_y, slider_w,5);

  // Draw Label
  gfx_rgb_control_high(control_num);
  gfx_setfont(1);
  str_w = 0; str_h = 0;
  str = controlLabelWithFallback(control_num);
  gfx_measurestr(str,str_w,str_h);
  gfx_x = slider_l + slider_w/2 - str_w/2; gfx_y = slider_b;
  gfx_drawstr(str);
  gfx_setfont(0);
);

function drawKeyIcon(control_num, kbr, l, icon_top, txt)
  local(w,h,en)
(
  en = CONTROL_ENABLED[control_num];
  // White keys
  gfx_rgb_kbr_low(kbr, en);
  gfx_rect(l,    icon_top + 6, 9, 2);
  gfx_rect(l+10, icon_top + 6, 9, 2);
  gfx_rect(l+20, icon_top + 6, 9, 2);

  gfx_rect(l+1,  icon_top + 9, 8, 6);
  gfx_rect(l+10, icon_top + 9, 9, 6);
  gfx_rect(l+20, icon_top + 9, 8, 6);

  // Black keys
  //(en)?(gfx_rgb_kbr_low(kbr, en)):(gfx_rgb_control_low(control_num));
  gfx_rgb_control_low(control_num);
  gfx_rect(l+5,  icon_top, 7, 5);
  gfx_rect(l+16, icon_top, 7, 5);

  gfx_rgb_control_high(control_num);
  gfx_setfont(1);
  gfx_measurestr(txt,w,h);
  gfx_xy(l+(29-w)/2,icon_top + 17);
  gfx_drawstr(txt);
  gfx_setfont(0);

);

function drawVelAtWidget(kbr,isVel)
   local(control_num, is_control_enabled, is_control_selected,
         icon_top,
         slider_w, slider_h, slider_t, slider_l, slider_r, slider_b, slider_full_h,
         in_rect)
(
  control_num          = ((isVel)?(CONTROL_VELOCITY_START):(CONTROL_AFTERTOUCH_START)) + kbr;
  is_control_enabled   = (CONTROL_ENABLED[control_num] == 1);
  is_control_selected  = (g_selected_control == control_num);

  slider_w      = 30;
  slider_h      = 20;
  slider_full_h = 28;

  slider_t      = CONTROL_PANEL_TOP + 32 + ((isVel)?(0):(42));
  slider_l      = 752 + kbr*42;

  slider_r      = slider_l + slider_w;
  slider_b      = slider_t + slider_full_h;

  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);

  // Click event
  mouse_click == 1 && in_rect ?
  (
    is_control_selected?(g_selected_control = NONE):(g_selected_control = control_num);
    onControlSelect();
  );

  in_rect?(
    g_kbr_to_highlight = kbr;
  );

  // Draw background
  is_control_selected ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);
    gfx_rect(slider_l-5,slider_t-5,slider_w+10,slider_full_h+10);
  );

  // Icon
  drawKeyIcon(control_num, kbr, slider_l, slider_t+2,
    (isVel)?("Vel"):("AT");
  );
);

function drawVelocityWidget(kbr)    ( drawVelAtWidget(kbr,1); );
function drawAftertouchWidget(kbr)  ( drawVelAtWidget(kbr,0); );

function drawKnob(knob_num)
  local(kb_zone_x_offset, kb_zone_y_offset,
        kb_l, kb_r, kb_t, kb_b,
        kb_center_x, kb_center_y,
        control_num,
        xpos, ypos, t, cval, x, y,
        str_w, str_h, str)
(
  control_num = CONTROL_KNOBS_START + knob_num;

  kb_zone_x_offset = 335;
  kb_zone_y_offset = 41;

  xpos = (knob_num % 5);
  ypos = floor(knob_num / 5);

  kb_center_x = kb_zone_x_offset + xpos*43;
  kb_center_y =  CONTROL_PANEL_TOP + kb_zone_y_offset + ypos*44;

  kb_l        = kb_center_x - 16;
  kb_r        = kb_center_x + 17;
  kb_t        = kb_center_y - 16;
  kb_b        = kb_center_y + 17;

  // Handle events
  mouse_click == 1 && mouse_x >= kb_l && mouse_x <= kb_r && mouse_y <= kb_b && mouse_y >= kb_t ?
  (
    (g_selected_control == control_num)?(g_selected_control = NONE):(g_selected_control = control_num);
    onControlSelect();
  );

  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);
    gfx_rect(kb_l,kb_t,33,43);
  );

  // KB Tics
  gfx_rgb_control_high(control_num);
  t = 0;
  while(t<11)
  (
    gfx_line(kb_center_x,kb_center_y,kb_center_x + floor(14*KNOB_TICS_X[t]+0.5), kb_center_y + floor(14*KNOB_TICS_Y[t]+0.5));
    t += 1;
  );

  // KB Background
  gfx_rgb_control_mid(control_num);
  gfx_circle(kb_center_x,kb_center_y,12,1,0);

  // KB Border
  gfx_rgb((g_selected_control == control_num)?(TH.CONTROL_HIGHLIGHT):(TH.BACKGROUND));
  gfx_circle(kb_center_x,kb_center_y,12,0,1);

  // Cursor
  gfx_rgb_control_high(control_num);

  cval = CONTROL_LAST_IN[control_num]/127.0;
  x = floor(knobTic(cval,1)*12 + 0.5);
  y = floor(knobTic(cval,0)*12 + 0.5);

  gfx_line(kb_center_x, kb_center_y, kb_center_x + x, kb_center_y + y);

  // Draw Label
  gfx_rgb_control_high(control_num);
  gfx_setfont(1);
  str_w = 0; str_h = 0;
  str = controlLabelWithFallback(control_num);
  gfx_measurestr(str,str_w,str_h);
  gfx_x = kb_center_x - str_w/2; gfx_y = kb_b-3;
  gfx_drawstr(str);
  gfx_setfont(0);
);

// CC Learn widget
function drawCCLearnButton(cnum)
   local(bl,bt,br,bb,in_rect)
(
  bl = 253;
  bt = GUI_CONTROL_PARAMS_TOP+24;
  br = bl + 70;
  bb = bt + 15;

  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt);
  in_rect ?
  (
    (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON_H)):(gfx_rgb(TH.MONO_B_H));

    mouse_click == 1 ? (
      (isCCLearning())?(disableCCLearn()):(enableCCLearn());
    );
  ):
  (
    (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON)):(gfx_rgb(TH.MONO_B));
  );
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);

  // Now the text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON_TEXT)):(gfx_rgb(TH.MONO_B_TEXT));
  gfx_drawstr("CC Learn");
);

// CC Learn widget
function drawCopySrcButton(cnum)
   local(bl,bt,br,bb,in_rect)
(
  bl = 253;
  bt = GUI_CONTROL_PARAMS_TOP+44;
  br = bl + 70;
  bb = bt + 15;

  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt);
  in_rect ?
  (
    // Hover in color
    gfx_rgb(TH.MONO_B_H);
    // Handle the callback in the draw function... erm
    mouse_click == 1 ? (
      CONTROL_DSTS[cnum] = CONTROL_SRCS[cnum];
    );
  ):
  (
    // Hover out color
    gfx_rgb(TH.MONO_B);
  );

  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);

  // Now the text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb(TH.MONO_B_TEXT);
  gfx_drawstr("Copy Src");
);

// Description label widget
function drawDescriptionInputLine()
   local(bl,bt,br,bb,str)
(
  bl = 130;
  bt = GUI_CONTROL_PARAMS_TOP+4;
  br = bl + 146;
  bb = bt + 15;
  str = controlDescription(g_selected_control);

  drawInputLine("input_desc", bl, bt, br, bb, str);
);

// Small label edition widget
function drawSmallLabelInputLine()
   local(bl,bt,br,bb,str)
(
  bl = 395;
  bt = GUI_CONTROL_PARAMS_TOP+4;
  br = bl + 40;
  bb = bt + 15;

  str = controlLabel(g_selected_control);
  drawInputLine("input_sl", bl, bt, br, bb, str);
);

function passThroughMayClashForControl(control)
   local(kbr,ic,oc)
(
  (controlShouldPassThrough(control))?(

    (isControlVelocity(control) || isControlAfterTouch(control))?(
      // Velo / AT
      kbr = controlKBRange(control);
      ic  = keyboardInputChannel();
      oc  = kbRangeOutputChannel(kbr);

      (oc == AS_SRC || ic == oc);
    ):(
      ic  = controlInputChannel(control);
      oc  = controlOutputChannel(control);

      (isControlPitchBend(control))?(
        // PB
        (oc == AS_SRC || ic == oc);
      ):(
        // CC / CP
        (oc == AS_SRC || ic == oc) && (CONTROL_SRCS[control] == CONTROL_DSTS[control]);
      );
    );
  ):(
    0;
  );
);

// Control editor sub panel for midi cc assignment
function drawAssignZone()
   local(src_cc, src_name, src_is_lsb, src_is_msb,
         dst_cc, dst_name, dst_is_lsb, dst_is_msb,
         kbr, str, w, h,
         in_rect, new_pos, new_val, pos, pval,
         slider_l, slider_w, slider_t,
         sli_b, sli_l, sli_r, sli_t, slider_num, vmax, vmin)
(
  gfx_rgb(TH.DEFAULT_FONT);

  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+8;
  gfx_drawStr("Description");

  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+28;
  gfx_drawStr("In  ->");

  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+48;
  gfx_drawStr("Out ->");

  gfx_rgb(TH.DEFAULT_FONT);
  gfx_x=90; gfx_y = GUI_CONTROL_PARAMS_TOP+28;
  gfx_drawStr("Chan");

  gfx_rgb(TH.DEFAULT_FONT);
  gfx_x=90; gfx_y = GUI_CONTROL_PARAMS_TOP+48;
  gfx_drawStr("Chan");

  // Channel In/Out
  (isControlVelocity(g_selected_control) || isControlAfterTouch(g_selected_control)) ?(

    kbr = controlKBRange(g_selected_control);

    str = textForChannelIn(keyboardInputChannel());
    gfx_measureStr(str, w, h);
    gfx_rgb(TH.DYN_LABEL);
    gfx_xy( 140 + (65-w)/2, GUI_CONTROL_PARAMS_TOP+28);
    gfx_drawStr(str);

    str = textForChannelOut(kbRangeOutputChannel(kbr));
    gfx_measureStr(str, w, h);
    gfx_rgb(TH.DYN_LABEL);
    gfx_xy( 140 + (65-w)/2, GUI_CONTROL_PARAMS_TOP+48);
    gfx_drawStr(str);

  ):(
    drawAddOrSubWidget("chan_src_spinbox",CONTROL_CHAN_SRCS,g_selected_control,130,GUI_CONTROL_PARAMS_TOP+24,0,16,56,0);
    drawAddOrSubWidget("chan_dst_spinbox",CONTROL_CHAN_DSTS,g_selected_control,130,GUI_CONTROL_PARAMS_TOP+44,0,16,56,0);
  );

  gfx_rgb(TH.DEFAULT_FONT);
  gfx_x=230; gfx_y = GUI_CONTROL_PARAMS_TOP+28;
  gfx_drawStr("CC");
  gfx_x=230; gfx_y = GUI_CONTROL_PARAMS_TOP+48;
  gfx_drawStr("CC");

  (isControlVelocity(g_selected_control) || isControlAfterTouch(g_selected_control) || isControlPitchBend(g_selected_control) ) ?(

    // Description

    (isControlVelocity(g_selected_control) || isControlAfterTouch(g_selected_control))?(
      kbr = controlKBRange(g_selected_control);
      gfx_rgb_kbr_low(kbr,1);
    ):(
      gfx_rgb(TH.DYN_LABEL);
    );
    gfx_xy(140, GUI_CONTROL_PARAMS_TOP+8);
    gfx_drawStr(controlName(g_selected_control));

    (isControlPitchBend(g_selected_control))?(
      gfx_rgb(TH.DYN_LABEL_DISABLED);
      gfx_xy(275, GUI_CONTROL_PARAMS_TOP+8);
      gfx_drawStr("(Symmetrical - only the positive half of the curve is drawn)");

      gfx_rgb(TH.DEFAULT_FONT);
      gfx_xy(780, GUI_CONTROL_PARAMS_TOP+8);
      gfx_drawStr("Reverse");

      drawYesNobutton(REVERSE_PITCH_BEND,0,GUI_CONTROL_PARAMS_TOP+5,850);
    );

    // Src CC
    gfx_rgb(TH.DYN_LABEL_DISABLED);
    gfx_x = 260; gfx_y = GUI_CONTROL_PARAMS_TOP+28;
    gfx_drawStr(controlName(g_selected_control));

    // HR
    (isControlVelocity(g_selected_control) && isHighResMidiInputEnabledForControl(g_selected_control))?(
      gfx_rgb(TH.ROUTING_INFO_OK);
      gfx_drawStr(" [High Res]");
    );

    // Dst
    gfx_rgb(TH.DYN_LABEL_DISABLED);
    gfx_x = 260; gfx_y = GUI_CONTROL_PARAMS_TOP+48;
    gfx_drawStr(controlName(g_selected_control));

    // HR
    (isControlVelocity(g_selected_control) && isHighResMidiOutputEnabledForControl(g_selected_control))?(
      gfx_rgb(TH.ROUTING_INFO_OK);
      gfx_drawStr(" [High Res]");
    );
  );

  (isControlAfterTouch(g_selected_control))?(
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_x = 510; gfx_y = GUI_CONTROL_PARAMS_TOP+8;
    gfx_drawStr("Info : This control is for per-key (poly) aftertouch.\n\n       For global aftertouch, aka Channel Pressure,\n\n       use a standard control with virtual CC#128.");
  );

  // Standard CC Routing / Renaming
  (isControlForRealCC(g_selected_control))?(
    // CC or CP
    gfx_x = 295; gfx_y = GUI_CONTROL_PARAMS_TOP+8;
    gfx_drawStr("Small Label");

    drawDescriptionInputLine();
    drawSmallLabelInputLine();

    drawCCLearnButton(g_selected_control);
    drawCopySrcButton(g_selected_control);

    drawAddOrSubWidget("cc_src_spinbox",CONTROL_SRCS,g_selected_control,332,GUI_CONTROL_PARAMS_TOP+24,0,128,42,0);
    drawAddOrSubWidget("cc_dst_spinbox",CONTROL_DSTS,g_selected_control,332,GUI_CONTROL_PARAMS_TOP+44,0,128,42,0);

    // Name of the src CC
    gfx_rgb(TH.ROUTING_INFO_CCNAME);
    gfx_x = 412;  gfx_y = GUI_CONTROL_PARAMS_TOP+28;
    src_cc     = CONTROL_SRCS[g_selected_control];
    src_name   = midiCCName(src_cc);

    src_is_lsb = isALsbCC(src_cc);
    src_is_msb = isAMsbCC(src_cc);

    gfx_drawStr(src_name);

    (controlHasOperationalHighResInput(g_selected_control))?(
      gfx_rgb(TH.ROUTING_INFO_OK);
      str = #;
      sprintf(str," [High Res 14-bit %d+%d]", (src_is_lsb)?(src_cc-32):(src_cc), (src_is_lsb)?(src_cc):(src_cc+32) );
      gfx_drawStr(str);
    ):(
      (src_is_lsb)?(
        gfx_drawStr(" (LSB)");
      );
      (src_is_msb)?(
        gfx_drawStr(" (MSB)");
      );
    );


    // Name of the dst CC
    gfx_rgb(TH.ROUTING_INFO_CCNAME);
    gfx_x = 412;  gfx_y = GUI_CONTROL_PARAMS_TOP+48;
    dst_cc     = CONTROL_DSTS[g_selected_control];
    dst_name   = midiCCName(dst_cc);
    dst_is_lsb = isALsbCC(dst_cc);
    dst_is_msb = isAMsbCC(dst_cc);

    gfx_drawStr(dst_name);

    (controlHasOperationalHighResOutput(g_selected_control))?(
      gfx_rgb(TH.ROUTING_INFO_OK);
      str = #;
      sprintf(str," [High Res 14-bit %d+%d]", (dst_is_lsb)?(dst_cc-32):(dst_cc), (dst_is_lsb)?(dst_cc):(dst_cc+32) );
      gfx_drawStr(str);
    ):(
      (dst_is_lsb)?(
        gfx_drawStr(" (LSB)");
      );
      (dst_is_msb)?(
        gfx_drawStr(" (MSB)");
      );
    );

  );

  // Potential high res controls
  ( isControlHighResCapableForInput(g_selected_control) )?(
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_x = (isControlVelocity(g_selected_control))?(365):(455); gfx_y = GUI_CONTROL_PARAMS_TOP+8;
    gfx_drawStr("High res input");
    drawYesNobutton(CONTROL_HIGHRES_INPUT_ENABLED,g_selected_control,GUI_CONTROL_PARAMS_TOP+5,(isControlVelocity(g_selected_control))?(490):(580));
  );

  // Potential high res controls
  ( isControlHighResCapableForOutput(g_selected_control) )?(
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_x = (isControlVelocity(g_selected_control))?(545):(635); gfx_y = GUI_CONTROL_PARAMS_TOP+8;
    gfx_drawStr("High res output");
    drawYesNobutton(CONTROL_HIGHRES_OUTPUT_ENABLED,g_selected_control,GUI_CONTROL_PARAMS_TOP+5,(isControlVelocity(g_selected_control))?(680):(770));
  );

  // In all cases, draw the pass through
  gfx_xy(30,GUI_CONTROL_PARAMS_TOP+68);
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawStr("Pass through original event");
  drawAddOrSubWidget("pt_spinbox",CONTROL_PASS_THROUGH,g_selected_control,262,GUI_CONTROL_PARAMS_TOP+64,-1,0,102,1);

  (passThroughMayClashForControl(g_selected_control))?(
    gfx_xy(410,GUI_CONTROL_PARAMS_TOP+68);
    gfx_rgb(TH.ROUTING_INFO_NOT_OK);
    gfx_drawStr("Warning! New and original events are likely to interfere.");
  );

  gfx_xy(30,GUI_CONTROL_PARAMS_TOP+88);
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawStr("Morphing");
  drawEnableDisableButton(CONTROL_MORPH_ENABLED,g_selected_control,GUI_CONTROL_PARAMS_TOP + 84, 110);

  (isMorphingEnabledForControl(g_selected_control))?(

    gfx_xy(206,GUI_CONTROL_PARAMS_TOP + 88);
    gfx_rgb(TH.CURVE_BASE_SEL);
    gfx_drawStr("Start");

    gfx_xy(506,GUI_CONTROL_PARAMS_TOP + 88);
    gfx_rgb(TH.CURVE_MORPH_SEL);
    gfx_drawStr("End");

    slider_num = morphSliderNumForControl(g_selected_control);

    // slider line
    slider_w = 230;
    slider_l = 260;
    slider_t = GUI_CONTROL_PARAMS_TOP + 90;

    gfx_rgb(TH.MONO_B);
    gfx_rect(slider_l, slider_t, slider_w, 3);

    vmin = 0;
    vmax = 1.0;

    sli_l = slider_l;
    sli_r = slider_l + slider_w;
    sli_t = slider_t - 4;
    sli_b = slider_t + 7;

    in_rect = (mouse_x >= sli_l-5 && mouse_x <= sli_r+5 && mouse_y >= sli_t-5 && mouse_y <= sli_b+5);

    (in_rect)?(
      (mouse_click == 1)?(
        mouse_capturator = "morph_param_slider";
      );
    );

    (mouse_cap == 1 && mouse_capturator == "morph_param_slider")?(
      new_pos = (mouse_x - sli_l)/(sli_r - sli_l);
      new_val = vmin + new_pos * (vmax - vmin);
      (new_val < vmin)?(new_val = vmin);
      (new_val > vmax)?(new_val = vmax);

      slider(slider_num) = new_val;

      // Inform the change upstream, so that if the user plays with the slider
      // During automation recording, the event is forwarded correctly.
      slider_automate(2 ^ (slider_num-1));

      g_slider_activity_this_block = 1;
      MORPH_SLIDER_ACTIVITY[g_selected_control] = 1;
    );

    // Slider button
    gfx_rgb(TH.CURVE);

    pval = slider(slider_num);
    pos  = (pval - vmin)/(vmax - vmin);
    gfx_rect(slider_l + (pos * slider_w) - 4, slider_t - 4, 7, 11);

    (isMorphAutoEmitAvailableForControl(g_selected_control))?(
      gfx_xy(560,GUI_CONTROL_PARAMS_TOP+88);
      gfx_rgb(TH.DEFAULT_FONT);
      gfx_drawStr("Auto-Emit");

      drawYesNobutton(CONTROL_MORPH_AUTO_EMIT_ENABLED, g_selected_control,GUI_CONTROL_PARAMS_TOP+84,648);
    );
  );
);

function drawControlPanel()
   local(i, maxi, str)
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,CONTROL_PANEL_TOP,gfx_w,20);

  (g_selected_control != NONE)?(

    // Header text
    gfx_rgb(TH.HEADER_TEXT);
    gfx_x = 90; gfx_y = CONTROL_PANEL_TOP+7;
    str = #;
    sprintf(str,"%s / %s", controlName(g_selected_control), controlDescription(g_selected_control));
    gfx_drawstr(str);

    // Enable / Disable
    drawEnableDisableButtonForControl(g_selected_control);
  ):(
    gfx_rgb(TH.HEADER_TEXT);
    gfx_x = 10; gfx_y = CONTROL_PANEL_TOP+7;
    gfx_drawstr("Select a control to edit it.");
  );

  drawWheel(0);
  drawWheel(1);
  drawPedal(0);
  drawPedal(1);
  drawPedal(2);
  drawPedal(3);

  i = 0; while(i<10)
  (
    drawKnob(i);
    i += 1;
  );
  i = 0; while(i<10)
  (
    drawFader(i);
    i += 1;
  );
  i = 0; while(i<10)
  (
    drawPad(i,0);
    i += 1;
  );
  maxi = ((isKeyboardFilteringEnabled())?(KB_RANGE_COUNT):(1));
  i = 0; while(i<maxi)
  (
    drawVelocityWidget(i);
    i += 1;
  );
  i = 0; while(i<maxi)
  (
    drawAftertouchWidget(i);
    i += 1;
  );

  // Edition of the selected control
  (g_selected_control != NONE)?(
    (CONTROL_ENABLED[g_selected_control] == 1 )?(
      // Assignment zone
      drawAssignZone();
      drawCurveZone();
    ):(
      gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+8 ; gfx_rgb(TH.DEFAULT_FONT);
      gfx_drawstr("To edit the parameters for this control, enable it first.");
    );
  );
);


////////////////////////
//   KEYBOARD PANEL  //
////////////////////////

function keyboardKeyColor(k)
  local(en,bk,cr,col,fac, r,g,b,offset)
(
  en = isKeyboardFilteringEnabled();
  bk = keyIsBlack(k);
  cr = keyKBRange(k);

  col = (en)?(
    (cr == 0)?( (bk)?(TH.KEY_BLACK_COLOR_0):(TH.KEY_WHITE_COLOR_0); ):(
    (cr == 1)?( (bk)?(TH.KEY_BLACK_COLOR_1):(TH.KEY_WHITE_COLOR_1); ):(
    (cr == 2)?( (bk)?(TH.KEY_BLACK_COLOR_2):(TH.KEY_WHITE_COLOR_2); ):(
    (cr == 3)?( (bk)?(TH.KEY_BLACK_COLOR_3):(TH.KEY_WHITE_COLOR_3); ):(
                (bk)?(TH.KEY_BLACK_COLOR_4):(TH.KEY_WHITE_COLOR_4);
          );
        );
      );
    );
  ):(
    (bk)?(TH.KEY_BLACK_DISABLED):(TH.KEY_WHITE_DISABLED);
  );

  (g_kbr_to_highlight == cr || !en)?(

    (offset == -1)?(offset = time_precise());
    fac = 1 + 0.2 * sin(10*(time_precise()-offset));

    r = (col>>16)&0xFF; r *= fac; (r>0xFF)?(r=0xFF);
    g = (col>>8)&0xFF;  g *= fac; (g>0xFF)?(g=0xFF);
    b = (col>>0)&0xFF;  b *= fac; (b>0xFF)?(b=0xFF);

    col = (r<<16) | (g<<8) | b;
  );

  (g_kbr_to_highlight == NONE)?(
    offset = -1;
  );

  col;
);

function drawKBRangeTransposeRow(cr,col,off,name8Va,nameSt)
  local(hoff)
(
  hoff = KEYBOARD_PANEL_WIDTH;
  hoff += 15;

  gfx_rgb(TH.DEFAULT_FONT);
  gfx_xy(hoff, KEYBOARD_FILTERING_TOP+3+off);
  gfx_drawstr("8vi");

  hoff += 27;
  drawAddOrSubWidget(name8Va, KB_RANGE_TRANSPOSE_8VA+cr, 0,hoff,KEYBOARD_FILTERING_TOP+off,  -8,8,   27,0);
  (g_add_or_sub_hover)?(g_kbr_to_highlight = cr);

  hoff += 63;
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_xy( hoff, KEYBOARD_FILTERING_TOP+3+off);
  gfx_drawstr("Semi");

  hoff += 36;
  drawAddOrSubWidget(nameSt  , KB_RANGE_TRANSPOSE_SEMI_TONES+cr,   0,hoff,KEYBOARD_FILTERING_TOP+off, -12,12, 37,0);
  (g_add_or_sub_hover)?(g_kbr_to_highlight = cr);

  hoff += 74;
  drawOnOffButton(KB_RANGE_TRANSPOSE_ENABLED,cr, KEYBOARD_FILTERING_TOP+off, hoff);
);

function drawTransposePanel()
   local(enabled)
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(KEYBOARD_PANEL_WIDTH+2,KEYBOARD_FILTERING_TOP,gfx_w - KEYBOARD_PANEL_WIDTH-2,20);

  // Button
  drawEnableDisableButton(KEYBOARD_TRANSPOSE_ENABLED,0,KEYBOARD_FILTERING_TOP + 3,10 + KEYBOARD_PANEL_WIDTH);

  // Title
  gfx_x = 88 + KEYBOARD_PANEL_WIDTH; gfx_y = KEYBOARD_FILTERING_TOP + 7;

  gfx_rgb(TH.HEADER_TEXT);
  gfx_drawstr("Transpose");

  (isKeyboardTranspositionEnabled())?(
    (isKeyboardFilteringEnabled())?(
      drawKBRangeTransposeRow(0,TH.KEY_BLACK_COLOR_0,6+27,"kr_0_8va","kr_0_st");
      drawKBRangeTransposeRow(1,TH.KEY_BLACK_COLOR_1,6+44,"kr_1_8va","kr_1_st");
      drawKBRangeTransposeRow(2,TH.KEY_BLACK_COLOR_2,6+61,"kr_2_8va","kr_2_st");
      drawKBRangeTransposeRow(3,TH.KEY_BLACK_COLOR_3,6+78,"kr_3_8va","kr_3_st");
      drawKBRangeTransposeRow(4,TH.KEY_BLACK_COLOR_4,6+95,"kr_4_8va","kr_4_st");
    ):(
      drawKBRangeTransposeRow(0,TH.KEY_BLACK_COLOR_0,6+27+27,"kr_0_8va","kr_0_st");
    );
  );
);

function drawKeyboardChannelsPanel()
   local(kf_enabled)
(
  kf_enabled = isKeyboardFilteringEnabled();

  gfx_xy(20, KEYBOARD_PANEL_TOP + 106);
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawstr("Channels");

  gfx_xy(100, KEYBOARD_PANEL_TOP + 106);
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawstr("In");
  drawAddOrSubWidget("chan_in_keyboard_spinbox",KB_INPUT_CHANNEL,0,125,KEYBOARD_PANEL_TOP+102,0,16,40,0);

  gfx_xy(223,KEYBOARD_PANEL_TOP + 106);
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawstr("Out");

  (mouse_capturator != "keyboard")?(
    g_kbr_to_highlight = NONE;
  );

  drawAddOrSubWidget("chan_out_range_0_spinbox",KB_RANGE_OUTPUT_CHANNEL,0,257,KEYBOARD_PANEL_TOP+102,0,16,46,0);
  (g_add_or_sub_hover)?(g_kbr_to_highlight = 0);

  (kf_enabled)?(
    drawAddOrSubWidget("chan_out_range_1_spinbox",KB_RANGE_OUTPUT_CHANNEL+1,0,347,KEYBOARD_PANEL_TOP+102,-1,16,46,0);
    (g_add_or_sub_hover)?(g_kbr_to_highlight = 1);

    drawAddOrSubWidget("chan_out_range_2_spinbox",KB_RANGE_OUTPUT_CHANNEL+2,0,437,KEYBOARD_PANEL_TOP+102,-1,16,46,0);
    (g_add_or_sub_hover)?(g_kbr_to_highlight = 2);

    drawAddOrSubWidget("chan_out_range_3_spinbox",KB_RANGE_OUTPUT_CHANNEL+3,0,527,KEYBOARD_PANEL_TOP+102,-1,16,46,0);
    (g_add_or_sub_hover)?(g_kbr_to_highlight = 3);

    drawAddOrSubWidget("chan_out_range_4_spinbox",KB_RANGE_OUTPUT_CHANNEL+4,0,617,KEYBOARD_PANEL_TOP+102,-1,16,46,0);
    (g_add_or_sub_hover)?(g_kbr_to_highlight = 4);

  );
);

function keyboardKeyClickEvent(i) (

  (mouse_click == 1)?(
    // Remember that the keybord has click focus
    mouse_capturator      = "keyboard";
    // We clicked on a key, we are colorizing all future hovered keys
    // With the opposite color.
    (mouse_cap == 1)?(g_keyboard_color_brush = KEYBOARD_KEY_COLORS[i]+1;);
    (mouse_cap == 2)?(g_keyboard_color_brush = KEYBOARD_KEY_COLORS[i]-1;);
    (g_keyboard_color_brush >= KB_RANGE_COUNT)?(g_keyboard_color_brush = 0;);
    (g_keyboard_color_brush < 0)?(g_keyboard_color_brush = KB_RANGE_COUNT - 1;);
  );

  ( (mouse_cap == 1 || mouse_cap == 2) && mouse_capturator == "keyboard")?(

    // Ok we are changing the status of this key
    KEYBOARD_KEY_COLORS[i] = g_keyboard_color_brush;
    g_kbr_to_highlight = g_keyboard_color_brush;
  );
);


function drawKeyboardKeyMarker(bk,chan,x,y)
  local(str,w,h,xs,ys)
(
  x = ceil(x);
  y = (bk)?(y+2):(y - 2);


  str = #;
  sprintf(str, "%d", chan);
  gfx_measurestr(str,w,h);

  xs = x-floor(w/2);
  ys = y - 14;

  // Draw the chan text
  // (small Technique to add a border to the text, use an offset and repeat)
  gfx_rgb(TH.KEY_MARKER_BORDER);
  gfx_xy(xs-2,ys);
  gfx_drawstr(str);
  gfx_xy(xs+2,ys);
  gfx_drawstr(str);
  gfx_xy(xs,ys-2);
  gfx_drawstr(str);
  gfx_xy(xs,ys+2);
  gfx_drawstr(str);
  gfx_rgb(TH.KEY_MARKER_BG);
  gfx_xy(xs,ys);
  gfx_drawstr(str);

  // Draw the circle with border
  gfx_rgb(TH.KEY_MARKER_BG);
  gfx_circle(x,y,3.5,1,0);
  gfx_rgb(TH.KEY_MARKER_BORDER);
  gfx_circle(x,y,3.5,0,0);
);

// This is a reduncant version of the keyboard drawing function below
// To draw just the overlay of events (round note marker & text popup)
function drawKeyboardKeyOverlay()
   local(kf_enabled, loff, left, top, white_key_width, key_height_top, key_height_bottom, key_height_full,
         bk, fk, key_top, key_offset, key_width, oct, in_oct_pos, in_rect, i, imax,
         normalized_key_offset, normalized_key_width, str,
         wkcount)
(
  kf_enabled = isKeyboardFilteringEnabled();

  // 88 keys keyboard
  // A0 : midi note 21
  // C8 : midi note 108

  loff              = 20;
  white_key_width   = 9;
  key_height_top    = 35;
  key_height_bottom = 25;
  key_height_full   = key_height_top + key_height_bottom;

  key_top           = KEYBOARD_FILTERING_TOP + 30; // Header skip

  // Top part of the keyboard
  i      = 0;
  imax   = i + (12 * 11); (imax > 128)?(imax = 128);

  while(i<imax) (
    bk = keyIsBlack(i);

    oct         = floor(i / 12);
    in_oct_pos  = i%12;

    normalized_key_offset = OCTAVE_TOP_KEY_OFFSETS[in_oct_pos];
    normalized_key_width  = OCTAVE_TOP_KEY_WIDTHS[in_oct_pos];

    // G9
    (i == 127)?(normalized_key_width = 0.5);

    key_offset = loff + (normalized_key_offset + oct * 7) * white_key_width;
    key_width  = normalized_key_width * white_key_width;

    (key_width != 0)?(

      // Key should appear at the top part of the keyboard
      left = key_offset;
      top  = key_top;

      (bk)?(
        // Key press marker
        (KEY_VELOCITIES[i] > 0)?(
          drawKeyboardKeyMarker(bk, KEY_CHANNELS[i], left + floor(key_width/2)-1, top + floor(key_height_top/2));
        );
      );
    );
    i += 1;
  );

  // Bottom part of the keyboard
  wkcount = 0;
  i       = 0;
  imax    = i + (12 * 11); (imax > 128)?(imax = 128);

  while(i<imax) (

    oct = floor(i / 12);
    bk  = keyIsBlack(i);

    (!bk)?(
      left = loff+wkcount*white_key_width;
      top  = key_top + key_height_top;

      // Key press marker
      (KEY_VELOCITIES[i] > 0)?(
        drawKeyboardKeyMarker(bk, KEY_CHANNELS[i], left + floor(white_key_width/2),top + floor(key_height_bottom/2.1));
      );

      // Increment white key counter
      wkcount += 1;
    );

    // Next key
    i += 1;
  );
);



function drawKeyboardKeys()
   local(kf_enabled, loff, left, top, white_key_width, key_height_top, key_height_bottom, key_height_full,
         bk, fk, key_top, key_offset, key_width, oct, in_oct_pos, in_rect, i, imax,
         normalized_key_offset, normalized_key_width, str,
         wkcount)
(
  kf_enabled = isKeyboardFilteringEnabled();

  // 88 keys keyboard
  // A0 : midi note 21
  // C8 : midi note 108

  loff              = 20;
  white_key_width   = 9;
  key_height_top    = 35;
  key_height_bottom = 25;
  key_height_full   = key_height_top + key_height_bottom;

  key_top           = KEYBOARD_FILTERING_TOP + 30; // Header skip

  // Top part of the keyboard
  i      = 0;
  imax   = i + (12 * 11); (imax > 128)?(imax = 128);
  fk     = 1;
  while(i<imax) (
    bk = keyIsBlack(i);

    oct         = floor(i / 12);
    in_oct_pos  = i%12;

    normalized_key_offset = OCTAVE_TOP_KEY_OFFSETS[in_oct_pos];
    normalized_key_width  = OCTAVE_TOP_KEY_WIDTHS[in_oct_pos];

    // G9
    (i == 127)?(normalized_key_width = 0.5);

    key_offset = loff + (normalized_key_offset + oct * 7) * white_key_width;
    key_width  = normalized_key_width * white_key_width;

    (key_width != 0)?(

      // Key should appear at the top part of the keyboard
      left = key_offset;
      top  = key_top;

      // Draw white keys
      (!kf_enabled)?(
        // Keyboard filtering not enabled, all keys are grayed out
        gfx_rgb(keyboardKeyColor(i));
        gfx_rect(left,top,key_width,key_height_top);
      ):(

        // Keyboard filtering enabled, color depends on key conf
        gfx_rgb(keyboardKeyColor(i));
        gfx_rect(left,top,key_width,key_height_top);

        in_rect = (mouse_x >= left && mouse_y >= top && mouse_x <= (left+key_width) && mouse_y <= (top+key_height_top));
        (in_rect)?(
          keyboardKeyClickEvent(i);
        );

      );

      // Black separation lines
      gfx_rgb(TH.KEY_SEP_LINES);
      gfx_line(left+key_width-1,top,left+key_width-1,top+key_height_top-1);
      gfx_line(left-1,top,left+key_width-1,top);
      (fk)?(
        gfx_line(left-1,top,left-1,top+key_height_top-1);
      );

      (bk)?(
        gfx_line(left,top+key_height_top-1,left+key_width-1,top+key_height_top-1);
        gfx_line(left,top,left+key_width-1,top);
  /*
        // Key press marker
        (KEY_VELOCITIES[i] > 0)?(
          drawKeyboardKeyMarker(left + floor(key_width/2)-1,top+floor(key_height_top/2));
        );
  */
      );
    );
    fk = 0;
    i += 1;
  );

  // Bottom part of the keyboard
  wkcount = 0;
  i       = 0;
  imax    = i + (12 * 11); (imax > 128)?(imax = 128);
  fk      = 1;
  while(i<imax) (

    oct = floor(i / 12);
    bk  = keyIsBlack(i);

    (!bk)?(
      left = loff+wkcount*white_key_width;
      top  = key_top + key_height_top;

      // Draw white keys
      (!kf_enabled)?(
        // Keyboard filtering not enabled, all keys are grayed out
        gfx_rgb(keyboardKeyColor(i));
        gfx_rect(left,top,white_key_width,key_height_bottom);
      ):
      (
        // Keyboard filtering enabled, color depends on key conf
        gfx_rgb(keyboardKeyColor(i));
        gfx_rect(left,top,white_key_width,key_height_bottom);

        in_rect = (mouse_x >= left && mouse_y >= top && mouse_x <= (left+white_key_width) && mouse_y <= (top+key_height_bottom));
        (in_rect)?(
          keyboardKeyClickEvent(i);
        );
      );

      // Black separation line
      gfx_rgb(TH.KEY_SEP_LINES);
      gfx_line(left+white_key_width-1,top,left+white_key_width-1,top+key_height_bottom-1);
      gfx_line(left-1,top+key_height_bottom,left+white_key_width-1,top+key_height_bottom);
      (fk)?(
        gfx_line(left-1,top,left-1,top+key_height_bottom-1);
      );
  /*
      // Key press marker
      (KEY_VELOCITIES[i] > 0)?(
        drawKeyboardKeyMarker(left + floor(white_key_width/2),top+floor(key_height_bottom/2.1));
      );
  */
      // Octava number
      (i%12 == 0)?(
        gfx_rgb(TH.KEY_OCTAVA_NUMBER);
        gfx_xy(left+1,top+13);
        str = #;
        (oct == 0)?(
          sprintf(str, ".");
        ):(
          sprintf(str, "%d", oct-1);
        );

        gfx_setfont(2);
        gfx_drawstr(str);
        gfx_setfont(0);
      );

      // Increment white key counter
      wkcount += 1;
    );

    // Next key
    i += 1;
    fk = 0;
  );
);


function drawKeyboardPanel()
   local(kf_enabled)
(
  kf_enabled = isKeyboardFilteringEnabled();

  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,KEYBOARD_FILTERING_TOP,KEYBOARD_PANEL_WIDTH,20);

  // Enable/Disable
  drawEnableDisableButton(KEYBOARD_FILTERING_ENABLED,0,KEYBOARD_FILTERING_TOP + 3,10);

  // Header text
  gfx_rgb(TH.HEADER_TEXT);
  gfx_x = 90; gfx_y = KEYBOARD_FILTERING_TOP+7;

  gfx_drawstr((kf_enabled)?("Keyboard splitting"):("Keyboard splitting (All keys are green)"));

  drawKeyboardKeys();
  drawKeyboardKeyOverlay();
  drawKeyboardChannelsPanel();
  drawTransposePanel();
);

function drawBottomBanner()
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,gfx_h-20,gfx_w,20);

  // Header text
  gfx_rgb(TH.HEADER_TEXT);
  gfx_x = 6; gfx_y = gfx_h - 14;
  gfx_drawstr("Midi CC Mapper X (5.3.1) by Benjamin 'Talagan' Babut - Dedicated to Kenji Kawai");

  drawSwitchButton(GUI_MODE,0,gfx_y-4,gfx_w-134,"Global settings","Back to plugin");
);

function drawGlobalSettingsPanel()
  local(l ,t, r, b, w, in_rect, hh)
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,0,gfx_w,20);

  gfx_rgb(TH.HEADER_TEXT);
  gfx_x= 10; gfx_y = 7;
  gfx_drawstr("Global Settings");

  // Add an additional button for going back (one never knows)
  drawSwitchButton(GUI_MODE,0,4,gfx_w - 134,"Global settings","Back to plugin");

  // MIDI Bus Routing
  hh = 54;
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_xy(100,hh);
  gfx_drawstr("MIDI Bus Routing");
  hh += 22;
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_xy(100,hh);
  gfx_drawstr("In");
  gfx_xy(250,hh);
  gfx_drawstr("Out");
  drawAddOrSubWidget("midi_bus_input_widget",MIDI_BUS_INPUT,0,133,hh-4,0,16,56,0);
  drawAddOrSubWidget("midi_bus_output_widget",MIDI_BUS_OUTPUT,0,293,hh-4,0,16,56,0);
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_xy(100,hh+22);
  gfx_drawstr("MIDI events not matching the input bus will pass through.");
  hh += 58; // 134

  // Firewall option
  drawOnOffButton(DROP_UNROUTED_CC_MESSAGES,0,hh-4,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_xy(100, hh);
  gfx_drawstr("Drop unrouted CC messages");
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_xy(100, hh+20);
  gfx_drawstr("If this option is on, all CC messages from unrouted controls are dropped.");
  gfx_xy(100, hh+34);
  gfx_drawstr("This makes the plugin acts as a firewall for the CC controls.");
  hh += 55; // 284

  // Pitch Bend
  drawOnOffButton(DROP_UNROUTED_PITCH_BEND_MESSAGES,0,hh-4,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_xy(100, hh);
  gfx_drawstr("Drop unrouted PitchBend messages");
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_xy(100, hh+20);
  gfx_drawstr("If this option is on, all PitchBend messages that are not routed are dropped.");
  gfx_xy(100, hh+34);
  gfx_drawstr("This makes the plugin acts as a firewall for PitchBend messages.");
  hh += 55; // 354

  // Firewall note
  drawOnOffButton(DROP_UNROUTED_NOTE_MESSAGES,0,hh-4,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_xy(100, hh);
  gfx_drawstr("Drop unrouted Note messages");
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_xy(100, hh+20);
  gfx_drawstr("If this option is on, all Note messages that do not match the keyboard input channel are dropped.");
  gfx_xy(100, hh+34);
  gfx_drawstr("This makes the plugin acts as a firewall for the keyboard.");
  hh += 55; // 354

  // Firewall AT Poly
  drawOnOffButton(DROP_UNROUTED_AT_POLY_MESSAGES,0,hh-4,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_xy(100, hh);
  gfx_drawstr("Drop unrouted Polyphonic AfterTouch messages");
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_xy(100, hh+20);
  gfx_drawstr("If this option is on, all PAT messages that do not match the keyboard input channel are dropped.");
  gfx_xy(100, hh+34);
  gfx_drawstr("This makes the plugin acts as a firewall for polyphonic AfterTouch.");
  hh += 75; // 354

  // Theme option
  drawSwitchButton(CURRENT_THEME_NUM,0,hh-4,35,"Light","Dark");
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_xy(100,hh);
  gfx_drawstr("Theme");
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_xy(100,hh+20);
  gfx_drawstr( (currentTheme() == DARK_THEME)?(
    "Home is behind, the world ahead, many paths to tread"):(
    "But in the end, it's only a passing thing, this shadow. Even darkness must pass.")
  );
  gfx_xy(100,hh+34);
  gfx_drawstr( (currentTheme() == DARK_THEME)?(
    "Through shadows to the edge of night, until the stars are all alight."):(
    "A new day will come. And when the sun shines it will shine out the clearer.")
  );
  hh += 125;

  // Reload function library
  w = 204; l = (gfx_w - w)/2; t = hh; r = l + 204; b = t + 15;
  in_rect = (mouse_x >= l && mouse_x <= r && mouse_y >= t && mouse_y <= b);

  gfx_rgb((in_rect)?(TH.MONO_B_H):(TH.MONO_B));
  gfx_rect(l,t,r-l,b-t);

  gfx_x = l + 10; gfx_y = t+4;
  gfx_rgb(TH.MONO_B_TEXT);
  gfx_drawstr("Reload function library");

  (in_rect && mouse_click == 1)?(
    readLibFiles();
  );
);

function drawGui()
(
  updateTheme();
  gfx_clear = (TH.BACKGROUND & 0xFF) << 16 + (TH.BACKGROUND & 0x00FF00) + (TH.BACKGROUND >> 16) ;
  drawBottomBanner();
  (GUI_MODE[0] == 1)?(
    drawKeyboardPanel();
    drawControlPanel();
  ):(
    drawGlobalSettingsPanel();
  );
);

// Handles communication with lua scripts
// E.G. : For exporting things.
function listenToGmemCommands()
  local(si, addr, min_bound, max_bound)
(
  (gmem[GMEM_CMD_STATUS] == 1)?(
    // Take the command
    gmem[GMEM_CMD_STATUS] = 2;

    (g_selected_control == NONE)?(
      gmem[GMEM_CMD_ERROR]  = 600;
      gmem[GMEM_CMD_STATUS] = 4;
    ):(
      (!CONTROL_ENABLED[g_selected_control])?(
        gmem[GMEM_CMD_ERROR]  = 601;
        gmem[GMEM_CMD_STATUS] = 4;
      ):
      (
        si        = 0;
        addr      = selectedControlEditedCurveAddress();

        min_bound = controlCurrentMinDrawingBound01(g_selected_control);
        max_bound = controlCurrentMaxDrawingBound01(g_selected_control);

        while(si < CURVESIZE)
        (
          gmem[GMEM_DUMP_CURVE_BUF + si] = ((addr[si]/127.0) - min_bound)/(max_bound - min_bound);
          si += 1;
        );
        gmem[GMEM_CMD_STATUS] = 3;
      );
    );
  );
);

///////////////////////////////////
// MOUSE EVENT ADDITIONAL LOGIC  //
///////////////////////////////////

function mouseClickAddOn()
(
  // Create a mouse_click event
  (mouse_cap != g_last_mouse_cap)?(
    (mouse_cap == 1 || mouse_cap == 2)?(mouse_click = 1):(mouse_click = 0);
    g_last_mouse_cap = mouse_cap;
  ):(
    mouse_click = 0;
  );

  // Clear the capturator source
  (mouse_cap == 0)?(
     mouse_capturator = "";
  );
);

function mouseWheelAddon()
(
  mouse_wheel != 0?
  (
    mouse_wheeli = (mouse_wheel>0)?(1):(-1);
  ):(
    mouse_wheeli = 0;
  );

  mouse_wheel = 0;
);

function mouseStallAddon() (
  (mouse_x != g_last_mouse_x || mouse_y != g_last_mouse_y || mouse_cap != 0)?(
    g_last_mouse_x      = mouse_x;
    g_last_mouse_y      = mouse_y;
    g_last_mouse_change = time_precise();
  );
  g_mouse_stall = time_precise() - g_last_mouse_change;
);
//////////////
// UI MAIN  //
//////////////

function ui_main() (
  // Main Routine
  mouseClickAddon();
  mouseWheelAddon();
  mouseStallAddon();
  drawGui();
  listenToGmemCommands();
);

ui_main();

// TEST LIB LOADING

/*
zzz_set_count   = gmem[GMEM_FSET_COUNT];
zzz_test_ben = isFSetFunctionDefined(0,0,0);
zzz_t00 = getFSetFunctionAddress(0,0,0);
zzz_t01 = getFSetFunctionAddress(0,0,1);
zzz_t10 = getFSetFunctionAddress(0,1,0);

#aaa_test = getFSetId(7);
#aaa_test2 = getFSetTab(7);
*/

// TESTS : Convert to i and back
/*
aaa_test_fconv     = midiVelocityHresI2F01(0,0);
midiVelocityHresF012I(aaa_test_fconv);
aaa_test_fconv_h   = g_hres_h;
aaa_test_fconv_l   = g_hres_l;

aaa_vtest_fconv     = midiVelocityHresI2F01(0,0);
midiVelocityHresF012I(aaa_vtest_fconv);
aaa_vtest_fconv_h   = g_hres_h;
aaa_vtest_fconv_l   = g_hres_l;
*/

//===========================================//
//==============     BLOCK     ==============//
//===========================================//
@block

// Detects if conditional filter applies to a value (input or output) and returns the resulting channel
function applyConditionalFiltering(blk_control, is_input, val_01, src_chan, dst_chan)
  local(en_inf, en_sup, inf01, sup01, sup_verified, inf_verified, chan_if_match)
(
  g_last_cf_matched = 0;

  // Apply conditional filtering on input
  (isConditionalFilteringOperationalForControl(blk_control))?(

    en_inf = (is_input)?(isConditionalFilteringInInfEnabledForControl(blk_control)):(isConditionalFilteringOutInfEnabledForControl(blk_control));
    en_sup = (is_input)?(isConditionalFilteringInSupEnabledForControl(blk_control)):(isConditionalFilteringOutSupEnabledForControl(blk_control));
    inf01  = (is_input)?(controlConditionalFilteringInInf01(blk_control)):(controlConditionalFilteringOutInf01(blk_control));
    sup01  = (is_input)?(controlConditionalFilteringInSup01(blk_control)):(controlConditionalFilteringOutSup01(blk_control));

    chan_if_match = conditionalFilteringDstChanForControl(blk_control);

    // Conditions need to include >= and == for casting problems
    // >= may return false while == returns true :(
    sup_verified = (val_01 >= sup01 || val_01 == sup01);
    inf_verified = (val_01 <= inf01 || val_01 == inf01);

    (en_inf && en_sup && (sup01 <= inf01))?(
      // Intersection band (AND)
      (sup_verified && inf_verified)?(
        dst_chan = chan_if_match;
        g_last_cf_matched = 1;
      );
    ):(
      // Non intersection band (OR)
      (en_inf)?(
        (inf_verified)?(
          dst_chan = chan_if_match;
          g_last_cf_matched = 1;
        );
      );
      (en_sup)?(
        (sup_verified)?(
          dst_chan = chan_if_match;
          g_last_cf_matched = 1;
        );
      );
    );

    dst_chan = (dst_chan == AS_SRC)?(src_chan):(dst_chan);
  );

  dst_chan;
);
// Alias for inputs
function applyConditionalInputFiltering(blk_control, in_val_01, src_chan, dst_chan)
  local(res)
(
  res = applyConditionalFiltering(blk_control, 1, in_val_01, src_chan, dst_chan);
  g_last_cfi_matched = g_last_cf_matched;
  res;
);
// Alias for outputs
function applyConditionalOutputFiltering(blk_control, out_val_01, src_chan, dst_chan)
  local(res)
(
  res = applyConditionalFiltering(blk_control, 0, out_val_01, src_chan, dst_chan);
  g_last_cfo_matched = g_last_cf_matched;
  res;
);


function produceAndEmitCCOutputForControl(blk_control, in_val_01, src_chan, dst_chan, mpos)
  local(out_val_01, out_cc_num, out_status)
(
  // Apply the curve
  out_val_01 = applyCurve(blk_control, in_val_01);

  dst_chan = applyConditionalOutputFiltering(blk_control, out_val_01, src_chan, dst_chan);

  (dst_chan != DROP)?(

    // Save some values for UI feedback (small red circle)
    CONTROL_LAST_IN[blk_control]  = in_val_01 * 127;
    CONTROL_LAST_OUT[blk_control] = out_val_01 * 127;

    // Save activity for this control+channel
    // This will be used by the auto-emit feature
    setOutputActivityForControlOnChannel(blk_control, dst_chan, in_val_01);

    out_cc_num          = CONTROL_DSTS[blk_control];
    out_status          = (MSG_CC<<4)|(dst_chan-1); // Chan : 1-16 ->> 0-15

    controlHasOperationalHighResOutput(blk_control) ? (
      // Output high res
      midiCCHresF012I(out_val_01);
      // Be compliant with reaper : MSB first, LSB last
      midiSend(mpos, out_status, out_cc_num,                    g_hres_h);
      midiSend(mpos, out_status, ccLsbCounterpart(out_cc_num),  g_hres_l);
    ):(
      (out_cc_num == CHANNEL_PRESSURE_FAKE_CC_NUM)?(
        // Channel pressure conversion
        out_status = (MSG_CHAN_PRESSURE<<4)|(dst_chan-1);
        midiSend(mpos, out_status, roundi(out_val_01 * 127), 0);
      ):(
        // Output low res, normalize by 127 (max is 127).
        midiSend(mpos, out_status, out_cc_num, roundi(out_val_01 * 127) );
      );
    );
  );
);

function produceAndEmitPitchBendOutputForControl(blk_control, in_val_01, src_chan, dst_chan, mpos)
  local(sigmul, out_val_01, out_val, out_status)
(
  sigmul     = (in_val_01 >=0)?(1.0):(-1.0);

  // Apply the curve on the absolute val
  out_val_01 = applyCurve(blk_control, sigmul * in_val_01);

  dst_chan   = applyConditionalOutputFiltering(blk_control, out_val_01, src_chan, dst_chan);

  (dst_chan != DROP)?(
    // Save some values for UI feedback (small red circle)
    CONTROL_LAST_IN[blk_control]  = in_val_01 * 127;
    CONTROL_LAST_OUT[blk_control] = out_val_01 * 127;

    // Reverse value if asked
    (REVERSE_PITCH_BEND[0])?(
      out_val_01 = - out_val_01;
    );

    // Convert back
    out_val = roundi( ((sigmul * out_val_01) * 0x1FFF  + 0x2000) );

    // Send result
    out_status = (MSG_PITCH_BEND<<4)|(dst_chan-1); // Chan : 1-16 ->> 0-15

    // Output low res, normalize by 127 (max is 127).
    midiSend(mpos, out_status, out_val & 0x7F , (out_val >> 7) & 0x7F);
  );
);

// For a given CONTROL on the UI, try to process the CC message
// The value is not passed. It's already been stored in CC_RECEIVED_VALUES.
function tryProcessCCWithControl(evt, blk_control)
  local (in_val_01, src_chan, dst_chan,
         src_is_hr, src_cc, src_msb_cc, src_lsb_cc,
         ctrl_is_enabled, src_cc_matches, src_chan_matches,
         control_is_for_real_cc, src_is_ok )
(
  control_is_for_real_cc      = isControlForRealCC(blk_control);
  ctrl_is_enabled             = isControlEnabled(blk_control);
  src_chan                    = controlInputChannel(blk_control);
  src_chan_matches            = (src_chan == ANY || src_chan == evt.chan );

  (control_is_for_real_cc && ctrl_is_enabled && src_chan_matches)?(

    src_is_hr                   = controlHasOperationalHighResInput(blk_control);
    src_cc                      = CONTROL_SRCS[blk_control];
    src_msb_cc                  = (src_is_hr)?(msbCCForAggregatedHRCC(src_cc)):(src_cc);
    src_lsb_cc                  = (src_is_hr)?(lsbCCForAggregatedHRCC(src_cc)):(src_cc);
    src_cc_matches              = (src_is_hr)?(src_msb_cc == evt.cc_num || src_lsb_cc == evt.cc_num):(src_cc == evt.cc_num);

    (src_cc_matches)?(

      dst_chan = controlOutputChannel(blk_control);
      dst_chan = (dst_chan == AS_SRC)?(evt.chan):(dst_chan);

      // Calculate curve result
      in_val_01  = 0;

      src_is_hr ? (
        (src_msb_cc == evt.cc_num)?(

          // Event is a msb, lookup for next event for a lsb
          (evtn.present && evtn.cc_num == src_lsb_cc)?(

            // Next event is a matching lsb event
            in_val_01   = midiCCHresI2F01(evt.cc_val, evtn.cc_val);

            // Mark next event as processed to skip it at next round.
            evtn.was_processed = 1;

          ):(
            // Next event does not exist or is not the LSB counterpart, so use zero as lsb.
            in_val_01   = midiCCHresI2F01(evt.cc_val, 0);
          );

        ):(
          // Event is a lsb, use MSB memory for msb and event value for lsb.
          in_val_01   = midiCCHresI2F01(CC_RECEIVED_VALUES[src_msb_cc], evt.cc_val);
        );

      ):(
        // Low res are normalized with a max of 127.0
        in_val_01   = evt.cc_val/127.0;
      );

      // Apply conditional filtering on input. This may re-route the message (and set the dst_chan to DROP).
      dst_chan = applyConditionalInputFiltering(blk_control, in_val_01, evt.chan, dst_chan);

      (dst_chan != DROP)?(
        produceAndEmitCCOutputForControl(blk_control, in_val_01, evt.chan, dst_chan, evt.mpos);
      );

      // Set the pass through flag.
      controlShouldPassThrough(blk_control)?(
        evt.should_pass_through = 1;

        (evtn.was_processed)?(
          // Since we used the next event as LSB, we should also pass it through if asked.
          evtn.should_pass_through = 1;
        );
      );

      evt.was_processed = 1;
    ):(

      // If the control has MSB + HR as input
      // If the cc of the event is the LSB of that MSB
      // Treat event as processed (it's aggregated during the treatment of the MSB event and eaten)
      (controlHasOperationalHighResInput(blk_control) && (evt.cc_num == ccLsbCounterpart(CONTROL_SRCS[blk_control]))) ? (

        // Set the pass through flag if needed for re-emission
        controlShouldPassThrough(blk_control)?(
          evt.should_pass_through = 1;
        );

        evt.was_processed = 1;
      );
    );
  );
  evt;
);

function processCCMessage(evt)
  local (process_counter, blk_control)
(
  // Memorize, may be useful
  CC_RECEIVED_VALUES[evt.cc_num] = evt.cc_val;

  (
    // Loop on all controls and see if we could find
    // Some of them linked to that cc.
    blk_control = 0; while(blk_control < CONTROL_COUNT)
    (
      tryProcessCCWithControl(evt, blk_control);
      blk_control       += 1;
    );
  );

  evt;
);

function processNoteMessage(evt)
  local(new_key, key_range_resolved,
    src_chan, dst_chan, src_chan_matches, dst_status,
    should_keep_note,
    velocity_control_num,
    has_velocity, is_note_on,
    in_velocity_01, out_velocity_01,
    velocity_tgt, lsb_cc_msg)
(
  // CAUTION 1 : Note OFF can be either (MSG_NOTE_OFF) or (MSG_NOTE_ON + velocity ZERO), thus :
  // Note ON + Velocity 0 should not be changed to something else due to the curve applying.

  // CAUTION 2 : Note Off messages may have velocities.
  // Atm, we don't manage them, so we'll apply routing but not the curve
  // And leave them untouched

  // Set velocity to zero for note off messages
  // (evt.type == MSG_NOTE_OFF)?(evt.velocity = 0);

  has_velocity    = (evt.velocity != 0);
  is_note_on      = (evt.type == MSG_NOTE_ON);

  // Save the source velocity, this is for UI feedback (small dots on keys)
  // Use 0 for note off velocities, so that these indicators disappear
  KEY_VELOCITIES[evt.key] = (is_note_on)?(evt.velocity):(0);
  KEY_CHANNELS[evt.key]   = evt.chan;

  key_range_resolved    = keyKBRangeResolved(evt.key);
  velocity_control_num  = velocityControlForKBRange(key_range_resolved);
  src_chan              = keyboardInputChannel();
  src_chan_matches      = (src_chan == evt.chan || src_chan == ANY);

  // Beware the logic below is a bit different than the one for CCs,
  // Because transposition may be applied even if the control is off,
  // And also because the routing may be applied even if the control is off.

  (src_chan_matches)?(

    dst_chan  = kbRangeOutputChannel(key_range_resolved);
    dst_chan  = (dst_chan == AS_SRC)?(evt.chan):(dst_chan);

    new_key = evt.key;

    // Transpose if asked to
    (shouldTransposeKBRange(key_range_resolved))?(
      new_key = evt.key + kbRangeTransposition(key_range_resolved);
    );

    // Transposition should not be outside midi range
    (new_key >= 0 && new_key <= 127)?(

      // in_velocity_01 : gives the velocity for note on events
      in_velocity_01  = evt.velocity/127.0;
      out_velocity_01 = 0;

      (isControlEnabled(velocity_control_num))?(

        // CALCULATE INPUT VALUE HI/LOW RES
        (isHighResMidiInputEnabledForControl(velocity_control_num))?(
          (is_note_on && has_velocity)?(
            // Seems to me we have to sub 1 to the velocity (MSB)
            // To be continuous starting from 0
            // (First non-null HR velocity starts at 0x0080, MSB is non null)
            in_velocity_01 = midiVelocityHresI2F01(evt.velocity-1, CC_RECEIVED_VALUES[88]);

            // Do not clear CC#88 anymore, expect the user to know what he/she's doin'.
            // If something is in CC#88 which is different from 0
            // Either it's High Res MIDI
            // Or the user is using CC#88 for a different reason and should not enable HR velocity.
            // CC_RECEIVED_VALUES[88] = 0;
          );
        );

        (is_note_on && has_velocity)?(
          // NOTE ON
          // Apply velocity curve and conditionally reroute/filter if needed

          // Apply conditional filtering on input. This may re-route the message (and set the dst_chan to DROP).
          dst_chan = applyConditionalInputFiltering(velocity_control_num, in_velocity_01, evt.chan, dst_chan);

          (dst_chan != DROP)?(
            out_velocity_01 = applyCurve(velocity_control_num, in_velocity_01);

            // Apply conditional filtering on the output. This may re-route the message (and set the dst_chan to DROP).
            dst_chan = applyConditionalOutputFiltering(velocity_control_num, out_velocity_01, evt.chan, dst_chan);

            (dst_chan != DROP)?(
              // Save for UI feedback (red circle).
              // Do it only when there's some velocity, having the circle
              // going back to 0 each time we release a key is annoying
              CONTROL_LAST_IN[velocity_control_num]   = in_velocity_01*127;
              CONTROL_LAST_OUT[velocity_control_num]  = out_velocity_01*127;
            ); // <-- Not dropped on ouput
          ); // <-- Not dropped on input

          // Remember the routing we've just decided for this NOTE ON event.
          setVelocityActivityDstChan(evt.chan, new_key, dst_chan);
        ):(
          // (NOTE OFF) or (NOTE ON + velocity ZERO)

          (isConditionalFilteringOperationalForControl(velocity_control_num))?(
            // The event should follow the last choice made for the corresponding NOTE ON event
            dst_chan = getVelocityActivityDstChan(evt.chan, new_key);
          );

          // Leave velocity untouched (for Note Off or Note On vel ZERO)
          out_velocity_01 = in_velocity_01;
        )
      ):(
        out_velocity_01 = in_velocity_01;
      ); // <-- isControlEnabled


      // Final Result Sending
      (dst_chan != DROP)?(

        // Create out status, remap chan to to 0-15
        dst_status = (evt.type << 4) | (dst_chan-1);

        (is_note_on && isControlEnabled(velocity_control_num) && isHighResMidiOutputEnabledForControl(velocity_control_num))?(
          // High-Res Note ON case

          lsb_cc_msg = ((MSG_CC << 4) | evt.chan);

          // Send modified velocity
          // If Note On + vel ZERO, out_velocity_01 is already forced to zero
          midiVelocityHresF012I(out_velocity_01);

          // Note : if pen drawn
          // g_hres_l will always be = 127 due to the drawing resolution
          midisend(evt.mpos, lsb_cc_msg, 88, g_hres_l);
          midisend(evt.mpos, dst_status, keyToMidiNote(new_key), g_hres_h);

        ):(
          // Other cases :
          // - Note ON with low res (Zero or non-zero vel)
          // - Note OFF (Zero or non-zero vel)
          midisend(evt.mpos, dst_status, keyToMidiNote(new_key), roundi(out_velocity_01 * 127) );
        );
      ); // <- dst chan is not drop
    ); // <- Transposition is not outside range

    // If pass through is set explicitely, duplicate
    (isControlEnabled(velocity_control_num))?(
      controlShouldPassThrough(velocity_control_num)?(
        evt.should_pass_through = 1;
      );
    );

    // As long as the input channel is concerned
    // Consider the event as treated (it's either DROPPED explicitly or handled).
    evt.was_processed = 1;

  ); // <- src chan matches

  evt;
);

function processPolyphonicAfterTouchMessage(evt)
  local(blk_control, velocity_control,
        src_chan, src_chan_matches,
        dst_chan, dst_status,
        new_key, key_range_resolved,
        in_val_01, out_val_01)
(
  key_range_resolved      = keyKBRangeResolved(evt.key);
  blk_control             = afterTouchControlForKBRange(key_range_resolved);
  velocity_control        = velocityControlForKBRange(key_range_resolved);
  src_chan                = keyboardInputChannel();
  src_chan_matches        = (src_chan == evt.chan || src_chan == ANY);

  (src_chan_matches)?(

    // As long as src chan matches, re-route (it's like note messages)
    dst_chan  = kbRangeOutputChannel(key_range_resolved);
    dst_chan  = (dst_chan == AS_SRC)?(evt.chan):(dst_chan);

    new_key = evt.key;

    // Transpose if asked to.
    // It should be done even if the AT control is not activated, for coherency.
    (shouldTransposeKBRange(key_range_resolved))?(
      new_key = evt.key + kbRangeTransposition(key_range_resolved);
    );

    // Transposition should not be outside midi range
    (new_key >= 0 && new_key <= 127)?(

      in_val_01   = evt.after_touch/127.0;
      out_val_01  = 0;

      // Apply control if needed
      (isControlEnabled(blk_control))?(
        // Apply conditional filtering on input. This may re-route the message (and set the dst_chan to DROP).
        dst_chan    = applyConditionalInputFiltering(blk_control, in_val_01, evt.chan, dst_chan);

        (dst_chan != DROP)?(

          out_val_01        = applyCurve(blk_control, in_val_01);
          dst_chan          = applyConditionalOutputFiltering(blk_control, out_val_01, evt.chan, dst_chan);

          // - If we have the "follow option"
          // - If no rerouting conditions matched
          // - But the associated velocity widget is enabled
          // - And it has conditional filtering on
          // Then reroute as last note ON
          (isConditionalFilteringOperationalForControl(blk_control) &&
            doesKbRangeAfterTouchFollowVelocity(key_range_resolved) &&
            isControlEnabled(velocity_control) &&
            isConditionalFilteringOperationalForControl(velocity_control) &&
            !g_last_cfi_matched &&
            !g_last_cfo_matched)?
          (
            dst_chan = getVelocityActivityDstChan(evt.chan, new_key);
          );

          (dst_chan != DROP)?(
            // Save for UI feedback (red circle).
            CONTROL_LAST_IN[blk_control]   = in_val_01 *127;
            CONTROL_LAST_OUT[blk_control]  = out_val_01*127;
          );
        );
      ):(
        // Just keep the value as is (bypass any calculation)
        out_val_01 = in_val_01;
      );

      (dst_chan != DROP)?(
        // Create out status, remap chan to to 0-15
        dst_status = (evt.type << 4) | (dst_chan-1);

        midisend(evt.mpos, dst_status, keyToMidiNote(new_key), roundi(out_val_01 * 127) );
      );
    ); // <- Transposition is not outside range


    (isControlEnabled(blk_control))?(
      (controlShouldPassThrough(blk_control))?(
        evt.should_pass_through = 1;
      );
    );

    // As long as the input channel is concerned
    // Consider the event as treated (it's either DROPPED explicitly or handled).
    evt.was_processed = 1;

  ); // <- src chan matches

  evt;
);

function processPitchBendMessage(evt)
  local(blk_control,
  src_chan, dst_chan,
  src_chan_matches, ctrl_is_enabled,
  in_val, in_val_01)
(
  blk_control                 = CONTROL_PITCH_BEND;
  src_chan                    = controlInputChannel(blk_control);

  src_chan_matches            = (src_chan == ANY || src_chan == evt.chan );
  ctrl_is_enabled             = isControlEnabled(blk_control);

  (src_chan_matches && ctrl_is_enabled)?(

    dst_chan  = controlOutputChannel(blk_control);
    dst_chan  = (dst_chan == AS_SRC)?(evt.chan):(dst_chan);

    // Pitch bend goes from 0 to 0x3FFF, center value is 0x2000.
    // There are thus 0x4000 possible values
    //
    // - 0x2000 values are negative, in ReaControlMIDI [-8192..-1]
    // - 1 is zero
    // - 0x1FFF values are positive, in ReaControlMIDI [1..8191]
    //
    // It is not symmetrical, and we have a problem to apply the curve.
    // We will assume to not use -8192 and remap it to -8191.

    in_val = evt.pitch_bend;

    // Merge 0 and 1 (0 should not exist)
    (in_val == 0)?(in_val = 1);

    // Put this into -1..1
    in_val_01   = (in_val * 2.0 - 0x4000)/0x3FFE;

    dst_chan = applyConditionalInputFiltering(blk_control, abs(in_val_01), evt.chan, dst_chan);

    (dst_chan != DROP)?(
      produceAndEmitPitchBendOutputForControl(blk_control, in_val_01, evt.chan, dst_chan, evt.mpos);
    );

    controlShouldPassThrough(blk_control)?(
      evt.should_pass_through = 1;
    );

    // Consider the event as treated.
    evt.was_processed = 1;
  ); // <- src chan matches and ctrl is enabled

  evt;
);

// Receive a new event. It is loaded into evtn, and evtn is loaded to evt.
// This gives a forward lookup of one event to the plugin so that it can handle 14-bit CC events.
// In the vast majority of cases, evtn is just useless and evt does not need forward lookup.

function receive()
  local(mpos,msg1,msg2,msg3)
(
  // Copy evtn to current evt if present
  (evtn.present)?(

    evt.bus         = evtn.bus;
    evt.mpos        = evtn.mpos;
    evt.msg1        = evtn.msg1;
    evt.msg2        = evtn.msg2;
    evt.msg3        = evtn.msg3;
    evt.status      = evtn.status;
    evt.type        = evtn.type;
    evt.chan        = evtn.chan;
    evt.cc_num      = evtn.cc_num;
    evt.cc_val      = evtn.cc_val;

    evt.should_pass_through = evtn.should_pass_through;
    evt.was_processed       = evtn.was_processed;
  );

  evt.present = evtn.present;

  (midirecv(mpos, msg1, msg2, msg3))?(
    evtn.bus          = midi_bus + 1; // 1-16, not 0-15
    evtn.mpos         = mpos;
    evtn.msg1         = msg1;
    evtn.msg2         = msg2;
    evtn.msg3         = msg3;
    evtn.status       = msg1;
    evtn.type         = (msg1 >> 4) & 0x0F;
    evtn.chan         = (msg1 & 0x0F) + 1; // 1-16, not 0-15

    // Since we will use forward lookup for 14-bit CC
    // Pre-translate cc_num / cc_val, we will need them on evtn
    // We could also do that for other types of event
    // But do not want to make the code heavier here.
    (evtn.type == MSG_CC)?(
      evtn.cc_num = msg2;
      evtn.cc_val = msg3;
    ):(
      evtn.cc_num = 0;
      evtn.cc_val = 0;
    );

    evtn.should_pass_through  = 0;
    evtn.was_processed        = 0;

    evtn.present = 1;
  ):(
    evtn.present = 0;
  );
);

function forwardCurrentEvent() (
  midisend(evt.mpos, evt.msg1, evt.msg2, evt.msg3)
);

function treatCurrentEvent()
(
  // If bus matches
  (midiBusInput() == ANY || midiBusInput() == evt.bus)?(

    // Set output midi_bus
    midi_bus = (midiBusOutput() == AS_SRC)?(evt.bus-1):(midiBusOutput()-1);

    // Start to  treat
    (evt.type == MSG_CC) ? (

      // CC LEARN (prior to message handling)
      (isCCLearning() && g_selected_control != NONE && isCCLearnableForControl(g_selected_control, evt.cc_num))?(

        // When learning, if HR is enabled, then learn the control on the MSB (be it LSB or MSB),
        // to avoid jittering between MSB and LSB. Probably more natural like this.
        (isHighResMidiInputEnabledForControl(g_selected_control) && isALsbCC(evt.cc_num) )?(
          CONTROL_SRCS[g_selected_control] = ccMsbCounterpart(evt.cc_num);
        ):(
          CONTROL_SRCS[g_selected_control] = evt.cc_num;
        );
        disableCCLearn();
      );

      processCCMessage(evt);

      (!evt.was_processed && !shouldDropUnroutedCCMessages())?(
        // Event not treated and not firewalled. Pass message.
        forwardCurrentEvent();
      );

      // Explicit user pass through
      (evt.was_processed && evt.should_pass_through)?(
        forwardCurrentEvent();
      );

    ):(
    (evt.type == MSG_NOTE_ON || evt.type == MSG_NOTE_OFF)?(

      // NOTE MESSAGE
      evt.note      = evt.msg2;
      evt.key       = midiNoteToKey(evt.note);
      evt.velocity  = evt.msg3;

      processNoteMessage(evt);

      (!evt.was_processed && !shouldDropUnroutedNoteMessages())?(
        forwardCurrentEvent();
      );

      // Explicit user pass through
      (evt.was_processed && evt.should_pass_through)?(
        forwardCurrentEvent();
      );

    ):(
    (evt.type == MSG_AT_POLY)?(

      // POLYPHONIC AFTERTOUCH
      evt.note        = evt.msg2;
      evt.key         = midiNoteToKey(evt.note);
      evt.after_touch = evt.msg3;

      processPolyphonicAfterTouchMessage(evt);

      (!evt.was_processed && !shouldDropUnroutedPolyphonicAfterTouchMessages())?(
        forwardCurrentEvent();
      );

      // Explicit user pass through
      (evt.was_processed && evt.should_pass_through)?(
        forwardCurrentEvent();
      );

    ):(
    (evt.type == MSG_CHAN_PRESSURE)?(

      // CHANNEL PRESSURE (Treat as any CC)
      evt.chan_pressure = evt.msg2;
      evt.cc_num        = CHANNEL_PRESSURE_FAKE_CC_NUM;
      evt.cc_val        = evt.chan_pressure;

      // CC LEARN
      (isCCLearning() && g_selected_control != NONE)?(
        CONTROL_SRCS[g_selected_control] = evt.cc_num;
        disableCCLearn();
      );

      processCCMessage(evt);

      (!evt.was_processed && !shouldDropUnroutedCCMessages())?(
        forwardCurrentEvent();
      );

      // Explicit user pass through
      (evt.was_processed && evt.should_pass_through)?(
        forwardCurrentEvent();
      );

    ):(
    (evt.type == MSG_PITCH_BEND)?(

      // PITCH BEND
      evt.pitch_bend = ((evt.msg3 & 0x7F) << 7) | (evt.msg2 & 0x7F);

      processPitchBendMessage(evt);

      (!evt.was_processed && !shouldDropUnroutedPitchBendMessages())?(
        forwardCurrentEvent();
      );

      // Explicit user pass through
      (evt.was_processed && evt.should_pass_through)?(
        forwardCurrentEvent();
      );

    ):(
      // Unhandled type of message, pass through
      forwardCurrentEvent();
    )))));
  ):(
    // Bus not matching leave untouched
    forwardCurrentEvent();
  );
);

function handleMidiEvents()
(
  // Cur and next events
  evt           = 0;
  evtn          = 1;

  // Has cur / has next
  evt.present   = 0;
  evtn.present  = 0;

  // Pre load next event
  receive();

  (evtn.present)?(

    // Put next into cur, load next
    receive();

    while(evt.present)
    (
      (!evt.was_processed)?(
        treatCurrentEvent();
      ):(
        // If the evt is already marked as processed, it means that it was eaten
        // During the time it was used as evtn (high-res cc forward lookup).
        // So it is already eaten.

        (evt.should_pass_through)?(
          // But if it was marked as "pass through", we should at least forward it.
          forwardCurrentEvent();
        );

        // Else, we will simply ignore the event.
      );

      receive();
    );
  );
);

function handleSliderEvents()
  local(cnum, chani, last_activity) (

  (g_slider_activity_this_block)?(

    // There's activity on some sliders
    cnum = 0;
    while(cnum < CONTROL_COUNT) (
     (MORPH_SLIDER_ACTIVITY[cnum] != 0)?(

        // Handle Slider activity for control.
        (isMorphingEnabledForControl(cnum) && isMorphAutoEmitEnabledForControl(cnum))?(

          // Loop on all channels, and simulate activity for known active channels
          chani = 0;
          while(chani < 16) (
            last_activity = outputActivityForControlOnChannel(cnum,chani);

            (last_activity >= 0)?(

              // Auto-Emit MIDI events to respond to morph slider changes
              // Use the last sample index of the block for this.

              (isControlPitchBend(cnum))?(
                // Use the activity chan as both src and dst chan
                produceAndEmitPitchBendOutputForControl(cnum, last_activity, chani, chani, samplesblock - 1);
              );

              (isControlForRealCC(cnum))?(
                // Use the activity chan as both src and dst chan
                produceAndEmitCCOutputForControl(cnum, last_activity, chani, chani, samplesblock - 1);
              );

              // No support for velocity or PAT (makes no sense).
            );

            chani += 1;
          );
        );

        // Clear Sliver Activity
        MORPH_SLIDER_ACTIVITY[cnum] = 0;
      );
      cnum += 1;
    );

    g_slider_activity_this_block = 0;
  );
);
function mainLoop() (
  handleMidiEvents();
  handleSliderEvents();
);

mainLoop();
