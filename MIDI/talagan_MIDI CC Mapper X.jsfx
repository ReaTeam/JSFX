desc: MIDI CC Mapper X
author: Talagan
version: 3.3
changelog:
  Fix : HighRes midi velocity was not properly handled for MSB 1, LSB 0.
  Fix : Highres midi velocity LSB was not sent on the proper CC (#88).
  Added a "pen" button to trigger pen mode, to avoid accidental clicks on the curve
  Added channel routing options for notes and ccs.
  Added firewall option for unrouted notes.
  Since red keys may now be kept due to channel re-routing, added an option to select what keys are transposed (All/Green/Red)
  Since red keys may now be kept due to channel re-routing, added an option to select what keys are affected by the velocity control (All/Green/Red)
  Added curve mih/max behaviours : the user can now set some min/max limits on the curve, so that the curve is clamped between those bounds. Predefined curves will be adapted to that range and pen drawing will be restricted to that range too.
  And a bit of source code cleaning.
screenshot:
  Dark Theme https://stash.reaper.fm/37471/CCMapperX-Dark.png
  Light Theme https://stash.reaper.fm/37472/CCMapperX-Light.png
about:
  # Midi CC Mapper X

  This JSFX  is an extended version of the original plugin called "MIDI CC Mapper" with many more features. It allows to modify the behavior and the real-time feel of a MIDI controller, by acting as a pre-filter on the MIDI input. It can : 

  - Filter in/out keyboard keys, channel split and drop/re-route keyboard keys
  - Transpose keyboard keys
  - Re-route CCs
  - Re-route CC channels
  - Tweak CC response curves, either by using predefined curves, or by pen-drawing/smoothing custom curves.
  - Tweak the keyboard velocity response curve

  The UI shows a virtual controller, on which CCs can be attributed to controls, allowing a user to visually map her/his real controller.

  High-Res MIDI input can be enabled via a global parameter, and High-Res MIDI output can be enabled on CCs individually.

  ## Keyboard Filtering Module

  Located in the top left of the main window, it can be used to achieve various configurations. You can enable/disable key colorizing with the button located in the module title bar. If key colorizing is enabled, the keys can be colorized in red/green by click/moving the mouse on them. The UI provides feedback for currently pressed keys.

  An input channel may be defined for the keyboard : all other channels will be ignored by the plugin. Output channels may be defined for the green/red parts of the keyboard to possibly reroute them, with the option to drop the red part (to filter them out).

  This module can be of great help for defining regions on the keyboard. By reusing it on multiple tracks at the same time, you can easily achieve keyboard split (left hand/right hand or more) and/or multi-instruments combinations.

  ## Keyboard Transposition Module

  Located in the top right of the main window. This module can be enabled or bypassed with the button located in the module title bar. If enabled, applies the sum of two parameters, one for transposing by octaves, one for transposing by semitones. This module can be optionally applied to the red/green/both parts of the keyboard.

  ## CC Routing/Curve tweaking

  Located in the bottom of the main window. This module UI is contextual to the selected control. When selected, a control can be enabled or disabled individually with the button located in the module title bar. For each control :

  - A description can be given that will appear in the title bar
  - A short description can be given that will appear close to the control for convenience
  - An input CC can be assigned (except for the velocity control which is tied to the keyboard velocity)
  - This input CC can be CC learned
  - An output CC can be assigned
  - This output CC can be copied from the input CC
  - The response curve can be pendrawn by hand with the mouse
  - The response curve can be defined from one of the templates on the right
  - The response curve can be smoothed with the smooth button
  - The response curve may be restricted to a user-defined space by configuring MIDI min/max values.

  Additionally, channel input/output may be configured for the CC.

  ## Reaper forum thread

  https://forum.cockos.com/showthread.php?t=172630

  ## Notes

  Older versions (v1 and v2) can be found on the forum thread.

desc: MIDI CC Mapper X
author: Talagan
version: 3.3
changelog:
  Added theme system, with two themes, Dark and Light.
  Reworked contrasts on Dark Theme.
  Bug fix : red curve feedback circle was a bit shifted if the CC was set to High Res.
screenshot:
  Dark Theme https://stash.reaper.fm/37471/CCMapperX-Dark.png
  Light Theme https://stash.reaper.fm/37472/CCMapperX-Light.png
about:
  # Midi CC Mapper X

  This JSFX  is an extended version of the original plugin called "MIDI CC Mapper" with many more features. It allows to modify the behavior and the real-time feel of a MIDI controller, by acting as a pre-filter on the MIDI input. It can : 

  - Filter in/out keyboard keys
  - Transpose keyboard keys
  - Re-route CCs
  - Tweak CC response curves, either by using predefined curves, or by pen-drawing/smoothing custom curves.
  - Tweak the keyboard velocity response curve

  The UI shows a virtual controller, on which CCs can be attributed to controls, allowing a user to visually map her/his real controller.

  High-Res MIDI input can be enabled via a global parameter, and High-Res MIDI output can be enabled on CCs individually.

  ## Keyboard Filtering Module

  Located in the top left of the main window. This module can be enabled or bypassed with the button located in the module title bar. If enabled, all keys colorized in red are filtered out. The keys can be colorized by click/moving the mouse on them. The UI provides feedback for currently pressed keys.

  This module can be of great help for defining regions on the keyboard. By reusing it on multiple tracks at the same time, you can easily achieve keyboard split (left hand/right hand or more) and/or multi-instruments combinations.

  ## Keyboard Transposition Module

  Located in the top right of the main window. This module can be enabled or bypassed with the button located in the module title bar. If enabled, applies the sum of two parameters, one for transposing by octaves, one for transposing by semitones.

  ## CC Routing/Curve tweaking

  Located in the bottom of the main window. This module UI is contextual to the selected control. When selected, a control can be enabled or disabled individually with the button located in the module title bar. For each control :

  - A description can be given that will appear in the title bar
  - A short description can be given that will appear close to the control for convenience
  - An input CC can be assigned (except for the velocity control which is tied to the keyboard velocity)
  - This input CC can be CC learned
  - An output CC can be assigned
  - This output CC can be copied from the input CC
  - The response curve can be pendrawn by hand with the mouse
  - The response curve can be defined from one of the templates on the right
  - The response curve can be smoothed with the smooth button

  ## Reaper forum thread

  https://forum.cockos.com/showthread.php?t=172630

  ## Notes

  Older versions (v1 and v2) can be found on the forum thread.

license:
  MIT (Do whatever you like with this code).

// Helpful Documentation
//
// Midi HR for Velocity : https://forum.cockos.com/showthread.php?t=83782

options:want_all_kb

//===========================================//
//=============      INIT      ==============//
//===========================================//
@init

NOTE_OFF_MSG              = 8;
NOTE_ON_MSG               = 9;
CC_MSG                    = 11; // 0x0B

// Plugin Controls parameters
CONTROL_COUNT             = 36;  // mod wh + 4 peds + 10 Sliders + 10 knobs + 10 pads + velo

CONTROL_WHEELS_START      = 0;
CONTROL_PEDALS_START      = 1;
CONTROL_FADERS_START      = 5;
CONTROL_KNOBS_START       = 15;
CONTROL_PADS_START        = 25;
CONTROL_VELOCITY_START    = 35;
CONTROL_MOD_WHEEL         = CONTROL_WHEELS_START;
CONTROL_VELOCITY          = CONTROL_VELOCITY_START;

// Curve parameters
RESOLUTION                = 2;
BUTTON_GRID_SIZE          = 10;
CURVESIZE                 = 128; // 1:1 for control values going from 0 to 127 

// Curve buttons params
BUTTON_ROW_LINEAR = 0;
BUTTON_ROW_POW2   = 1;
BUTTON_ROW_POW3   = 2;
BUTTON_ROW_CIRC   = 3;
BUTTON_ROW_STEP   = 4;
BUTTON_ROW_GATE   = 5;

// Various UI dimensions
KEYBOARD_FILTERING_TOP   = 0;
CONTROL_PANEL_TOP        = 130;
GUI_CONTROL_PARAMS_TOP   = 260;

KEYBOARD_PANEL_WIDTH     = 670;

// Pseudo-Object that contains pointer to colors
TH            = 0;

// Theme nums
DARK_THEME    = 0;
LIGHT_THEME   = 1;

// Helper function for memory allocation.
MEM_PTR  = 0;
function malloc(msize)
  local(ret)
(
  ret = MEM_PTR;
  MEM_PTR += msize;
  ret;
);

////////////////////////////////
// Persistent data (user conf)
////////////////////////////////

CONTROL_ENABLED                 = malloc(CONTROL_COUNT);
CONTROL_SRCS                    = malloc(CONTROL_COUNT);
CONTROL_DSTS                    = malloc(CONTROL_COUNT);
CONTROL_HIGHRES_OUTPUT_ENABLED  = malloc(CONTROL_COUNT);  // Per control option
CURVES                          = malloc(CONTROL_COUNT*CURVESIZE);

KEYBOARD_FILTERING_ENABLED      = malloc(1);
KEYBOARD_FILTERED_NOTES         = malloc(88);
KEYBOARD_TRANSPOSE_ENABLED      = malloc(1);
KEYBOARD_TRANSPOSE_8VA          = malloc(1);
KEYBOARD_TRANSPOSE_SEMI_TONES   = malloc(1);

HIGHRES_INPUT_ENABLED           = malloc(1); // Global option              
DROP_UNROUTED_CC_MESSAGES       = malloc(1); // Global option

/////////////////////////////////
// Buffers, used for computation
/////////////////////////////////

// Cosinus and sinus tables for all possible eleven angles
KNOB_TICS_X               = malloc(11); // This is not spinal tap... 0..10 == 11 tics!
KNOB_TICS_Y               = malloc(11); 

BUTTON_GRID_PRESENCE      = malloc(BUTTON_GRID_SIZE * BUTTON_GRID_SIZE);  
BUTTON_DATA               = malloc(32 * BUTTON_GRID_SIZE * BUTTON_GRID_SIZE);

// Curve smoothing buffer
SCURVE                    = malloc(CURVESIZE);

// Control states memorization
CONTROL_LAST_IN           = malloc(CONTROL_COUNT);
CONTROL_LAST_OUT          = malloc(CONTROL_COUNT);

OCTAVE_BLACK_KEY_LOOKUP   = malloc(12);
OCTAVE_TOP_KEY_WIDTHS     = malloc(12);
OCTAVE_TOP_KEY_OFFSETS    = malloc(12);
OCTAVE_LOOKUP_BOTTOM      = malloc(7);

KEY_VELOCITIES            = malloc(88);
CC_RECEIVED_VALUES        = malloc(128); 

GUI_MODE                  = malloc(1);

CURRENT_THEME_NUM         = malloc(1);

// Added 3.3
CONTROL_CHAN_SRCS           = malloc(CONTROL_COUNT);
CONTROL_CHAN_DSTS           = malloc(CONTROL_COUNT);
KB_INPUT_CHANNEL            = malloc(1);
KBG_OUTPUT_CHANNEL          = malloc(1); // Green keys
KBR_OUTPUT_CHANNEL          = malloc(1); // Red keys
KEYBOARD_TRANSPOSE_APPLY_TO = malloc(1);
KEYBOARD_VELOCITY_APPLY_TO  = malloc(1);
CONTROL_MAXS_MSB            = malloc(CONTROL_COUNT);         
CONTROL_MAXS_LSB            = malloc(CONTROL_COUNT);
CONTROL_MINS_MSB            = malloc(CONTROL_COUNT);
CONTROL_MINS_LSB            = malloc(CONTROL_COUNT);
DROP_UNROUTED_NOTE_MESSAGES = malloc(1);

/////////////////////////
//    MEMORY ACCESS    //
/////////////////////////

function curveAddress(cnum)
(
  (cnum <0 || cnum >= CONTROL_COUNT)?(-1):(
    CURVES + (cnum * CURVESIZE)
  );
);

function shouldDropUnroutedCCMessages() (
  (DROP_UNROUTED_CC_MESSAGES[0] == 1);
);

function shouldDropUnroutedNoteMessages() (
  (DROP_UNROUTED_NOTE_MESSAGES[0] == 1);
);

function isKeyboardFilteringEnabled() (
  (KEYBOARD_FILTERING_ENABLED[0] == 1);
);

function isKeyboardTranspositionEnabled() (
  (KEYBOARD_TRANSPOSE_ENABLED[0] == 1);
);

function isRedKey(k) (
  (KEYBOARD_FILTERED_NOTES[k]==1)
);


/////////////////////////
//        MATH         //
/////////////////////////

function roundi(valf) (
  floor(valf+0.5) | 0;
);

// Applies a curve, returns a value from 0 to 1.

// Internally, the curve values are 128 floating values, between 0 and 127, 
// but this is historical (before midi high-res implementation).
// And ideally, they should have been between 0 and 1,
// Because what we want is a curve from [0..1] to [0..1].
// We thus need to pass a reference for normalization
// Telling what is the maximum value allowed for the reference space.
// For example, low-res midi values are going from 0 to 127, so the max is 127.
// But for high-res midi, values are going from 0 to 127.999 so the max is 128 ! Argh !

function applyCurve(blk_control, x01) 
  local(attached_curve, x01, sample_num_f, sample_num_il, sample_num_ir, sample_l, sample_r, curve_interp, alpha)
(
  attached_curve = curveAddress(blk_control);
  
  // Do some clamping cleanup first
  x01 = min(max(x01,0),1);
  
  // Normalize reference space > Curve space
  sample_num_f  = 127 * x01;
  sample_num_il = floor(sample_num_f);
  sample_num_ir = ceil(sample_num_f);
  
  // Get left sample, right sample, and linear interpolation factor
  sample_l      = attached_curve[sample_num_il];
  sample_r      = attached_curve[sample_num_ir];
  alpha         = sample_num_f - sample_num_il;
  
  // Lerp : this will return a value between 0 and 127
  curve_interp  = (1-alpha) * sample_l + alpha * sample_r;

  // Return a value between 0 and 1.
  (curve_interp/127.0);
);

// Calculate pre-defined curves
function buttonEquate(row,col,x01) local(ret)
(
  ret = 0;
  (row == BUTTON_ROW_LINEAR) ? (
    (col == 0)? (
      ret = x01;  
    );
    (col == 1)? (
      ret = 1-x01;
    );
  );
  
  (row == BUTTON_ROW_CIRC) ? (
    (col == 0)? (
      ret = 1-sqrt(1-pow(x01,2));
    ); 
    (col == 1)? (
      ret = 1-sqrt(1-pow(1-x01,2));
    );
    (col == 2)? (
      ret = sqrt(1-pow(1-x01,2));
    );
    (col == 3)? (
      ret = sqrt(1-pow(x01,2));
    );   
  );
  
  
  (row == BUTTON_ROW_POW2) ? (
    (col == 0)? (
      ret = pow(x01,2);
    );
    (col == 1)? (
      ret = pow(1-x01,2);
    );
    (col == 2)? (
      ret = pow(x01,0.5);
    );
    (col == 3)? (
    ret   = pow(1-x01,0.5);
    );
  );
  
  (row == BUTTON_ROW_POW3) ? (
    (col == 0)? (
      ret = pow(x01,3);
    );
    (col == 1)? (
      ret = pow(1-x01,3);
    );
    (col == 2)? (
      ret = pow(x01,1/3);
    ); 
    (col == 3)? (
      ret = pow(1-x01,1/3);
    );  
  ); 
   
  (row == BUTTON_ROW_STEP) ? (
    (col == 0)? (
      // Smooth step
      ret = 3*pow(x01,2) - 2*pow(x01,3);
    );
    (col == 1)? (
      // Smooth step
      ret = 1-(3*pow(x01,2) - 2*pow(x01,3));
    );
    (col == 2)? (
      // Smoother step
      ret = 6*pow(x01,5) - 15*pow(x01,4) + 10*pow(x01,3);
    ); 
    (col == 3)? (
      // Smoother step
      ret = 1-(6*pow(x01,5) - 15*pow(x01,4) + 10*pow(x01,3));
    ); 
    (col == 4)? (
      // Discrete step
      ret = (x01<=0.5)?(0):(1);
    );
    (col == 5)? (
      // Discrete step
      ret = (x01<=0.5)?(1):(0);
    );
  );
  
  (row == BUTTON_ROW_GATE) ? (
    (col == 0)? (
      // Smoother gatep
      x01 = (x01 <= 0.5)?(2*x01):(2-2*x01);
      ret = (6*pow(x01,5) - 15*pow(x01,4) + 10*pow(x01,3));
    );
    (col == 1)? (
      // Smoother gatep
      x01 = (x01 <= 0.5)?(2*x01):(2-2*x01);
      ret = 1-(6*pow(x01,5) - 15*pow(x01,4) + 10*pow(x01,3));    
    );
    (col == 2)? (
      // Triangle
      x01 = (x01 <= 0.5)?(2*x01):(2-2*x01);
      ret = x01;
    );
    (col == 3)? (
      // Triangle
      x01 = (x01 <= 0.5)?(2*x01):(2-2*x01);
      ret = 1-x01;
    );
    (col == 4)? (
      // Square
      x01 = (x01 <= 0.25 || x01 > 0.75)?(0):(1);
      ret = x01;
    );
    (col == 5)? (
      // Square
      x01 = (x01 <= 0.25 || x01 > 0.75)?(0):(1);
      ret = 1-x01;
    );
  );
  
  ret;
);

//////////////////////
//       MIDI       //
//////////////////////

g_hres_h = 0;
g_hres_l = 0;

// Converts a floating value of a CC **between 0 and 1**
// To high/low parts of a 14-bit hres
// For CC #0 to #31 (with respective #32 to #63).
function midiCCHresF012I(f01) 
  local(ival) 
(  
  // Clamp to 0..1 for safety
  f01  = max(min(f01,1),0);
  
  // Convert to 14-bit space
  ival = roundi(f01 * 16383);
  
  // Floor to int for the high part
  g_hres_h  = (ival >> 7);
  g_hres_l  = ival & 0x7F;
);

// Inverse of midiCCHresF012I
function midiCCHresI2F01(high,low)
  local(val01, high, low, ival)
(
  
  // Sanitize
  high = max(min(high,127),0);
  low  = max(min(low,127),0);
  
  // 14-bit value
  ival = (high << 7) + low;
  
  // Put it in 0-1 space
  val01 = ival/16383;
);

// Converts a floating value of a key velocity **between 0 and 1**
// To high/low parts of a 14-bit hres
//
// Specification for this
// https://forum.cockos.com/showthread.php?t=83782
function midiVelocityHresF012I(f01) 
  local(ival) 
(
  
  // Clamp to 0..1 for safety
  f01  = max(min(f01,1),0);

  // Convert to 14-bit space
  // Caution : only 16256+1 values are possible (127*128 non zero values + the zero case)
  // (All LSB values for MSB=0 NOTE OFF are not allowed)
  ival = roundi(f01 * 16256);
  
  (ival==0)?(
    g_hres_h = 0;
    g_hres_l = 0;
  ):(
    // ival is in [1..16256] so put it in [0..16255]
    ival -= 1; 
    // Floor to int for the high part
    // Add 1 for NOTE_ON
    g_hres_h  = (ival >> 7)+1;
    g_hres_l  = ival & 0x7F;
  )
);

// Inverse of midiVelocityHresF012I
function midiVelocityHresI2F01(high,low) 
  local(val01, ival) 
(

  // Sanitize
  high = max(min(high,127),0);
  low  = max(min(low,127),0);
    
  high==0?(
    // If high is equal to 0
    // Low = 0 is not allowed for NOTE OFF compatibility
    // So just return 0, it's a NOTE OFF, period.
    0;
  ):(
  
    // This said, we can start at 0.
    high = high-1;
    
    // 14-bit value
    ival = (high << 7) + low;
    
    // Avoid the zero case, ival is between [0..16255] so put all between [1..16256]
    ival += 1;
    
    // Put it in 0-1 space
    // Only 16256+1 values are available since we rejected all LSB values for MSB=0
    val01 = ival/16256;
    val01 = max(min(val01,1),0);
  );
);

// Octave number for a floating x axis of white keys
function octaveForBottomPos(keyboard_floating_pos) (
  floor(keyboard_floating_pos/7);
);

// Octave note for a floating x axis of white keys
// For the bottom row of the keyboard (only white keys here)
function octaveNoteForBottomPos(keyboard_bottom_floating_pos) (
  OCTAVE_LOOKUP_BOTTOM[floor(keyboard_bottom_floating_pos) % 7];
);

// Is key black? (keys are numbered from 0 to 87)
function keyIsBlack(key_num) (
  OCTAVE_BLACK_KEY_LOOKUP[key_num % 12] == 1;
);

// Key octave
function octaveForKey(key_num) (
  floor(key_num / 12);
);

// Key for midi note
function midiNoteToKey(midi_note) (
  midi_note - 21; // A0
);

// Midi note to key
function keyToMidiNote(key) (
  key + 21; // A0
);


// For a #CC, returns LSB counterpart or -1 if it hasn't.
function ccLsbCounterpart(ccnum) local(ret) (
  ret = -1;
  
  (ccnum>=0 && ccnum < 32)?(
    ret = ccnum + 32;
  );
  
  ret;
);

// For a #CC, returns MSB counterpart or -1 if it hasn't.
function ccMsbCounterpart(ccnum) local(ret) (
  ret = -1;
  
  (ccnum>=32 && ccnum < 64)?(
    ret = ccnum - 32;
  );
  
  ret;
);

function isALsbCC(ccnum) (
  // 88 is the LSB Channel for velocity.
  (ccMsbCounterpart(ccnum) != -1 || ccnum == 88);
);

function isAMsbCC(ccnum) (
  // 88 is the LSB Channel for velocity.
  (ccLsbCounterpart(ccnum) != -1);
);

// High res midi input? (it's a global param)
function isHighResMidiInputEnabled()
(
  HIGHRES_INPUT_ENABLED[0];
);

// High res output? (it's a local param)
function isHighResMidiOutputEnabledForControl(control) 
(
  CONTROL_HIGHRES_OUTPUT_ENABLED[control];
);

function controlHasOperationalHighResOutput(control)
  local(hr_is_legit_for_control, hr_is_enabled)
(
  hr_is_legit_for_control = (control == CONTROL_VELOCITY || ccLsbCounterpart(CONTROL_DSTS[control])!=-1);
  hr_is_enabled           = isHighResMidiOutputEnabledForControl(control);
  
  (hr_is_legit_for_control && hr_is_enabled);
);

function controlCurrentBound01(control,is_min)
  local(lsb,msb)
(
  msb = (is_min)?(CONTROL_MINS_MSB[control]):(CONTROL_MAXS_MSB[control]);
 
  (controlHasOperationalHighResOutput(control))?(
    lsb = (is_min)?(CONTROL_MINS_LSB[control]):(CONTROL_MAXS_LSB[control]);
    
    (control == CONTROL_VELOCITY)?(
      midiVelocityHresI2F01(msb,lsb);
    ):(
      midiCCHresI2F01(msb,lsb);
    );
  ):(
    msb/127.0;
  );
);

function controlCurrentMinBound01(control)
(
  controlCurrentBound01(control,1);
);

function controlCurrentMaxBound01(control)
(
  controlCurrentBound01(control,0);
);


// Is the CC learnable? (in high res, we don't allow LSB controls to be learnable)
function isCCLearnable(ccnum) (
  (!isHighResMidiInputEnabled())?(1):(!isALsbCC(ccnum););
);

function enableCCLearn()
(
  g_cc_learn = 1;
);

function disableCCLearn()
(
  g_cc_learn = 0;
);

function isCCLearning() 
(
  (g_cc_learn == 1);
);


/////////////////////
//  INIT FUNCTIONS //
/////////////////////

function knobTic(val, x_or_y) local(ret, v1, v2)
(
  // Clamp val between 0 and 1
  val = min(val,0.99999);
  val = max(0,val);
  
  val = 10*val;
  
  v1 = floor(val) | 0; // intify, v1 between 0 and 9
  v2 = (v1 + 1) | 0;
  
  (x_or_y == 1)?
  ( 
    ret = KNOB_TICS_X[v1] + (val-v1)*(KNOB_TICS_X[v2]-KNOB_TICS_X[v1]);
  ):
  (
    ret = KNOB_TICS_Y[v1] + (val-v1)*(KNOB_TICS_Y[v2]-KNOB_TICS_Y[v1]); 
  );
);

function initKnobTics() local(t, angle)
(
  t = 0;
  while(t<11)
  (
    angle = 90 + 30 + t*(36-6);
    angle *= $pi / 180;
    KNOB_TICS_X[t] = cos(angle);
    KNOB_TICS_Y[t] = sin(angle);
    t += 1;
  );
);

function initMidiControlNames()
(
  strcpy(0,"Bank Select");
  strcpy(1,"Modulation Wheel");
  strcpy(2,"Breath");
  strcpy(3,"CC 3");
  strcpy(4,"Foot Controller");
  strcpy(5,"Portamento Time");
  strcpy(6,"Data Entry");
  strcpy(7,"Volume");
  strcpy(8,"Balance");
  strcpy(9,"CC 9");
  strcpy(10,"Pan");
  strcpy(11,"Expression");
  strcpy(12,"Effect Controller 1");
  strcpy(13,"Effect Controller 2");
  strcpy(14,"CC 14");
  strcpy(15,"CC 15");
  strcpy(16,"General Purpose Slider 1");
  strcpy(17,"General Purpose Slider 2");
  strcpy(18,"General Purpose Slider 3");
  strcpy(19,"General Purpose Slider 4");
  strcpy(20,"CC 20");
  strcpy(21,"CC 21");
  strcpy(22,"CC 22");
  strcpy(23,"CC 23");
  strcpy(24,"CC 24");
  strcpy(25,"CC 25");
  strcpy(26,"CC 26");
  strcpy(27,"CC 27");
  strcpy(28,"CC 28");
  strcpy(29,"CC 29");
  strcpy(30,"CC 30");
  strcpy(31,"CC 31");
  
  strcpy(32+0,"Bank Select");
  strcpy(32+1,"Modulation Wheel");
  strcpy(32+2,"Breath");
  strcpy(32+3,"CC 3");
  strcpy(32+4,"Foot Controller");
  strcpy(32+5,"Portamento Time");
  strcpy(32+6,"Data Entry");
  strcpy(32+7,"Volume");
  strcpy(32+8,"Balance");
  strcpy(32+9,"CC 14");
  strcpy(32+10,"Pan");
  strcpy(32+11,"Expression");
  strcpy(32+12,"Effect Controller 1");
  strcpy(32+13,"Effect Controller 2");
  strcpy(32+14,"CC 14");
  strcpy(32+15,"CC 15");
  strcpy(32+16,"General Purpose Slider 1");
  strcpy(32+17,"General Purpose Slider 2");
  strcpy(32+18,"General Purpose Slider 3");
  strcpy(32+19,"General Purpose Slider 4");
  strcpy(32+20,"CC 20");
  strcpy(32+21,"CC 21");
  strcpy(32+22,"CC 22");
  strcpy(32+23,"CC 23");
  strcpy(32+24,"CC 24");
  strcpy(32+25,"CC 25");
  strcpy(32+26,"CC 26");
  strcpy(32+27,"CC 27");
  strcpy(32+28,"CC 28");
  strcpy(32+29,"CC 29");
  strcpy(32+30,"CC 30");
  strcpy(32+31,"CC 31");

  strcpy(64,"Damper/Sustain Pedal (Hold1) On/Off");
  strcpy(65,"Portamento On/Off");
  strcpy(66,"Sostenuto On/Off");
  strcpy(67,"Soft Pedal On/Off");
  strcpy(68,"Legato Pedal On/Off");
  strcpy(69,"Damper/Sustain Pedal (Hold2) On/Off");
  strcpy(70,"Sound Variation");
  strcpy(71,"Sound Timbre/Resonance/Harmonics");
  strcpy(72,"Release");
  strcpy(73,"Attack");
  strcpy(74,"Cutoff/Brightness");
  strcpy(75,"Sound Controller 6");
  strcpy(76,"Sound Controller 7");
  strcpy(77,"Sound Controller 8");
  strcpy(78,"Sound Controller 9");
  strcpy(79,"Sound Controller 10");
  strcpy(80,"General Purpose On/Off 1");
  strcpy(81,"General Purpose On/Off 2");
  strcpy(82,"General Purpose On/Off 3");
  strcpy(83,"General Purpose On/Off 4");
  strcpy(83,"General Purpose On/Off 4");
  strcpy(84,"Portamento Amount");
  
  strcpy(88,"Keyboard velocity");
  
  strcpy(91,"Effect 1 Level (Reverb)");
  strcpy(92,"Effect 2 Level (Tremolo)");
  strcpy(93,"Effect 3 Level (Chorus)");
  strcpy(94,"Effect 4 Level (Detune/Celeste)");
  strcpy(95,"Effect 5 Level (Phaser)");
  strcpy(96,"NRPN/RPN Data +1");
  strcpy(97,"NRPN/RPN Data +1");
  strcpy(98,"NRPN LSB");
  strcpy(99,"NRPN MSB");
  strcpy(100,"RPN LSB");
  strcpy(101,"RPN MSB");
);

function initPluginControlNames()
(
  strcpy(128+CONTROL_WHEELS_START+0,"Modulation Wheel");
  
  strcpy(128+CONTROL_PEDALS_START+0,"Pedal Sustain");
  strcpy(128+CONTROL_PEDALS_START+1,"Pedal 2");
  strcpy(128+CONTROL_PEDALS_START+2,"Pedal 3");
  strcpy(128+CONTROL_PEDALS_START+3,"Pedal 4");
  
  strcpy(128+CONTROL_FADERS_START+0,"Fader 1");
  strcpy(128+CONTROL_FADERS_START+1,"Fader 2");
  strcpy(128+CONTROL_FADERS_START+2,"Fader 3");
  strcpy(128+CONTROL_FADERS_START+3,"Fader 4");
  strcpy(128+CONTROL_FADERS_START+4,"Fader 5");
  strcpy(128+CONTROL_FADERS_START+5,"Fader 6");
  strcpy(128+CONTROL_FADERS_START+6,"Fader 7");
  strcpy(128+CONTROL_FADERS_START+7,"Fader 8");
  strcpy(128+CONTROL_FADERS_START+8,"Fader 9");
  strcpy(128+CONTROL_FADERS_START+9,"Fader 10");
  
  strcpy(128+CONTROL_KNOBS_START+0,"Knob 1");
  strcpy(128+CONTROL_KNOBS_START+1,"Knob 2");
  strcpy(128+CONTROL_KNOBS_START+2,"Knob 3");
  strcpy(128+CONTROL_KNOBS_START+3,"Knob 4");
  strcpy(128+CONTROL_KNOBS_START+4,"Knob 5");
  strcpy(128+CONTROL_KNOBS_START+5,"Knob 6");
  strcpy(128+CONTROL_KNOBS_START+6,"Knob 7");
  strcpy(128+CONTROL_KNOBS_START+7,"Knob 8");
  strcpy(128+CONTROL_KNOBS_START+8,"Knob 9");
  strcpy(128+CONTROL_KNOBS_START+9,"Knob 10");
  
  strcpy(128+CONTROL_PADS_START+0,"Pad 1");
  strcpy(128+CONTROL_PADS_START+1,"Pad 2");
  strcpy(128+CONTROL_PADS_START+2,"Pad 3");
  strcpy(128+CONTROL_PADS_START+3,"Pad 4");
  strcpy(128+CONTROL_PADS_START+4,"Pad 5");
  strcpy(128+CONTROL_PADS_START+5,"Pad 6");
  strcpy(128+CONTROL_PADS_START+6,"Pad 7");
  strcpy(128+CONTROL_PADS_START+7,"Pad 8");
  strcpy(128+CONTROL_PADS_START+8,"Pad 9");
  strcpy(128+CONTROL_PADS_START+9,"Pad 10");
  
  strcpy(128+CONTROL_VELOCITY_START+0,"Keyboard velocity");
);

function initOctaveLookups() (
  
  OCTAVE_LOOKUP_BOTTOM[0] = 0; // A
  OCTAVE_LOOKUP_BOTTOM[1] = 2; // B
  OCTAVE_LOOKUP_BOTTOM[2] = 3; // C
  OCTAVE_LOOKUP_BOTTOM[3] = 5; // D
  OCTAVE_LOOKUP_BOTTOM[4] = 7; // E
  OCTAVE_LOOKUP_BOTTOM[5] = 8; // F
  OCTAVE_LOOKUP_BOTTOM[6] = 10; // G
  
  // Starts at A (not C)
  OCTAVE_BLACK_KEY_LOOKUP[0]  = 0; // A
  OCTAVE_BLACK_KEY_LOOKUP[1]  = 1; // A#/Bb
  OCTAVE_BLACK_KEY_LOOKUP[2]  = 0; // B
  OCTAVE_BLACK_KEY_LOOKUP[3]  = 0; // C
  OCTAVE_BLACK_KEY_LOOKUP[4]  = 1; // C#/Db
  OCTAVE_BLACK_KEY_LOOKUP[5]  = 0; // D
  OCTAVE_BLACK_KEY_LOOKUP[6]  = 1; // D#/Eb
  OCTAVE_BLACK_KEY_LOOKUP[7]  = 0; // E
  OCTAVE_BLACK_KEY_LOOKUP[8]  = 0; // F
  OCTAVE_BLACK_KEY_LOOKUP[9]  = 1; // F#/Gb
  OCTAVE_BLACK_KEY_LOOKUP[10] = 0; // G
  OCTAVE_BLACK_KEY_LOOKUP[11] = 1; // G#/Ab     
  
  OCTAVE_TOP_KEY_WIDTHS[0]  = 0;   // A
  OCTAVE_TOP_KEY_WIDTHS[1]  = 1;   // A#/Bb
  OCTAVE_TOP_KEY_WIDTHS[2]  = 0.5; // B
  OCTAVE_TOP_KEY_WIDTHS[3]  = 0.5; // C
  OCTAVE_TOP_KEY_WIDTHS[4]  = 1;   // C#/Db
  OCTAVE_TOP_KEY_WIDTHS[5]  = 0;   // D
  OCTAVE_TOP_KEY_WIDTHS[6]  = 1;   // D#/Eb
  OCTAVE_TOP_KEY_WIDTHS[7]  = 0.5; // E
  OCTAVE_TOP_KEY_WIDTHS[8]  = 0.5; // F
  OCTAVE_TOP_KEY_WIDTHS[9]  = 1;   // F#/Gb
  OCTAVE_TOP_KEY_WIDTHS[10] = 0;   // G
  OCTAVE_TOP_KEY_WIDTHS[11] = 1;   // G#/Ab  
  
  OCTAVE_TOP_KEY_OFFSETS[0]  = 0.5; // A
  OCTAVE_TOP_KEY_OFFSETS[1]  = 0.5; // A#/Bb
  OCTAVE_TOP_KEY_OFFSETS[2]  = 1.5; // B
  OCTAVE_TOP_KEY_OFFSETS[3]  = 2;   // C
  OCTAVE_TOP_KEY_OFFSETS[4]  = 2.5; // C#/Db
  OCTAVE_TOP_KEY_OFFSETS[5]  = 3.5; // D
  OCTAVE_TOP_KEY_OFFSETS[6]  = 3.5; // D#/Eb
  OCTAVE_TOP_KEY_OFFSETS[7]  = 4.5; // E
  OCTAVE_TOP_KEY_OFFSETS[8]  = 5;   // F
  OCTAVE_TOP_KEY_OFFSETS[9]  = 5.5; // F#/Gb
  OCTAVE_TOP_KEY_OFFSETS[10] = 6.5; // G
  OCTAVE_TOP_KEY_OFFSETS[11] = 6.5; // G#/Ab 
);

function switchToDarkTheme() (

  TH.LIGHTGREEN = 0x80E580;
  TH.MIDGREEN   = 0x20A020;
  TH.LOWGREEN   = 0x10A010;
  
  TH.BACKGROUND          = 0x000000;
  TH.DEFAULT_FONT        = 0xCCCCCC; // Default font color
  
  TH.HEADER              = 0x202066;
  TH.HEADER_TEXT         = TH.DEFAULT_FONT;

  // Enable/Disable button colors (Green/Grey)
  TH.EN_B_ON             = TH.MIDGREEN; // Toggle button on
  TH.EN_B_ON_H           = TH.LIGHTGREEN; // Toggle button on+hover
  TH.EN_B_ON_TEXT        = 0xFFFFFF;
  TH.EN_B_OFF            = 0x303030; // Toggle button off
  TH.EN_B_OFF_H          = 0x606060; // Toggle button off+hover
  TH.EN_B_OFF_TEXT       = TH.DEFAULT_FONT;
  
  // Switch button (Bistate button, but does not change color)
  // Used for changing tabs for example
  TH.SW_B_ON             = 0x202020; 
  TH.SW_B_ON_H           = 0x505050; 
  TH.SW_B_ON_TEXT        = TH.DEFAULT_FONT;
  TH.SW_B_OFF            = 0x202020;
  TH.SW_B_OFF_H          = 0x505050;
  TH.SW_B_OFF_TEXT       = TH.DEFAULT_FONT;
  
  // Mono state button (cannot be toggled)
  TH.MONO_B              = 0x202020; 
  TH.MONO_B_H            = 0x505050;
  TH.MONO_B_TEXT         = 0xAAAAFF; 
  TH.MONO_B_CURVE        = 0xFF5050;
  
  TH.CC_LEARN_ON         = 0x666600;
  TH.CC_LEARN_ON_H       = 0x888800;
  TH.CC_LEARN_ON_TEXT    = 0xFFFF00;
  
  // Dynamic labels (Control information display)
  TH.DYN_LABEL           = 0x8080FF;
  TH.DYN_LABEL_HIGHLIGHT = 0xFFFFFF;
  TH.DYN_LABEL_NEUTRAL   = 0x808080;
  TH.DYN_LABEL_DISABLED  = 0x505050;
  
  // Curve
  TH.CURVE               = 0x6060FF;
  TH.CURVE_BG            = 0x191919;
  TH.CURVE_BG_EXCL       = 0x090909;
  TH.CURVE_GRID          = 0x353535;
  TH.CURVE_BORDER        = 0x474747;
  TH.CURVE_CURRENT_VALUE = 0xFF4040;
  
  // Controls
  TH.CONTROL_HIGHLIGHT              = 0x7070F0;
  TH.CONTROL_HIGHLIGHT_H            = 0xA0A000;
  
  TH.CONTROL_ENABLED_CONTRAST_HIGH  = 0xF0F0F0;
  TH.CONTROL_ENABLED_CONTRAST_MID   = 0xB0B0B0;
  TH.CONTROL_ENABLED_CONTRAST_LOW   = 0x6C6C6C;
  
  TH.CONTROL_DISABLED_CONTRAST_HIGH = 0x505050;
  TH.CONTROL_DISABLED_CONTRAST_MID  = 0x454545;
  TH.CONTROL_DISABLED_CONTRAST_LOW  = 0x202020;
  
  // Edit input lines
  TH.INPUTLINE_BG        = TH.MONO_B;
  TH.INPUTLINE_BG_H      = TH.MONO_B_H;
  TH.INPUTLINE_TEXT      = TH.MONO_B_TEXT;
  
  TH.INPUTLINE_EDIT_BG   = TH.CC_LEARN_ON;
  TH.INPUTLINE_EDIT_BG_H = TH.CC_LEARN_ON_H;
  TH.INPUTLINE_EDIT_TEXT = TH.CC_LEARN_ON_TEXT;
  
  // Src/Dst labels
  TH.ROUTING_INFO_CCNAME = TH.DYN_LABEL;
  TH.ROUTING_INFO_NOT_OK = 0xFF5533;
  TH.ROUTING_INFO_OK     = 0x00FF00;
  
  // Keyboard
  TH.KEY_MARKER_BORDER  = 0x000000;
  TH.KEY_MARKER_BG      = 0xFFFFFF; 
  TH.KEY_BLACK_DISABLED = 0x306030;
  TH.KEY_WHITE_DISABLED = 0x608060;
  
  TH.KEY_WHITE_FILTERED_IN  = TH.LIGHTGREEN;
  TH.KEY_BLACK_FILTERED_IN  = TH.MIDGREEN;
  TH.KEY_BLACK_FILTERED_OUT = 0xB24C4C;
  TH.KEY_WHITE_FILTERED_OUT = 0xE58080;
);

function switchToLightTheme() (

  TH.LIGHTGREEN = 0x50D050;
  TH.MIDGREEN   = 0x20A020;
  TH.LOWGREEN   = 0x10A010;
  
  TH.BACKGROUND          = 0xE0E0E0;
  TH.DEFAULT_FONT        = 0x101010; // Default font color
  
  TH.HEADER              = 0xC0C0C0;
  TH.HEADER_TEXT         = TH.DEFAULT_FONT;

  // Enable/Disable button colors (Green/Grey)
  TH.EN_B_ON             = TH.MIDGREEN; // Toggle button on
  TH.EN_B_ON_H           = TH.LIGHTGREEN; // Toggle button on+hover
  TH.EN_B_ON_TEXT        = 0xFFFFFF;
  TH.EN_B_OFF            = 0xA0A0A0; // Toggle button off
  TH.EN_B_OFF_H          = 0xD0D0D0; // Toggle button off+hover
  TH.EN_B_OFF_TEXT       = TH.DEFAULT_FONT;
  
  // Switch button (Bistate button, but does not change color)
  // Used for changing tabs for example
  TH.SW_B_ON             = 0xA0A0A0; 
  TH.SW_B_ON_H           = 0xD0D0D0; 
  TH.SW_B_ON_TEXT        = TH.DEFAULT_FONT;
  TH.SW_B_OFF            = 0xA0A0A0;
  TH.SW_B_OFF_H          = 0xD0D0D0;
  TH.SW_B_OFF_TEXT       = TH.DEFAULT_FONT;
  
  // Mono state button (cannot be toggled)
  TH.MONO_B              = 0xA0A0A0; 
  TH.MONO_B_H            = 0xD0D0D0;
  TH.MONO_B_TEXT         = 0xFFFFFF; 
  TH.MONO_B_CURVE        = 0xFF5050;
  
  TH.CC_LEARN_ON         = 0x666600;
  TH.CC_LEARN_ON_H       = 0x888800;
  TH.CC_LEARN_ON_TEXT    = 0xFFFF00;
  
  // Dynamic labels (Control information display)
  TH.DYN_LABEL           = 0x6060FF;
  TH.DYN_LABEL_HIGHLIGHT = 0x000000;
  TH.DYN_LABEL_NEUTRAL   = 0x808080;
  TH.DYN_LABEL_DISABLED  = 0x505050;
  
  // Curve
  TH.CURVE               = 0x6060FF;
  TH.CURVE_BG            = 0x393939;
  TH.CURVE_BG_EXCL       = 0x292929;
  TH.CURVE_GRID          = 0x555555;
  TH.CURVE_BORDER        = 0x676767;
  TH.CURVE_CURRENT_VALUE = 0xFF4040;
  
  // Controls
  TH.CONTROL_HIGHLIGHT              = 0xC7C7FF;
  TH.CONTROL_HIGHLIGHT_H            = 0xA0A000;
  
  TH.CONTROL_ENABLED_CONTRAST_HIGH  = 0xA0A0A0;//0xF0F0F0;
  TH.CONTROL_ENABLED_CONTRAST_MID   = 0x707070;//0x909090;
  TH.CONTROL_ENABLED_CONTRAST_LOW   = 0x606060;//0x4C4C4C;
  
  TH.CONTROL_DISABLED_CONTRAST_HIGH = 0xD3D3D3;
  TH.CONTROL_DISABLED_CONTRAST_MID  = 0xD3D3D3;
  TH.CONTROL_DISABLED_CONTRAST_LOW  = 0xC7C7C7;
  
  
  // Edit input lines
  TH.INPUTLINE_BG        = TH.MONO_B;
  TH.INPUTLINE_BG_H      = TH.MONO_B_H;
  TH.INPUTLINE_TEXT      = TH.MONO_B_TEXT;
  
  TH.INPUTLINE_EDIT_BG   = TH.CC_LEARN_ON;
  TH.INPUTLINE_EDIT_BG_H = TH.CC_LEARN_ON_H;
  TH.INPUTLINE_EDIT_TEXT = TH.CC_LEARN_ON_TEXT;
  
  // Src/Dst labels
  TH.ROUTING_INFO_CCNAME = TH.DYN_LABEL;
  TH.ROUTING_INFO_NOT_OK = 0xFF0000;
  TH.ROUTING_INFO_OK     = 0x008F00;
  
  // Keyboard
  TH.KEY_MARKER_BORDER  = 0x000000;
  TH.KEY_MARKER_BG      = 0xFFFFFF; 
  TH.KEY_BLACK_DISABLED = 0x70A070;
  TH.KEY_WHITE_DISABLED = 0x90C090;
  
  TH.KEY_WHITE_FILTERED_IN  = TH.LIGHTGREEN;
  TH.KEY_BLACK_FILTERED_IN  = TH.MIDGREEN;
  TH.KEY_BLACK_FILTERED_OUT = 0xB24C4C;
  TH.KEY_WHITE_FILTERED_OUT = 0xE58080;
);

function switchToTheme(theme_num) (
  (theme_num == DARK_THEME)?(switchToDarkTheme()):(switchToLightTheme());
);

function updateTheme() (
  switchToTheme(CURRENT_THEME_NUM[0]);
);

function initThemes() (
  CURRENT_THEME_NUM[0] = DARK_THEME;
  updateTheme();
);

////////////////////////
//     UI HELPERS     //
////////////////////////

function hasButtonInGrid(row,col)
(
  BUTTON_GRID_PRESENCE[row*BUTTON_GRID_SIZE + col];
);

function buttonDataAddress(row,col)
(
  BUTTON_DATA + (BUTTON_GRID_SIZE*row+col)*32;
);

function midiControlName(midi_cnum)
(
  midi_cnum;
);
function controlName(cnum)
(
  128+cnum;
);
function controlDescription(cnum)
(
  128+CONTROL_COUNT+cnum;
);
function controlLabel(cnum)
(
  128+CONTROL_COUNT+CONTROL_COUNT+cnum;
);
function controlLabelWithFallback(cnum) local(str)
(
  str = controlLabel(cnum);
  (strlen(str)==0)?(str="?");
  str;
);

function selectedControlCurveAddress()
(
  curveAddress(g_selected_control);
);

function initButton(row,col) 
  local(points, i)
(
  BUTTON_GRID_PRESENCE[row*BUTTON_GRID_SIZE + col] = 1;
  points = buttonDataAddress(row,col);
  
  i = 0;
  while(i<32) ( points[i] = buttonEquate(row,col,i/31); i+=1);
);



///////////////////////////////
//     MAIN INIT FUNCTIONS   //
///////////////////////////////

function firstInit() 
  local(c, curve, i)
( 
  // Init midi control names
  initMidiControlNames();
  initPluginControlNames();

  // Init theme colors
  initThemes();
  
  // Init knob tics
  initKnobTics();
  
  // Init octave lookups
  initOctaveLookups();

  // Init curves
  c = 0;
  while(c<CONTROL_COUNT) ( 

    // Init to identity.   
    CONTROL_ENABLED[c] = 1;

    curve = curveAddress(c);
    i = 0; 
    while(i<CURVESIZE) ( 
      curve[i] = i;
      i+=1; 
    ); 
    
    c += 1; 
  );
  
  // Init channel options
  KB_INPUT_CHANNEL[0]     = 0;
  KBR_OUTPUT_CHANNEL[0]   = 0;
  KBR_OUTPUT_CHANNEL[0]   =-1; // DROP
  
  // Init controls
  c = 0; while(c<CONTROL_COUNT) (  
    CONTROL_LAST_IN[c]                  = 0;
    CONTROL_LAST_OUT[c]                 = 0;
    CONTROL_ENABLED[c]                  = 0;    
    CONTROL_SRCS[c]                     = 127; 
    CONTROL_DSTS[c]                     = 127;
    CONTROL_CHAN_SRCS[c]                = 0; // Any
    CONTROL_CHAN_DSTS[c]                = 0; // As src
    CONTROL_HIGHRES_OUTPUT_ENABLED[c]   = 0; 
    CONTROL_MINS_LSB[c] = 0;
    CONTROL_MINS_MSB[c] = 0;
    CONTROL_MAXS_LSB[c] = 127;
    CONTROL_MAXS_MSB[c] = 127;
        
    c+=1 
  );
  
  // Init global params
  KEYBOARD_TRANSPOSE_ENABLED[0]     = 0;
  KEYBOARD_TRANSPOSE_8VA[0]         = 0;
  KEYBOARD_TRANSPOSE_SEMI_TONES[0]  = 0;     
 
  HIGHRES_INPUT_ENABLED[0]          = 0;
  DROP_UNROUTED_CC_MESSAGES[0]      = 0;
  DROP_UNROUTED_NOTE_MESSAGES[0]    = 0;

  // Init mod wheel
  CONTROL_ENABLED[CONTROL_WHEELS_START] = 1;
  CONTROL_SRCS[CONTROL_WHEELS_START]    = 1; // Midi mod wheel
  CONTROL_DSTS[CONTROL_WHEELS_START]    = 1; // Midi mod wheel
  
  // Init sustain pedal
  CONTROL_ENABLED[CONTROL_PEDALS_START] = 1;
  CONTROL_SRCS[CONTROL_PEDALS_START]    = 64; // Midi sustain pedal
  CONTROL_DSTS[CONTROL_PEDALS_START]    = 64; // Midi sustain pedal
  
  // Init button presence grid
  i = 0; while(i<BUTTON_GRID_SIZE*BUTTON_GRID_SIZE) ( BUTTON_GRID_PRESENCE[i] = 0; i+=1 );
   
  // Init buttons
  initButton(BUTTON_ROW_LINEAR,0);
  initButton(BUTTON_ROW_LINEAR,1);
  
  initButton(BUTTON_ROW_POW2,0);
  initButton(BUTTON_ROW_POW2,1); 
  initButton(BUTTON_ROW_POW2,2);
  initButton(BUTTON_ROW_POW2,3);
    
  initButton(BUTTON_ROW_POW3,0);
  initButton(BUTTON_ROW_POW3,1);
  initButton(BUTTON_ROW_POW3,2);
  initButton(BUTTON_ROW_POW3,3);
   
  initButton(BUTTON_ROW_CIRC,0);
  initButton(BUTTON_ROW_CIRC,1);
  initButton(BUTTON_ROW_CIRC,2);
  initButton(BUTTON_ROW_CIRC,3);   
  
  initButton(BUTTON_ROW_STEP,0);
  initButton(BUTTON_ROW_STEP,1);
  initButton(BUTTON_ROW_STEP,2);
  initButton(BUTTON_ROW_STEP,3);
  initButton(BUTTON_ROW_STEP,4);
  initButton(BUTTON_ROW_STEP,5);
  
  initButton(BUTTON_ROW_GATE,0);
  initButton(BUTTON_ROW_GATE,1);
  initButton(BUTTON_ROW_GATE,2);
  initButton(BUTTON_ROW_GATE,3);
  initButton(BUTTON_ROW_GATE,4);
  initButton(BUTTON_ROW_GATE,5);   
  
  GUI_MODE[0] = 1;
  
  // Configure font number 1
  gfx_setfont(1,"Arial",10,'b');           
  gfx_setfont(0);
);

ext_noinit=1;
!hasinit ? (
  firstInit();
  
  last_modified = -1;
  g_selected_control = -1;
);
hasinit=1;

//===========================================//
//==============    SLIDER     ==============//
//===========================================//
@slider

//===========================================//
//==============   SERIALIZE   ==============//
//===========================================//
@serialize

// CURRENT FILE FORMAT
FILE_FORMAT_1_0             = (1<<8)+0; // 1.0 (==256)
CURRENT_FILE_FORMAT_VERSION = FILE_FORMAT_1_0;

function memwr(is_saving, ver) 
  local(ccount,s,avail) 
(
  
  ccount = (is_saving)?(CONTROL_COUNT):(0);
    
  // version and control count bytes introduced in V3.1a
  (ver>0)?(
    // Version number already managed 
    // Now the control count. 
    // Read it if we're reading, or save it if we're writing
    file_var(0,ccount);
    // And the first curve
    file_mem(0,CURVES+0,CURVESIZE);
  ):(
    !is_saving?(
      // In that version there were 35 controls
      ccount = 35;
    );
  
    // Version number was in fact the first sample of the first curve.
    // There are still n-1 samples to read afterwards.
    file_mem(0,CURVES+1,CURVESIZE-1);
  );
  
  // Read/Write other (ccount-1) curves (first one handled separately for bw compatibility)
  file_mem(0,CURVES+CURVESIZE , (ccount-1) * CURVESIZE);
 
  // Flags
  file_mem(0,CONTROL_ENABLED  , ccount);
  
  // Srcs and dests
  file_mem(0,CONTROL_SRCS     , ccount);
  file_mem(0,CONTROL_DSTS     , ccount);
  
  // Descriptions
  s=0;while(s<ccount) 
  ( 
    file_string(0,controlDescription(s)); 
    s+=1;
  );
  
  // Short descriptions
  s=0;while(s<ccount) 
  ( 
    file_string(0,controlLabel(s)); 
    s+=1;
  );
  
  // Introduced in V3 (keyboard filtering)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,KEYBOARD_FILTERING_ENABLED,1);
    file_mem(0,KEYBOARD_FILTERED_NOTES,88);
  );
  
  // Introduced in V3.1a (transpose / high res)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CONTROL_HIGHRES_OUTPUT_ENABLED, ccount);
    file_mem(0,KEYBOARD_TRANSPOSE_ENABLED,1);
    file_mem(0,KEYBOARD_TRANSPOSE_8VA,1);
    file_mem(0,KEYBOARD_TRANSPOSE_SEMI_TONES,1);
    file_mem(0,HIGHRES_INPUT_ENABLED,1);
    file_mem(0,DROP_UNROUTED_CC_MESSAGES,1);
  );
  
  // Introduced in V3.1d (theme selection)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CURRENT_THEME_NUM,1);
  );
  
  // Introduced in V3.3 (channel routing + min/max)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CONTROL_CHAN_SRCS, ccount);
    file_mem(0,CONTROL_CHAN_DSTS, ccount);
    file_mem(0,KB_INPUT_CHANNEL,1);
    file_mem(0,KBG_OUTPUT_CHANNEL,1);
    file_mem(0,KBR_OUTPUT_CHANNEL,1);
    file_mem(0,KEYBOARD_VELOCITY_APPLY_TO,1);
    file_mem(0,KEYBOARD_TRANSPOSE_APPLY_TO,1);
    file_mem(0,CONTROL_MINS_MSB, ccount);
    file_mem(0,CONTROL_MINS_LSB, ccount);
    file_mem(0,CONTROL_MAXS_MSB, ccount);
    file_mem(0,CONTROL_MAXS_LSB, ccount);
    file_mem(0,DROP_UNROUTED_NOTE_MESSAGES,1);
  );
);

function backupOrRestore() local(is_saving, check_ver, old_format) (

  is_saving = (file_avail(0)<0);
  
  (is_saving)?(

    file_var(0, CURRENT_FILE_FORMAT_VERSION);
    memwr(is_saving, CURRENT_FILE_FORMAT_VERSION);
  ):
  (  
    // Reading the file
    // Have to manage the old format ...
    check_ver = 0;
    file_var(0,check_ver);
    
    // Now, we put a version number >= 256.
    // The old format had a curve point on the first slot, so < 256.
    old_format = (check_ver < 256);
    
    (old_format)?( 
      // Repair first curve 
      // The "ver" would not exist and is in fact the first sample of the first curve
      CURVES[0] = check_ver; // Yuuuk!!
      // Force the file format to 0.0
      memwr(is_saving, 0);
    ):( 
      // 1.0 format, 36 controls
      memwr(is_saving, FILE_FORMAT_1_0);
    );
  )
);

backupOrRestore();

//===========================================//
//===============     GFX     ===============//
//===========================================//
@gfx 840 680

//////////////////////////
// GENERIC UI FUNCTIONS //
//////////////////////////

function gfx_rgb(hex_col) (
  gfx_r = ((hex_col>>16)&0xFF)/255; 
  gfx_g = ((hex_col>>8)&0xFF)/255;
  gfx_b = ((hex_col>>0)&0xFF)/255;
);

function gfx_xy(x,y) (
  gfx_x = x;
  gfx_y = y;
);

function gfx_rgb_control_high(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_HIGH):(TH.CONTROL_DISABLED_CONTRAST_HIGH) );
);
function gfx_rgb_control_mid(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_MID):(TH.CONTROL_DISABLED_CONTRAST_MID) );
);
function gfx_rgb_control_low(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_LOW):(TH.CONTROL_DISABLED_CONTRAST_LOW) );
);


function textForComboBox(combo_id, val)
  local(tmp)
(
  ( (combo_id == "chan_dst_spinbox" || combo_id == "chan_out_green_spinbox" || combo_id == "chan_out_red_spinbox") && val == 0) ? (
    "As In";
  ):(
    ( (combo_id == "chan_src_spinbox" || combo_id == "chan_in_keyboard_spinbox") && val == 0) ? (
      "Any";
    ):(
      (combo_id == "chan_out_red_spinbox" && val == -1)?(
        "Drop"
      ):(
        (combo_id == "applyto" || combo_id == "velo_applyto")?(
          (val == 0)?(
            "All"
          ):(
            (val== 1)?(
              gfx_rgb(TH.KEY_WHITE_FILTERED_IN);
              "G "
            ):(
              gfx_rgb(TH.KEY_WHITE_FILTERED_OUT);
              " R"
            )
          );
        ):(
          tmp = #;
          sprintf(tmp, "%d", val);
          tmp;
        );
      );
    );
  );
);



// Draws a enable/disable button
// This button is linked to an adress in memory : flag_address[flag_local_address].
// The only way I had found in EEL to use "pointers" was an array trick.
// I've just discovered pseudo objects, it could be a solution too.
function drawBistateButton(flag_address,flag_local_address,t,l,ontext,offtext,color_on,color_off,color_on_hover,color_off_hover,text_color_on,text_color_off) 
  local(tmp, ontextw, offtextw, 
        bb, br, bw, bh, bl, bt, 
        in_rect, enabled)
(
  tmp = 0; ontextw = 0; offtextw = 0;
  gfx_measurestr(ontext, ontextw, tmp);
  gfx_measurestr(offtext, offtextw, tmp);
  
  bw = max(ontextw,offtextw) + 10;
  bh = 15;
  
  bl = l;
  bt = t;
  
  br = bl + bw;
  bb = bt + bh;
  
  enabled = flag_address[flag_local_address];
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y >= bt && mouse_y <= bb;
  
  in_rect ?(
    // Hover color
    gfx_rgb((enabled)?(color_on_hover):(color_off_hover));

    // Click
    mouse_click == 1 ? (
      flag_address[flag_local_address] = !flag_address[flag_local_address];
    );
  ):(
    // Not-hovered color
    gfx_rgb((enabled)?(color_on):(color_off));
  );
  gfx_rect(bl,bt,bw,bh); 
  
  // Text color
  gfx_rgb((enabled)?(text_color_on):(text_color_off));
  gfx_y = t + 4;
  enabled?(
    gfx_x = l+(bw-ontextw)/2; 
    gfx_drawstr(ontext); 
  ):(
    gfx_x = l+(bw-offtextw)/2;
    gfx_drawstr(offtext)
  );
);

function drawStandardBistateButton(flag_address,flag_local_address,t,l,on_text,off_text) (
  drawBistateButton(flag_address,flag_local_address,t,l,on_text,off_text, TH.EN_B_ON ,TH.EN_B_OFF, TH.EN_B_ON_H, TH.EN_B_OFF_H, TH.EN_B_ON_TEXT, TH.EN_B_OFF_TEXT);
);

function drawSwitchButton(flag_address,flag_local_address,t,l,on_text,off_text) (
 drawBistateButton (flag_address,flag_local_address,t,l,on_text,off_text, TH.SW_B_ON ,TH.SW_B_OFF, TH.SW_B_ON_H, TH.SW_B_OFF_H, TH.SW_B_ON_TEXT, TH.SW_B_OFF_TEXT); 
);


// ShortCut for a OnOff button with "Enabled"/"Bypass" texts
function drawEnableDisableButton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"Enabled","Disabled");
);

// ShortCut for a OnOff button with "Yes"/"No" texts
function drawYesNobutton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"Yes","No");
);

// ShortCut for a OnOff button with "On"/"Off" texts
function drawOnOffButton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"On","Off");
);

// - or + button for a spinbox
function drawAddOrSubButton(button_id,val_address,val_local_address,l,t,add_or_sub,minval,maxval)
   local(bl,bt,br,bb,in_rect,val_shift,got_event)
(
  got_event = 0;

  bl = l;
  bt = t;
   
  br = bl + 15;
  bb = bt + 15;
  
  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt); 
   
  (mouse_click == 1 && in_rect)?(
    mouse_capturator = button_id;
  ); 
   
  in_rect  ?
  (
    gfx_rgb(TH.MONO_B_H);   
    val_shift = 0;
   
    mouse_cap == 1 && mouse_capturator == button_id ? (
      // Limit this to 20 calls / seconds
      new_srcdstbtn_time = time_precise();
      (new_srcdstbtn_time - last_srcdstbtn_time > 0.03 || mouse_click) ? (
        val_shift = (add_or_sub)?(1):(-1);
        last_srcdstbtn_time = new_srcdstbtn_time; 
        mouse_click == 1 ? (last_srcdstbtn_time += 0.3);
      );
    ); 
    /*
      // maybe too dangerous ?
      mouse_wheeli != 0 ? (
        val_shift = mouse_wheeli;
      );
    */
    val_shift != 0 ? (  
      val_address[val_local_address] += val_shift;
      val_address[val_local_address] = min(max(val_address[val_local_address],minval),maxval);   
      got_event = 1; 
    );
  
  ):( gfx_rgb(TH.MONO_B) );  
 
  // Button background 
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
 
  // Button text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb(TH.MONO_B_TEXT);  
  add_or_sub == 0?(gfx_drawstr("-")):(gfx_drawstr("+"));  
  
  got_event;
);

// A Spinbox, with a int value and two +/- buttons
function drawAddOrSubWidget(widget_id,val_address,val_local_address,l,t,minval,maxval,labelwidth)
   local(tmp, roffset, got_event)
(
  roffset = labelwidth + 20; 
  
  got_event = 0;
  
  // Buttons -/+
  got_event |= drawAddOrSubButton(widget_id,val_address,val_local_address,l,t,0,minval,maxval);
  got_event |= drawAddOrSubButton(widget_id,val_address,val_local_address,l+roffset,t,1,minval,maxval);

  // Value between - and +
  gfx_rgb(TH.DYN_LABEL);
 
  gfx_x = l+23; gfx_y = t+4;
  
  tmp = textForComboBox(widget_id, val_address[val_local_address]);
  gfx_drawStr(tmp);
  
  got_event;
);

function drawInputLine(input_id, bl, bt, br, bb, str)
  local(in_rect,new_char,dstr) (
  
  in_rect = ( mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt ); 
  in_rect ?
  (
    gfx_rgb( (g_edited_input==input_id)?(TH.INPUTLINE_EDIT_BG_H):(TH.INPUTLINE_BG_H));   
   
    mouse_click == 1 ? (
      (g_edited_input != input_id)?(
        g_edited_input = input_id;
        while(gfx_getChar()>0); // Empty the queue
      )
      :(
        g_edited_input = "";
      );
    ); 
  ):(
    gfx_rgb( (g_edited_input==input_id)?(TH.INPUTLINE_EDIT_BG):(TH.INPUTLINE_BG) )
  );  
  
  g_edited_input == input_id?
  (
    new_char = gfx_getchar();
    
    // Alpha num
    new_char >= 32 && new_char <= 126 ?
    (
      sprintf(str,"%s%c",str,new_char);
    );
    // Del
    new_char == 8?
    (
      strncpy(str, str, max(strlen(str)-1,0)); 
    );
    // Return / Esc
    new_char == 13 || new_char == 27?
    (
      g_edited_input = "";
    );
  );
  
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb((g_edited_input==input_id)?(TH.INPUTLINE_EDIT_TEXT):(TH.INPUTLINE_TEXT));
  
  g_edited_input == input_id?
  (
    // If in edition, show a caret
    dstr = #;
    sprintf(dstr,"%s_",str);
    gfx_drawstr(dstr);
  ):(
    gfx_drawstr(str);
  );
  
);

/////////////////////
//    CURVE ZONE   //
/////////////////////

function mousePenCallback(gzone)
   local(curve,in_rect,px,py,x1,x2,y1,y2,alpha,i,min_bound,max_bound)
(   
  curve = selectedControlCurveAddress();
  
  in_rect = (mouse_x >= gzone.l && mouse_x < gzone.r && mouse_y >= gzone.t && mouse_y < gzone.b);

  // Remember that first click was in drawing zone (click focus)
  (mouse_click == 1 && in_rect)?(
    mouse_capturator = "curvezone";
  );
  
  // Only handle events if we have click focus
  mouse_cap == 1 && mouse_capturator == "curvezone" && g_pen_is_active ? (  
    // Drawing callback
    in_rect ?
    (
      px = (mouse_x-gzone.il)/(RESOLUTION);
      py = (gzone.ib-mouse_y+2)/(RESOLUTION);
      
      min_bound = controlCurrentMinBound01(g_selected_control);
      max_bound = controlCurrentMaxBound01(g_selected_control);
      
      // If inside the margin around the draw zone, clamp
      px < 0 ? px = 0;
      px > CURVESIZE - 1 ? px = CURVESIZE-1;
      (py < min_bound * (CURVESIZE - 1)) ? (py = min_bound * (CURVESIZE-1));
      (py > max_bound * (CURVESIZE - 1)) ? (py = max_bound * (CURVESIZE-1));
      px = roundi(px);
      py = roundi(py); 
      
      last_modified == -1 || last_modified == px ? (
        curve[px]     = py;
        last_modified = px;
      ):
      (
        // Perform some interpolation since mouse positions are not continuous
        x1=x2=y1=y2=0;
        px <= last_modified ? 
        ( x1 = px; x2 = last_modified; y1 = py; y2 = curve[last_modified]; ):
        ( x1 = last_modified; x2 = px; y1 = curve[last_modified]; y2 = py; );
        i = x1;
        while(i <= x2) (
          alpha  = (i-x1)/(x2-x1);
          curve[i] = y1 + alpha * (y2-y1);
          i += 1;
        );
        last_modified = px;
      )
    )
  ):(
    last_modified = -1
  );
);

function smoothButtonCallback()
  local(curve, i)
(
  curve = selectedControlCurveAddress();
  
  // Limit this to 20 calls / seconds
  new_smooth_time = time_precise();
  (new_smooth_time - last_smooth_time > 0.05) ? (
    
    SCURVE[0]           = curve[0];
    SCURVE[CURVESIZE-1] = curve[CURVESIZE-1];
    
    // Blur the curve
    i = 1;
    while(i<CURVESIZE-1)
    (
      SCURVE[i] = (CURVE[i-1] + CURVE[i] + CURVE[i+1])/3;
      i+=1;
    );
    
    i=0; while(i<CURVESIZE) ( CURVE[i] = SCURVE[i]; i+=1 );
    last_smooth_time = new_smooth_time;
  );
);

function curveButtonCallback(row_num, button_num) 
  local(i,curve,min_bound,max_bound)
(
  curve = selectedControlCurveAddress();

  min_bound = controlCurrentMinBound01(g_selected_control);
  max_bound = controlCurrentMaxBound01(g_selected_control);

  i = 0;
  while(i<CURVESIZE) (
    curve[i] = (CURVESIZE-1) * (min_bound + (max_bound-min_bound) * buttonEquate(row_num, button_num, i/(CURVESIZE-1)));
    i+=1;
  );
);

function drawMousePenButton(gzone)
  local(in_rect,bl,bt,br,bb)
(
  bl = gzone.il;
  bt = gzone.b;
  br = bl + 44;
  bb = bt + 20;
  
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;
 
  (in_rect && mouse_click == 1 && !g_pen_is_active)?(
    g_pen_is_active = 1;
  ):(
    (mouse_click == 1 && mouse_capturator != "curvezone")?(
      g_pen_is_active = 0;
    );
  );

  in_rect ?
  (
    gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON_H):(TH.MONO_B_H) );
  ):(
    gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON):(TH.MONO_B) );
  );
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  

  gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON_TEXT):(TH.MONO_B_TEXT) );
  gfx_x   = bl+10;
  gfx_y   = bt+7;
  gfx_drawstr("Pen");   
);


// Smooth button
function drawSmoothButton(gzone) 
  local(bl,bt,br,bb)
(
  bl = gzone.ir-88;
  bt = gzone.b;
  br = bl + 88;
  bb = bt + 20;
   
  mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt ?
  (
   gfx_rgb(TH.MONO_B_H);
   
   mouse_click == 1 ? ( mouse_capturator = "smoothbutton" );
   
   mouse_cap == 1 && mouse_capturator == "smoothbutton" ? (
     smoothButtonCallback();
   ); 
  ):(gfx_rgb(TH.MONO_B));  
  
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_x   = bl+20;
  gfx_y   = bt+7;
  gfx_rgb(TH.MONO_B_TEXT);
  gfx_drawstr("Smooth");  
);

// Draw buttons
function drawCurveButton(bzone, row_num, button_num) 
  local(points,bl,bt,br,bb,i)
(
  // Adress of the row
  points  = buttonDataAddress(row_num,button_num);
  
  bl = bzone.margin + 20 + bzone.l + button_num*42;
  bt = bzone.margin + 7 + bzone.t + row_num*42;
  br = bl + 32;
  bb = bt + 32;
   
  mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt ?
  (
   gfx_rgb(TH.MONO_B_H);   
   // Handle the callback in the draw function... erm
   (mouse_click==1) ? (
     curveButtonCallback(row_num,button_num);
   ); 
  ):
  ( 
    gfx_rgb(TH.MONO_B);
  );
  
  // Draw the button rect
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
     
  // Draw the button points
  gfx_rgb(TH.MONO_B_CURVE);
  gfx_x = bl; gfx_y = floor(bb- 31*points[0]-0.5);  
  i = 1;
  while(i<32)
  (
    gfx_lineto(bl+i ,floor(bb- 31*points[i]-0.5));
    i+=1;
  );
);

// Curve buttons
function drawCurveButtons(bzone) 
  local(by,r,c)
(
  // Draw headers
  gfx_rgb(TH.DEFAULT_FONT);
  by      = bzone.t+bzone.margin+20;
  gfx_x   = bzone.l;
  gfx_y   = by;
  gfx_drawstr("Lin");
  by      += 42;
  gfx_x   = bzone.l;
  gfx_y   = by;
  gfx_drawstr("X^2"); 
  by      += 42;
  gfx_x   = bzone.l;
  gfx_y   = by;
  gfx_drawstr("X^3");  
  by      += 42;
  gfx_x   = bzone.l;
  gfx_y   = by;
  gfx_drawstr("Circ");
  by      += 42;
  gfx_x   = bzone.l;
  gfx_y   = by;
  gfx_drawstr("Step");  
  by      += 42;
  gfx_x   = bzone.l;
  gfx_y   = by;
  gfx_drawstr("Gate"); 

  // Draw buttons
  r=0; 
  while(r<BUTTON_GRID_SIZE)
  (
    c=0;
    while(c<BUTTON_GRID_SIZE)
    (
      hasButtonInGrid(r,c) ? (
        drawCurveButton(bzone,r,c);
      );
      c+=1; 
    );
   r+=1;
  );
);

function drawMinInputLine()
   local(bl,bt,br,bb,str)
(
  bl = 680;
  bt = GUI_CONTROL_PARAMS_TOP+130;
  br = bl + 80;
  bb = bt + 15;
  
  str = #;
  val = 0;
  match("%f", "2.23", val);
  sprintf(str, "%i", roundi(val*1000));
  drawInputLine("min_bound", bl, bt, br, bb, str);
  
);

function drawBoundariesPanel()
  local(got_event,i,min_bound,max_bound,with_lsb,curve)
(
  gfx_rgb(TH.DEFAULT_FONT);

  with_lsb = controlHasOperationalHighResOutput(g_selected_control);
  
  gfx_xy(694, GUI_CONTROL_PARAMS_TOP + 102);
  gfx_drawStr("Curve limits");
  
  gfx_xy((with_lsb)?(692):(732), GUI_CONTROL_PARAMS_TOP + 142);
  gfx_drawStr("MSB");
  
  (with_lsb)?(
    gfx_xy(770, GUI_CONTROL_PARAMS_TOP + 142);
    gfx_drawStr("LSB");
  );
  
  gfx_xy((with_lsb)?(620):(660), GUI_CONTROL_PARAMS_TOP + 172);
  gfx_drawStr("Min");
  
  gfx_xy((with_lsb)?(620):(660), GUI_CONTROL_PARAMS_TOP + 202);
  gfx_drawStr("Max");
  
  got_event = 0;
  
  got_event |= drawAddOrSubWidget("min_spinbox_msb",CONTROL_MINS_MSB,g_selected_control,(with_lsb)?(670):(710),GUI_CONTROL_PARAMS_TOP+170,0,127,35); 
  got_event |= drawAddOrSubWidget("max_spinbox_msb",CONTROL_MAXS_MSB,g_selected_control,(with_lsb)?(670):(710),GUI_CONTROL_PARAMS_TOP+200,0,127,35); 
  
  (with_lsb)?(
    got_event |= drawAddOrSubWidget("min_spinbox_lsb",CONTROL_MINS_LSB,g_selected_control,750,GUI_CONTROL_PARAMS_TOP+170,0,127,35);
    got_event |= drawAddOrSubWidget("max_spinbox_lsb",CONTROL_MAXS_LSB,g_selected_control,750,GUI_CONTROL_PARAMS_TOP+200,0,127,35); 
  );

  got_event?(
  
    min_bound = controlCurrentMinBound01(g_selected_control)*127;
    max_bound = controlCurrentMaxBound01(g_selected_control)*127;
   
    curve = curveAddress(g_selected_control);
         
    // Reclamp the curve.
    i = 0;
    while(i<CURVESIZE) (
    
      (curve[i]<min_bound)?(curve[i] = min_bound);
      (curve[i]>max_bound)?(curve[i] = max_bound);
      
      i+=1;
    );
  );
);

function drawCurvezone() 
  local(curve, curve_panel_top, left, top, right, bottom, gridstep, gzone, bzone, i, t1,t2,t3,t4)
(
   // Curve zone
    curve_panel_top = GUI_CONTROL_PARAMS_TOP+70;  
    curve = selectedControlCurveAddress();
   
    gzone = 0;
    gzone.margin = 20;
    
    gzone.l   = 10;
    gzone.t   = curve_panel_top; 
    gzone.ih  = (CURVESIZE-1)*RESOLUTION;
    gzone.iw  = (CURVESIZE-1)*RESOLUTION;
    gzone.it  = gzone.t  + gzone.margin;
    gzone.il  = gzone.l  + gzone.margin;
    gzone.ir  = gzone.il + gzone.iw;
    gzone.ib  = gzone.it + gzone.ih;
    gzone.r   = gzone.ir + gzone.margin;
    gzone.b   = gzone.ib + gzone.margin;
  
    left   = gzone.il;
    right  = gzone.ir;
    top    = gzone.it;
    bottom = gzone.ib; 
   
    bzone         = 0;
    bzone.margin  = 20;
    bzone.l       = gzone.r;
    bzone.t       = gzone.t;
    
    t1        = top;
    t2        = bottom - gzone.ih * controlCurrentMaxBound01(g_selected_control);
    t3        = bottom - gzone.ih * controlCurrentMinBound01(g_selected_control);
    t4        = bottom;
    
    // Draw background
    gfx_rgb(TH.CURVE_BG); 
    gfx_rect(left,top,right-left,bottom-top);
    
    gfx_rgb(TH.CURVE_BG_EXCL);
    gfx_rect(left,t1,right-left,t2-t1);
    gfx_rect(left,t3,right-left,t4-t3);
    
      
    // Draw grid
    gfx_rgb(TH.CURVE_GRID);
    gridstep = (CURVESIZE/4)*RESOLUTION;
    gfx_line(left+1*gridstep,top,left+1*gridstep,bottom);
    gfx_line(left+2*gridstep,top,left+2*gridstep,bottom);
    gfx_line(left+3*gridstep,top,left+3*gridstep,bottom);
    gfx_line(left,top+1*gridstep,right,top+1*gridstep);
    gfx_line(left,top+2*gridstep,right,top+2*gridstep);
    gfx_line(left,top+3*gridstep,right,top+3*gridstep);
      
    // Draw border
    gfx_rgb(TH.CURVE_BORDER);
    gfx_x = left;
    gfx_y = top;
    gfx_lineto(right,top);
    gfx_lineto(right,bottom);
    gfx_lineto(left,bottom);
    gfx_lineto(left,top);
     
    // Draw curve
    gfx_rgb(TH.CURVE);
    gfx_x = left;
    gfx_y = bottom-roundi(RESOLUTION*curve[0]);
      
    i = 1; while(i<CURVESIZE)(
      gfx_lineto(left+i*RESOLUTION, bottom - roundi(RESOLUTION*curve[i]));
      i+=1; 
    );
      
    gfx_rgb(TH.CURVE_CURRENT_VALUE);   
    // Draw last event
    gfx_circle(left + CONTROL_LAST_IN[g_selected_control]*RESOLUTION ,bottom-floor(1.5 + RESOLUTION*CONTROL_LAST_OUT[g_selected_control]),3);
        
    mousePenCallback(gzone);    
        
    drawCurveButtons(bzone);
    drawMousePenButton(bzone);
    drawSmoothButton(bzone);
    drawBoundariesPanel();
);

//////////////////////
//  ASSIGN PANEL   //
//////////////////////

// Enable/Disable button for a CC control
function drawEnableDisableButtonForControl(control_num) (
  drawEnableDisableButton(CONTROL_ENABLED,control_num,CONTROL_PANEL_TOP+3,10);
);

function onControlSelect()
(
  disableCCLearn();
  g_edited_input = "";
);

function drawWheel(wh_num) 
  local(control_num, in_rect, slider_zone_x_offset, slider_zone_y_offset,
        slider_h, slider_w, slider_l, slider_t, slider_b, slider_r,
        slider_zone_x_offset, slider_zone_y_offset,
        rect_x, rect_y,
        cval)
(
  control_num = CONTROL_WHEELS_START + wh_num;
 
  slider_zone_x_offset = 30;
  slider_zone_y_offset = CONTROL_PANEL_TOP + 32;
  
  slider_h     = 70 + 5;  
  slider_w     = 15;
  slider_t     = slider_zone_y_offset;
  slider_l     = slider_zone_x_offset; 
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;

  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);
  
  // Click event
  mouse_click == 1 && in_rect ?
  (
    g_selected_control == control_num?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();
  );
  
  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);
    gfx_rect(slider_l-5,slider_t-5,slider_w+10,slider_h+10);
  );
  
  // Draw wheel body 
  gfx_rgb_control_high(control_num);
  gfx_rect(slider_l,slider_t,slider_w,slider_h);
    
  // Draw Cursor
  cval = CONTROL_LAST_IN[control_num]/127.0;
  gfx_rgb_control_low(control_num);
  rect_x = slider_l;
  rect_y = slider_b - cval*65 - 10;
  gfx_rect(rect_x, rect_y, slider_w,10);
);

function drawPad(pad_num, is_pedal)
   local(in_rect, control_num, cval,
         slider_t, slider_l, slider_b, slider_r, slider_h, slider_w,
         slider_h_inner, slider_t_inner, slider_l_inner, slider_w_inner,
         slider_zone_x_offset, slider_zone_y_offset,
         str, str_h, str_w)
(
  control_num = (is_pedal==1)?(CONTROL_PEDALS_START + pad_num):(CONTROL_PADS_START + pad_num);
 
  slider_h     = is_pedal == 1?(12):(22);  
  slider_w     = is_pedal == 1?(15):(32);
 
  slider_zone_x_offset = (is_pedal==1)?(58):(
    507 + (pad_num % 5) * (slider_w+9);
  );
  slider_zone_y_offset =(is_pedal==1)?(32 + pad_num*21):
  (
    30 + floor(pad_num / 5) * (slider_h+23);
  );
  
  slider_t     = CONTROL_PANEL_TOP + slider_zone_y_offset;
  slider_l     = slider_zone_x_offset; 
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;
  
  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);
  
  // Handle events
  mouse_click == 1 && in_rect ?
  (
    g_selected_control == control_num?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();
  );
  
  // Draw highlight
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);  
    gfx_rect(slider_l-3,slider_t-3,slider_w+6,slider_h+((is_pedal==1)?(7):(17)) );
  );
  
  cval = CONTROL_LAST_IN[control_num]/127.0;

  // Draw body
  (is_pedal)?(
    (CONTROL_ENABLED[control_num] == 1)?(
      (cval>0.5)?(
        gfx_rgb_control_high(control_num);
      ):(
        gfx_rgb_control_mid(control_num);
      );
    ):(
      gfx_rgb_control_mid(control_num);
    );
    gfx_rect(slider_l,slider_t,slider_w,slider_h);
     
    // Draw small line pattern that make this look like a pedal
    gfx_rgb( (g_selected_control == control_num)?(TH.CONTROL_HIGHLIGHT):(TH.BACKGROUND) );
    gfx_line(slider_l,slider_t+4,slider_r,slider_t+4);  
    gfx_line(slider_l+3,slider_t,slider_l+3,slider_t+4);  
    gfx_line(slider_l+7,slider_t,slider_l+7,slider_t+4);  
    gfx_line(slider_l+11,slider_t,slider_l+11,slider_t+4);  
     
  ):(
   
    gfx_rgb_control_mid(control_num);
    gfx_rect(slider_l,slider_t,slider_w,slider_h);
    
    // Growing center rect
    (CONTROL_ENABLED[control_num] == 1)?(
      slider_w_inner = roundi(slider_w * cval / 2)*2;
      slider_h_inner = roundi(slider_h * cval / 2)*2;
      slider_l_inner = slider_l + (slider_w - slider_w_inner) * 0.5;
      slider_t_inner = slider_t + (slider_h - slider_h_inner) * 0.5;
            
      gfx_rgb_control_high(control_num);
      gfx_rect(slider_l_inner,slider_t_inner,slider_w_inner,slider_h_inner);
    );  
  
    // Draw Label
    gfx_rgb_control_high(control_num);
    gfx_setfont(1);
    str_w = 0; str_h = 0;
    str = controlLabelWithFallback(control_num);
    gfx_measurestr(str,str_w,str_h);
    gfx_x = slider_l + slider_w/2 - str_w/2; gfx_y = slider_b+1;
    gfx_drawstr(str);
    gfx_setfont(0);
  ); 
);

function drawPedal(ped_num)
(
  drawPad(ped_num,1);
);

function drawFader(sl_num) 
   local(control_num, cval, rect_x, rect_y,
         str, str_w, str_h,
         slider_zone_x_offset, slider_zone_y_offset,
         slider_inter,
         slider_w, slider_h, slider_t, slider_l, slider_b, slider_r, s)
(
  control_num = CONTROL_FADERS_START + sl_num;
 
  slider_zone_x_offset = 85;
  slider_zone_y_offset = 32;
  
  slider_inter = 6;
  slider_w     = 15;
  slider_h     = slider_inter*10 + 5;  
  slider_t     = CONTROL_PANEL_TOP + slider_zone_y_offset;
  slider_l     = slider_zone_x_offset + sl_num * 20; 
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;
  
  // Handle events
  mouse_click == 1 && mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t ?
  (
    g_selected_control == control_num?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();
  );
  
  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT); 
    gfx_rect(slider_l,slider_t,slider_w,slider_h+12);
  );
  
  // Draw tics
  gfx_rgb_control_mid(control_num);
  s = 0;
  while(s<11)
  (
    gfx_line(slider_l + 3, 2 + slider_t + s*slider_inter, slider_r - 4, 2 + slider_t + s*slider_inter);
    s += 1;
  );
  
  // Draw Cursor
  cval = CONTROL_LAST_IN[control_num]/127.0;
  gfx_rgb_control_high(control_num);
  rect_x = slider_l;
  rect_y = slider_b - cval*slider_inter*10-5;
  gfx_rect(rect_x, rect_y, slider_w,5);
  
  // Draw Label
  gfx_rgb_control_high(control_num);
  gfx_setfont(1);
  str_w = 0; str_h = 0;
  str = controlLabelWithFallback(control_num);
  gfx_measurestr(str,str_w,str_h);
  gfx_x = slider_l + slider_w/2 - str_w/2; gfx_y = slider_b;
  gfx_drawstr(str);
  gfx_setfont(0);
);

function drawVelocityWidget() 
   local(control_num, is_control_enabled, is_control_selected,
         icon_top,
         slider_w, slider_h, slider_t, slider_l, slider_r, slider_b, slider_full_h,
         in_rect)
(
 
  control_num          = CONTROL_VELOCITY;
  is_control_enabled   = (CONTROL_ENABLED[control_num] == 1);
  is_control_selected  = (g_selected_control == control_num);
 
  slider_w      = 60;
  slider_h      = 67;
  slider_full_h = 72;
 
  slider_t      = CONTROL_PANEL_TOP + 32;
  slider_l      = 722; 
  
  slider_r      = slider_l + slider_w;
  slider_b      = slider_t + slider_full_h;
  
  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);
  
  // Click event
  mouse_click == 1 && in_rect ?
  (
    is_control_selected?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();
  );
  
  // Draw background
  is_control_selected ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT); 
    gfx_rect(slider_l-5,slider_t-5,slider_w+10,slider_full_h+10);
  );
  
  // Icon
  icon_top = slider_t + 17;
  gfx_rgb_control_high(control_num);
    
  // White keys
  gfx_rect(slider_l,    icon_top + 14, 18, 3);
  gfx_rect(slider_l+20, icon_top + 14, 18, 3);
  gfx_rect(slider_l+40, icon_top + 14, 18, 3);
  
  gfx_rect(slider_l+2,  icon_top + 19, 16, 11); 
  gfx_rect(slider_l+20, icon_top + 19, 18, 11);
  gfx_rect(slider_l+40, icon_top + 19, 16, 11); 
  
  // Black keys
  gfx_rgb_control_low(control_num);  
  gfx_rect(slider_l+11, icon_top+1, 14, 11); 
  gfx_rect(slider_l+33, icon_top+1, 14, 11); 

  // Label
  gfx_rgb_control_high(control_num);  
  gfx_setfont(1);
  gfx_x = slider_l+9; gfx_y = icon_top + 35;
  gfx_drawstr("Velocity");
  gfx_setfont(0);
);

function drawKnob(knob_num) 
  local(kb_zone_x_offset, kb_zone_y_offset, 
        kb_l, kb_r, kb_t, kb_b,
        kb_center_x, kb_center_y, 
        control_num,
        xpos, ypos, t, cval, x, y, 
        str_w, str_h, str)
(
  control_num = CONTROL_KNOBS_START + knob_num;

  kb_zone_x_offset = 305;
  kb_zone_y_offset = 41;
  
  xpos = (knob_num % 5);
  ypos = floor(knob_num / 5);
  
  kb_center_x = kb_zone_x_offset + xpos*43;
  kb_center_y =  CONTROL_PANEL_TOP + kb_zone_y_offset + ypos*44;
  
  kb_l        = kb_center_x - 16;
  kb_r        = kb_center_x + 17;
  kb_t        = kb_center_y - 16;
  kb_b        = kb_center_y + 17;
  
  // Handle events
  mouse_click == 1 && mouse_x >= kb_l && mouse_x <= kb_r && mouse_y <= kb_b && mouse_y >= kb_t ?
  (
    (g_selected_control == control_num)?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();   
  );
  
  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);  
    gfx_rect(kb_l,kb_t,33,43);
  );
  
  // KB Tics
  gfx_rgb_control_high(control_num);
  t = 0;
  while(t<11)
  (
    gfx_line(kb_center_x,kb_center_y,kb_center_x + floor(14*KNOB_TICS_X[t]+0.5), kb_center_y + floor(14*KNOB_TICS_Y[t]+0.5));
    t += 1;
  ); 
  
  // KB Background
  gfx_rgb_control_mid(control_num);
  gfx_circle(kb_center_x,kb_center_y,12,1,0);
  
  // KB Border
  gfx_rgb((g_selected_control == control_num)?(TH.CONTROL_HIGHLIGHT):(TH.BACKGROUND));
  gfx_circle(kb_center_x,kb_center_y,12,0,1);
  
  // Cursor
  gfx_rgb_control_high(control_num);
  
  cval = CONTROL_LAST_IN[control_num]/127.0;
  x = floor(knobTic(cval,1)*12 + 0.5);
  y = floor(knobTic(cval,0)*12 + 0.5);
  
  gfx_line(kb_center_x, kb_center_y, kb_center_x + x, kb_center_y + y);
  
  // Draw Label
  gfx_rgb_control_high(control_num);
  gfx_setfont(1);
  str_w = 0; str_h = 0;
  str = controlLabelWithFallback(control_num);
  gfx_measurestr(str,str_w,str_h);
  gfx_x = kb_center_x - str_w/2; gfx_y = kb_b-3;
  gfx_drawstr(str);
  gfx_setfont(0);
);

// CC Learn widget
function drawCCLearnButton(cnum) 
   local(bl,bt,br,bb,in_rect)
(
  bl = 253;
  bt = GUI_CONTROL_PARAMS_TOP+30;
  br = bl + 70;
  bb = bt + 15;
   
  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt);
  in_rect ? 
  (
    (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON_H)):(gfx_rgb(TH.MONO_B_H));   
    
    mouse_click == 1 ? (
      (isCCLearning())?(disableCCLearn()):(enableCCLearn());
    ); 
  ):
  (
    (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON)):(gfx_rgb(TH.MONO_B));   
  );  
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  
  // Now the text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON_TEXT)):(gfx_rgb(TH.MONO_B_TEXT));  
  gfx_drawstr("CC Learn");
);

// CC Learn widget
function drawCopySrcButton(cnum) 
   local(bl,bt,br,bb,in_rect)
(
  bl = 253;
  bt = GUI_CONTROL_PARAMS_TOP+50;
  br = bl + 70;
  bb = bt + 15;
   
  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt);
  in_rect ?
  (
    // Hover in color
    gfx_rgb(TH.MONO_B_H); 
    // Handle the callback in the draw function... erm
    mouse_click == 1 ? (
      CONTROL_DSTS[cnum] = CONTROL_SRCS[cnum];
    ); 
  ):
  (
    // Hover out color
    gfx_rgb(TH.MONO_B);
  );  
  
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
 
  // Now the text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb(TH.MONO_B_TEXT);
  gfx_drawstr("Copy Src");
);

// Description label widget
function drawDescriptionInputLine() 
   local(bl,bt,br,bb,str)
(
  bl = 130;
  bt = GUI_CONTROL_PARAMS_TOP+10;
  br = bl + 146;
  bb = bt + 15;
  str = controlDescription(g_selected_control);
  
  drawInputLine("input_desc", bl, bt, br, bb, str);
);

// Small label edition widget
function drawSmallLabelInputLine() 
   local(bl,bt,br,bb,str)
(
  bl = 395;
  bt = GUI_CONTROL_PARAMS_TOP+10;
  br = bl + 40;
  bb = bt + 15;
  
  str = controlLabel(g_selected_control);
  drawInputLine("input_sl", bl, bt, br, bb, str);
);


// Control editor sub panel for midi cc assignment
function drawAssignZone() 
   local(src_cc, src_name, src_is_lsb, src_is_msb,
         dst_cc, dst_name, dst_is_lsb, dst_is_msb)
(
  gfx_rgb(TH.DEFAULT_FONT);
    
  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+14;
  gfx_drawStr("Description");
  
  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+34;
  gfx_drawStr("In  ->");
  
  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+54;
  gfx_drawStr("Out ->");
  
  
  gfx_rgb(TH.DEFAULT_FONT); 
  gfx_x=90; gfx_y = GUI_CONTROL_PARAMS_TOP+34;  
  gfx_drawStr("Chan");  
  
  gfx_rgb(TH.DEFAULT_FONT); 
  gfx_x=90; gfx_y = GUI_CONTROL_PARAMS_TOP+54;  
  gfx_drawStr("Chan");
  
  g_selected_control != CONTROL_VELOCITY ?(
    drawAddOrSubWidget("chan_src_spinbox",CONTROL_CHAN_SRCS,g_selected_control,130,GUI_CONTROL_PARAMS_TOP+30,0,16,51);  
    drawAddOrSubWidget("chan_dst_spinbox",CONTROL_CHAN_DSTS,g_selected_control,130,GUI_CONTROL_PARAMS_TOP+50,0,16,51);
  ):(
    gfx_rgb(TH.DYN_LABEL); 
    gfx_x=140; gfx_y = GUI_CONTROL_PARAMS_TOP+34;  
    gfx_drawStr("Keyb In");
  
    gfx_rgb(TH.DYN_LABEL); 
    gfx_x=140; gfx_y = GUI_CONTROL_PARAMS_TOP+54;  
    gfx_drawStr("Keyb Out");
  );
  
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_x=230; gfx_y = GUI_CONTROL_PARAMS_TOP+34;
  gfx_drawStr("CC");
  gfx_x=230; gfx_y = GUI_CONTROL_PARAMS_TOP+54;
  gfx_drawStr("CC");
  
  g_selected_control != CONTROL_VELOCITY ?(
    gfx_x = 295; gfx_y = GUI_CONTROL_PARAMS_TOP+14;
    gfx_drawStr("Small Label");
    
    drawDescriptionInputLine();
    drawSmallLabelInputLine();

    drawCCLearnButton(g_selected_control);
    drawCopySrcButton(g_selected_control);
   
    drawAddOrSubWidget("cc_src_spinbox",CONTROL_SRCS,g_selected_control,332,GUI_CONTROL_PARAMS_TOP+30,0,127,37);
    drawAddOrSubWidget("cc_dst_spinbox",CONTROL_DSTS,g_selected_control,332,GUI_CONTROL_PARAMS_TOP+50,0,127,37);
  
    // Name of the src CC
    gfx_rgb(TH.ROUTING_INFO_CCNAME);
    gfx_x = 412;  gfx_y = GUI_CONTROL_PARAMS_TOP+34;
    src_cc     = CONTROL_SRCS[g_selected_control];
    src_name   = midiControlName(src_cc);
    
    src_is_lsb = isALsbCC(src_cc);
    src_is_msb = isAMsbCC(src_cc);
    
    gfx_drawStr(src_name);
    
    (src_is_lsb)?(
      (isHighResMidiInputEnabled())?(
        gfx_rgb(TH.ROUTING_INFO_NOT_OK);
        gfx_drawStr(" [LSB not routable in High-Res]");
      ):(
        gfx_drawStr(" (LSB)");
      );
    );
    
    (src_is_msb)?(
      (isHighResMidiInputEnabled())?(
        gfx_rgb(TH.ROUTING_INFO_OK);
        gfx_drawStr(" [High Res]");
      ):(
        gfx_drawStr(" (MSB)");
      );
    );
    
    // Name of the dst CC
    gfx_rgb(TH.ROUTING_INFO_CCNAME);
    gfx_x = 412;  gfx_y = GUI_CONTROL_PARAMS_TOP+54;
    dst_cc     = CONTROL_DSTS[g_selected_control];
    dst_name   = midiControlName(dst_cc);
    dst_is_lsb = isALsbCC(dst_cc);
    dst_is_msb = isAMsbCC(dst_cc);
    
    gfx_drawStr(dst_name);
    
    (dst_is_msb)?(
      (isHighResMidiOutputEnabledForControl(g_selected_control))?(
       gfx_rgb(TH.ROUTING_INFO_OK);
        gfx_drawStr(" [High Res]");
      ):(
        gfx_drawStr(" (MSB)");
      );
    );
    
    (dst_is_lsb)?(
      gfx_drawStr(" (LSB)");
    );
    
  ):(
  
    // Keyboard Velocity special case
    gfx_rgb(TH.DYN_LABEL);
    gfx_x = 140; gfx_y = GUI_CONTROL_PARAMS_TOP+14;
    gfx_drawStr("Keyboard velocity");  
    
    // Src
    gfx_rgb(TH.DEFAULT_FONT); 
    gfx_x=90; gfx_y = GUI_CONTROL_PARAMS_TOP+34;  
    gfx_drawStr("Chan");
    
    gfx_rgb(TH.DYN_LABEL_DISABLED);
    gfx_x = 260; gfx_y = GUI_CONTROL_PARAMS_TOP+34;
    gfx_drawStr("Keyboard velocity");  
    (isHighResMidiInputEnabled())?(
      gfx_rgb(TH.ROUTING_INFO_OK);
      gfx_drawStr(" [High Res]");
    );
    
    // Dst
    gfx_rgb(TH.DYN_LABEL_DISABLED);
    gfx_x = 260; gfx_y = GUI_CONTROL_PARAMS_TOP+54;
    gfx_drawStr("Keyboard velocity");    
    (isHighResMidiOutputEnabledForControl(g_selected_control))?(
      gfx_rgb(TH.ROUTING_INFO_OK);
      gfx_drawStr(" [High Res]");
    );
  ); 
  
  (g_selected_control == CONTROL_VELOCITY)?(
    gfx_rgb(TH.DEFAULT_FONT); 
    gfx_x=312; gfx_y = GUI_CONTROL_PARAMS_TOP+14;  
    gfx_drawStr("Keys");
    drawAddOrSubWidget("velo_applyto", KEYBOARD_VELOCITY_APPLY_TO,0,358,GUI_CONTROL_PARAMS_TOP+11,0,2,32);  
  );
  
  (g_selected_control == CONTROL_VELOCITY || ccLsbCounterpart(CONTROL_DSTS[g_selected_control])!=-1)?(
    // High Res Control
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_x = 455; gfx_y = GUI_CONTROL_PARAMS_TOP+14;
    gfx_drawStr("High res output");  
    drawYesNobutton(CONTROL_HIGHRES_OUTPUT_ENABLED,g_selected_control,GUI_CONTROL_PARAMS_TOP+11,590);
  );
);

function drawControlPanel() 
   local(i, str)
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,CONTROL_PANEL_TOP,gfx_w,20);
       
  (g_selected_control != -1)?(
  
    // Header text
    gfx_rgb(TH.HEADER_TEXT);
    gfx_x = 88; gfx_y = CONTROL_PANEL_TOP+7;
    str = #;
    sprintf(str,"%s / %s", controlName(g_selected_control), controlDescription(g_selected_control));
    gfx_drawstr(str);
    
    // Enable / Disable
    drawEnableDisableButtonForControl(g_selected_control);
  ):(
    gfx_rgb(TH.HEADER_TEXT);
    gfx_x = 10; gfx_y = CONTROL_PANEL_TOP+7;  
    gfx_drawstr("Select a control to edit it."); 
  );
  
  drawWheel(0);
  drawPedal(0);
  drawPedal(1);
  drawPedal(2);
  drawPedal(3);
  
  i = 0; while(i<10)
  (
    drawKnob(i);
    i += 1;
  );
  i = 0; while(i<10)
  (
    drawFader(i);
    i += 1;
  );
  i = 0; while(i<10)
  (
    drawPad(i,0);
    i += 1;
  );
  
  drawVelocityWidget();
  
  // Edition of the selected control
  (g_selected_control != -1)?(
    (CONTROL_ENABLED[g_selected_control] == 1 )?(
      // Assignment zone   
      drawAssignZone();
      drawCurveZone();
    ):(
      gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+14 ; gfx_rgb(TH.DEFAULT_FONT);
      gfx_drawstr("To edit the parameters for this control, enable it first.");
    );
  );
);


////////////////////////
//   KEYBOARD PANEL  //
////////////////////////

function drawKeyboardKeyMarker(x,y)
(
  gfx_rgb(TH.KEY_MARKER_BG);
  gfx_circle(x,y,4,1,0);
  gfx_rgb(TH.KEY_MARKER_BORDER);
  gfx_circle(x,y,4,0,0);
);

function drawTransposePanel() 
   local(enabled) 
(

  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(KEYBOARD_PANEL_WIDTH+2,KEYBOARD_FILTERING_TOP,gfx_w - KEYBOARD_PANEL_WIDTH-2,20);

  // Button 
  drawEnableDisableButton(KEYBOARD_TRANSPOSE_ENABLED,0,KEYBOARD_FILTERING_TOP + 3,10 + KEYBOARD_PANEL_WIDTH);
  
  // Title
  gfx_x = 88 + KEYBOARD_PANEL_WIDTH; gfx_y = KEYBOARD_FILTERING_TOP + 7;
 
  gfx_rgb(TH.HEADER_TEXT);
  gfx_drawstr("Transpose"); 
  
  enabled = KEYBOARD_TRANSPOSE_ENABLED[0];
  
  enabled?(

    gfx_x = KEYBOARD_PANEL_WIDTH+10; gfx_y = KEYBOARD_FILTERING_TOP+50;
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_drawstr("8vi");

    gfx_x = KEYBOARD_PANEL_WIDTH+10; gfx_y = KEYBOARD_FILTERING_TOP+70;
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_drawstr("Semitones");
    
    gfx_x = KEYBOARD_PANEL_WIDTH+10; gfx_y = KEYBOARD_FILTERING_TOP+90;
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_drawstr("Keys");
    
    drawAddOrSubWidget("8va"     , KEYBOARD_TRANSPOSE_8VA,0,KEYBOARD_PANEL_WIDTH+90,KEYBOARD_FILTERING_TOP+46,-2,2,32);
    drawAddOrSubWidget("semitone", KEYBOARD_TRANSPOSE_SEMI_TONES,0,KEYBOARD_PANEL_WIDTH+90,KEYBOARD_FILTERING_TOP+66,-12,12,32);
    drawAddOrSubWidget("applyto",  KEYBOARD_TRANSPOSE_APPLY_TO,0,KEYBOARD_PANEL_WIDTH+90,KEYBOARD_FILTERING_TOP+86,0,2,32);
  );
);

function drawKeyboardChannelsPanel() 
   local(kf_enabled) 
(
  kf_enabled = KEYBOARD_FILTERING_ENABLED[0];

  gfx_x = 30; gfx_y = KEYBOARD_PANEL_TOP + 106;
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawstr("Channels");

  gfx_x = 130; gfx_y = KEYBOARD_PANEL_TOP + 106;
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawstr("In");


  drawAddOrSubWidget("chan_in_keyboard_spinbox",KB_INPUT_CHANNEL,0,155,KEYBOARD_PANEL_TOP+102,0,16,35);

  gfx_x = 260; gfx_y = KEYBOARD_PANEL_TOP + 106;
  gfx_rgb(TH.ROUTING_INFO_OK);
  gfx_drawstr("Green out");
  
  drawAddOrSubWidget("chan_out_green_spinbox",KBG_OUTPUT_CHANNEL,0,342,KEYBOARD_PANEL_TOP+102,0,16,51);  
  
  (kf_enabled)?(
    gfx_x = 470; gfx_y = KEYBOARD_PANEL_TOP + 106;
    gfx_rgb(TH.ROUTING_INFO_NOT_OK);
    gfx_drawstr("Red out");
 
    drawAddOrSubWidget("chan_out_red_spinbox",KBR_OUTPUT_CHANNEL,0,537,KEYBOARD_PANEL_TOP+102,-1,16,51);  
  );
);

function drawKeyboardPanel() 
   local(kf_enabled, loff, left, top, white_key_width, key_height_top, key_height_bottom, key_height_full, 
         bk, key_top, key_offset, key_width, oct, in_oct_pos, in_rect, i,
         normalized_key_offset, normalized_key_width,
         wkcount)
(
  kf_enabled = KEYBOARD_FILTERING_ENABLED[0];

  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,KEYBOARD_FILTERING_TOP,KEYBOARD_PANEL_WIDTH,20);
  
  // Enable/Disable
  drawEnableDisableButton(KEYBOARD_FILTERING_ENABLED,0,KEYBOARD_FILTERING_TOP + 3,10);

  // Header text
  gfx_rgb(TH.HEADER_TEXT);
  gfx_x = 87; gfx_y = KEYBOARD_FILTERING_TOP+7;
  
  gfx_drawstr((kf_enabled)?("Keyboard splitting"):("Keyboard splitting (All keys are green)"));
  
  // 88 keys keyboard
  // A0 : midi note 21
  // C8 : midi note 108
  
  loff              = 30;
  white_key_width   = 12;
  key_height_top    = 35;
  key_height_bottom = 25;
  key_height_full   = key_height_top + key_height_bottom;
  
  key_top           = KEYBOARD_FILTERING_TOP + 30; // Header skip
  
  // Top part of the keyboard
  i = 0; 
  while(i<88) (
    bk = keyIsBlack(i);
      
    oct         = floor(i / 12);
    in_oct_pos  = i%12;
    
    normalized_key_offset = OCTAVE_TOP_KEY_OFFSETS[in_oct_pos];
    normalized_key_width  = OCTAVE_TOP_KEY_WIDTHS[in_oct_pos];
    
    (i==0)?(
      // A0 patch
      normalized_key_offset = 0;
      normalized_key_width  = 0.5;
    );
    
    (i==87)?(
      // C8 patch
      normalized_key_width = 1;
    );
    
    key_offset = loff + (normalized_key_offset + oct * 7) * white_key_width; 
    key_width  = normalized_key_width * white_key_width;
    
    (key_width != 0)?(
    
      // Key should appear at the top part of the keyboard
      left = key_offset;
      top  = key_top;
      
      // Draw white keys
      (!kf_enabled)?(
        // Keyboard filtering not enabled, all keys are grayed out
        gfx_rgb((bk)?(TH.KEY_BLACK_DISABLED):(TH.KEY_WHITE_DISABLED));
        gfx_rect(left,top,key_width,key_height_top);
      ):(
      
        // Keyboard filtering enabled, color depends on key conf
        (KEYBOARD_FILTERED_NOTES[i] == 1)?(
          // The Key is disabled
          gfx_rgb((bk)?(TH.KEY_BLACK_FILTERED_OUT):(TH.KEY_WHITE_FILTERED_OUT));
        ):(
          // The Key is enabled 
          gfx_rgb((bk)?(TH.KEY_BLACK_FILTERED_IN):(TH.KEY_WHITE_FILTERED_IN));
        );
        gfx_rect(left,top,key_width,key_height_top);
        
        in_rect = (mouse_x >= left && mouse_y >= top && mouse_x <= (left+key_width) && mouse_y <= (top+key_height_top));       
        (in_rect)?(
          
          (mouse_click == 1)?( 
            // Remember that the keybord has click focus
            mouse_capturator      = "keyboard";
            // We clicked on a key, we are colorizing all future hovered keys
            // With the opposite color.
            keyboard_key_enabling = ((KEYBOARD_FILTERED_NOTES[i] == 1)?(0):(1));
          );
          
          (mouse_cap == 1 && mouse_capturator == "keyboard")?(
            
            // Ok we are changing the status of this key
            KEYBOARD_FILTERED_NOTES[i] = keyboard_key_enabling;
          );  
        );
        
      );

      // Black separation lines
      gfx_rgb(TH.BACKGROUND);
      gfx_line(left+key_width-1,top,left+key_width-1,top+key_height_top-1);
      
      (bk)?(
        gfx_line(left,top+key_height_top-1,left+key_width-1,top+key_height_top-1);
        
        // Key press marker
        (KEY_VELOCITIES[i] > 0)?(
          drawKeyboardKeyMarker(left + floor(key_width/2) -1,top+floor(key_height_top/2));
        );
      );
    );
    
    i+=1;
  );

  // Bottom part of the keyboard
  wkcount = 0; i = 0; 
  while(i<88) (
  
    bk = keyIsBlack(i);
    
    (!bk)?(
      left = loff+wkcount*white_key_width;
      top  = key_top + key_height_top;
    
      // Draw white keys
      (!kf_enabled)?(
        // Keyboard filtering not enabled, all keys are grayed out
        gfx_rgb(TH.KEY_WHITE_DISABLED);
        gfx_rect(left,top,white_key_width,key_height_bottom);
      ):
      (
        // Keyboard filtering enabled, color depends on key conf
        (KEYBOARD_FILTERED_NOTES[i] == 1)?(
          // The Key is disabled
          gfx_rgb(TH.KEY_WHITE_FILTERED_OUT);
        ):(
          // The Key is enabled 
          gfx_rgb(TH.KEY_WHITE_FILTERED_IN);
        );
        
        gfx_rect(left,top,white_key_width,key_height_bottom); 
      
        in_rect = (mouse_x >= left && mouse_y >= top && mouse_x <= (left+white_key_width) && mouse_y <= (top+key_height_bottom));       
        (in_rect)?(
          
          (mouse_click == 1)?( 
            // Remember that the keybord has click focus
            mouse_capturator      = "keyboard";
            // We clicked on a key, we are colorizing all future hovered keys
            // With the opposite color.
            keyboard_key_enabling = ((KEYBOARD_FILTERED_NOTES[i] == 1)?(0):(1));
          ); 
          
          (mouse_cap == 1 && mouse_capturator == "keyboard")?(
  
            //Ok we are changing the status of this key
            KEYBOARD_FILTERED_NOTES[i] = keyboard_key_enabling;
          );
        );
      );  
            
      // Black separation line
      gfx_rgb(TH.BACKGROUND);
      gfx_line(left+white_key_width-1,top,left+white_key_width-1,top+key_height_bottom-1);
      
      // Key press marker
      (KEY_VELOCITIES[i] > 0)?(
        drawKeyboardKeyMarker(left + floor(white_key_width/2) -1,top+floor(key_height_bottom/2));
      );
      
      // Increment white key counter
      wkcount += 1;
    );
    
    // Next key
    i+=1; 
  );
  
  drawKeyboardChannelsPanel();
  drawTransposePanel();
);

function drawBottomBanner()
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,gfx_h-20,gfx_w,20);
      
  // Header text
  gfx_rgb(TH.HEADER_TEXT);
  gfx_x = 6; gfx_y = gfx_h - 14;
  gfx_drawstr("Midi CC Mapper X (3.3) by Benjamin 'Talagan' Babut - Dedicated to Kenji Kawai"); 

  drawSwitchButton(GUI_MODE,0,gfx_y-4,gfx_w-134,"Global settings","Back to plugin");
);

function drawGlobalSettingsPanel() (
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,0,gfx_w,20);
  
  gfx_rgb(TH.HEADER_TEXT);
  gfx_x= 10; gfx_y = 7;
  gfx_drawstr("Global Settings"); 
  
  // Add an additional button for going back (one never knows)
  drawSwitchButton(GUI_MODE,0,4,gfx_w - 134,"Global settings","Back to plugin");

  // High Res input option
  drawOnOffButton(HIGHRES_INPUT_ENABLED,0,50,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_x= 100; gfx_y = 54;
  gfx_drawstr("High-Res midi input"); 
  
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_x= 100; gfx_y = 74;
  gfx_drawstr("If this option is on, all LSB CCs become 'unroutable' : they are aggregated"); 
  gfx_x= 100; gfx_y = 88;
  gfx_drawstr("to their MSB counterparts to form High-Res midi CC values. To route these"); 
  gfx_x= 100; gfx_y = 102;
  gfx_drawstr("values in that configuration, you should route the MSB CC."); 
    
  // Firewall option 
  drawOnOffButton(DROP_UNROUTED_CC_MESSAGES,0,120,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_x= 100; gfx_y = 124;
  gfx_drawstr("Drop unrouted CC messages"); 
  
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_x= 100; gfx_y = 144;
  gfx_drawstr("If this option is on, all CC messages from unrouted controls are dropped."); 
  gfx_x= 100; gfx_y = 158;
  gfx_drawstr("This makes the plugin acts as a firewall for the CC controls."); 
  
  // Firewall note
  drawOnOffButton(DROP_UNROUTED_NOTE_MESSAGES,0,180,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_x= 100; gfx_y = 184;
  gfx_drawstr("Drop unrouted Note messages"); 
  
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_x= 100; gfx_y = 204;
  gfx_drawstr("If this option is on, all Note messages that do not match the keyboard input"); 
  gfx_x= 100; gfx_y = 218;
  gfx_drawstr("channel are dropped. This makes the plugin acts as a firewall for the keyboard."); 
  
  // Theme option 
  drawSwitchButton(CURRENT_THEME_NUM,0,240,35,"Dark","Light");
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_x= 100; gfx_y = 244;
  gfx_drawstr("Theme"); 
);

function drawGui()
(
  updateTheme();
  gfx_clear = (TH.BACKGROUND & 0xFF) << 16 + (TH.BACKGROUND & 0x00FF00) + (TH.BACKGROUND >> 16) ;
  (GUI_MODE[0] == 1)?(
  //  drawChannelPanel();
    drawKeyboardPanel();
    drawControlPanel();
  ):(
    drawGlobalSettingsPanel();
  );
  drawBottomBanner();
);

///////////////////////////////////
// MOUSE EVENT ADDITIONAL LOGIC  //
///////////////////////////////////

function mouseClickAddOn()
(
  // Create a mouse_click event
  (mouse_cap != last_mouse_cap)?(
    (mouse_cap == 1)?(mouse_click = 1):(mouse_click = 0);
    last_mouse_cap = mouse_cap;    
  ):(
    mouse_click = 0;
  );
  
  // Clear the capturator source
  (mouse_cap == 0)?(
     mouse_capturator = "";
  );
);

function mouseWheelAddon()
(
  mouse_wheel != 0?
  (
    mouse_wheeli = (mouse_wheel>0)?(1):(-1);
  ):(
    mouse_wheeli = 0;
  );
  
  mouse_wheel = 0;
);

//////////////
// UI MAIN  //
//////////////

function ui_main() (
  // Main Routine
  mouseClickAddon();
  mouseWheelAddon();
  drawGui();
);

ui_main();


// TESTS : Convert to i and back
/*
aaa_test_fconv     = midiVelocityHresI2F01(0,0);
midiVelocityHresF012I(aaa_test_fconv);
aaa_test_fconv_h   = g_hres_h;
aaa_test_fconv_l   = g_hres_l;

aaa_vtest_fconv     = midiVelocityHresI2F01(0,0);
midiVelocityHresF012I(aaa_vtest_fconv);
aaa_vtest_fconv_h   = g_hres_h;
aaa_vtest_fconv_l   = g_hres_l;
*/

//===========================================//
//==============     BLOCK     ==============//
//===========================================//
@block

// For a given CONTROL on the UI, try to process the CC message
// The value is not passed. It's already been stored in CC_RECEIVED_VALUES.
function tryProcessCCWithControl(evt, blk_control) 
  local (was_processed, 
         in_val_01, out_val_01, 
         ctrl_input_chan, ctrl_output_chan,
         out_cc_num, out_chan, out_status,
         in_lsb_counterpart, out_lsb_counterpart,
         src_matches, src_cc_matches, src_chan_matches, src_is_enabled, src_matches_and_is_enabled, control_is_not_velocity) 
(
  was_processed = 0;
  
  ctrl_input_chan  = CONTROL_CHAN_SRCS[blk_control];
  ctrl_output_chan = CONTROL_CHAN_DSTS[blk_control];

  // We found in the GUI a Control with is enabled and matches this CC
  src_cc_matches              = (CONTROL_SRCS[blk_control] == evt.cc_num);
  src_chan_matches            = (ctrl_input_chan == evt.chan || ctrl_input_chan == 0); // 0 is ANY
  src_matches                 = src_cc_matches && src_chan_matches;
  src_is_enabled              = (CONTROL_ENABLED[blk_control] == 1);
  src_matches_and_is_enabled  = (src_matches && src_is_enabled);
  control_is_not_velocity     = (blk_control != CONTROL_VELOCITY);
 
  (src_matches_and_is_enabled && control_is_not_velocity) ? (
  
    // Calculate curve result
    in_val_01  = 0;
    
    in_lsb_counterpart = ccLsbCounterpart(evt.cc_num); 
    
    in_lsb_counterpart != -1 && isHighResMidiInputEnabled() ? (
      // It's a high res control. 
      // Read full value and convert.
      in_val_01   = midiCCHresI2F01(CC_RECEIVED_VALUES[evt.cc_num], CC_RECEIVED_VALUES[in_lsb_counterpart]);
    ):(
      // Low res are normalized with a max of 127.0
      in_val_01   = CC_RECEIVED_VALUES[evt.cc_num]/127.0;
    );
  
    // Apply the curve
    out_val_01 = applyCurve(blk_control, in_val_01);
    
    // Save some values for UI feedback (small red circle)
    CONTROL_LAST_IN[blk_control]  = in_val_01 * 127;
    CONTROL_LAST_OUT[blk_control] = out_val_01 * 127;
    
    // Send result
    out_cc_num          = CONTROL_DSTS[blk_control];
    out_lsb_counterpart = ccLsbCounterpart(out_cc_num);
    out_chan            = (ctrl_output_chan == 0)?(evt.chan):(ctrl_output_chan);
    out_status          = (CC_MSG<<4)|(out_chan-1); // Chan : 1-16 ->> 0-15
     
    out_lsb_counterpart != -1 && isHighResMidiOutputEnabledForControl(blk_control) ? (
      // Output high res
      midiCCHresF012I(out_val_01);     
      // Send lsb first then msb
      midiSend(evt.mpos, out_status, out_lsb_counterpart, g_hres_l);
      midiSend(evt.mpos, out_status, out_cc_num,          g_hres_h);
    ):(
      // Output low res, normalize by 127 (max is 127).
      midiSend(evt.mpos, out_status, out_cc_num, roundi(out_val_01 * 127) );
    );
    
    was_processed = 1;
  );

  was_processed;
);

function processCCMessage(evt) 
  local (process_counter, blk_control) 
( 
  // Memorize, may be useful
  CC_RECEIVED_VALUES[evt.cc_num] = evt.cc_val;

  process_counter = 0;
  (isHighResMidiInputEnabled() && isALsbCC(evt.cc_num))?(
  
    // In high res midi, drop all messages coming from lsb channels
    // They've been just stored for aggregation.
    process_counter = 1;
  ):(
  
    // Loop on all controls and see if we could find
    // Some of them linked to that cc.
    blk_control = 0; while(blk_control < CONTROL_COUNT)
    (              
      process_counter += tryProcessCCWithControl(evt, blk_control);
      blk_control     += 1;
    );
  );
  
  process_counter;
);

function processNoteMessage(evt) 
  local(new_key, is_red_key,
    src_chan, dst_chan, src_chan_matches, dst_status,
    was_processed, should_keep_note, 
    has_velocity, velocity_01, out_velocity_01, 
    velocity_control_enabled, should_apply_velocity_to_key, should_transpose, transpose_tgt, velocity_tgt,
    lsb_cc_msg)
(
  was_processed = 0;
  
  // Update key statuses, to be displayed in the gui
  (evt.type == NOTE_OFF_MSG)?(
    // For safety. I don't know if it's useful.
    evt.velocity=0;
  );  
  
  // Save the source velocity, this is for UI feedback
  KEY_VELOCITIES[evt.key] = evt.velocity;
  
  is_red_key       = isKeyboardFilteringEnabled() && isRedKey(evt.key); // Key is green if filtering not enabled
  src_chan         = KB_INPUT_CHANNEL[0];
  src_chan_matches = (src_chan == evt.chan || src_chan == 0); // 0 is ANY
  
  (src_chan_matches)?(
  
    dst_chan  = (is_red_key)?(KBR_OUTPUT_CHANNEL[0]):(KBG_OUTPUT_CHANNEL[0]);  
    dst_chan  = (dst_chan == 0)?(evt.chan):(dst_chan);
  
    // -1 is the drop channel.
    (dst_chan != -1)?( 
    
      new_key = evt.key;
          
      transpose_tgt    = KEYBOARD_TRANSPOSE_APPLY_TO[0];
      should_transpose = (transpose_tgt == 0 || (!is_red_key && transpose_tgt == 1) || (is_red_key && transpose_tgt == 2));
      
      // Transpose if asked to.
      (should_transpose)?(
        (KEYBOARD_TRANSPOSE_ENABLED[0])?(
          new_key = evt.key + KEYBOARD_TRANSPOSE_8VA[0]*12 + KEYBOARD_TRANSPOSE_SEMI_TONES[0];
      
          // Clamp the key if we're too low
          (new_key<0)?(new_key=0);
        );
      );
      
      // Caution : Note OFF can be either (NOTE_OFF_MSG) or (NOTE_ON_MSG + velocity zero)
      // Thus, the following code should be tolerant :
      // Velocity 0 should not be changed to something else.
      
      has_velocity                  = (evt.velocity!=0);  
      velocity_01                   = 0;         
       
      // CALCULATE INPUT VALUE HI/LOW RES
      (isHighResMidiInputEnabled())?(
        (has_velocity)?(
          // Seems to me we should sub 1 to the velocity (MSB)
          // To be continuous starting from 0 (First non-null HR velocity starts at 0x0080, MSB is non null)
          velocity_01 = midiVelocityHresI2F01(evt.velocity-1, CC_RECEIVED_VALUES[88]); 
          CC_RECEIVED_VALUES[88] = 0; // Clear the LSB. 
        );
      ):(
        velocity_01 = evt.velocity/127;
      );
            
     
      // APPLY THE CURVE
      out_velocity_01 = 0;
      has_velocity?(
       
        // Apply velocity curve if needed
        velocity_control_enabled      = CONTROL_ENABLED[CONTROL_VELOCITY];
        velocity_tgt                  = KEYBOARD_VELOCITY_APPLY_TO[0];
        should_apply_velocity_to_key  = (velocity_tgt == 0 || (!is_red_key && velocity_tgt == 1) || (is_red_key && velocity_tgt == 2));
       
        (velocity_control_enabled && should_apply_velocity_to_key)?(
          out_velocity_01                     = applyCurve(CONTROL_VELOCITY, velocity_01);
        
          // Save for UI feedback (red circle).
          // Do it only when there's some velocity, having the circle 
          // going back to 0 each time we release a key is annoying
          CONTROL_LAST_IN[CONTROL_VELOCITY]   = velocity_01*127;
          CONTROL_LAST_OUT[CONTROL_VELOCITY]  = out_velocity_01*127;
        ):(
        
          // Just keep the value as is (bypass any calculation)
          out_velocity_01 = velocity_01;
        )
      );
      
      // Create out status, remap chan to to 0-15
      dst_status = (evt.type << 4) | (dst_chan-1);
                   
      // SEND THE FINAL RESULT HI/LOW RES
      (isHighResMidiOutputEnabledForControl(CONTROL_VELOCITY))?(
         
        lsb_cc_msg = ((CC_MSG << 4) | evt.chan);
        (has_velocity)?(
          // Send modified velocity
          midiVelocityHresF012I(out_velocity_01);
        
          // Note : if pen drawn
          // g_hres_l will always be = 127 due to the drawing resolution
          midisend(evt.mpos, lsb_cc_msg, 88, g_hres_l);
          midisend(evt.mpos, dst_status, keyToMidiNote(new_key), g_hres_h);
        ):(
          // Send 0-velocity note.
          midisend(evt.mpos, lsb_cc_msg, 88, 0);
          midisend(evt.mpos, dst_status, keyToMidiNote(new_key), 0);
        );
      ):
      (   
        // This is compatible with zero-velocity
        midisend(evt.mpos, dst_status, keyToMidiNote(new_key), roundi(out_velocity_01 * 127) );
      );
    );
  
    // As long as the input channel is concerned
    // Consider the event as treated.
    was_processed = 1;
  );  
);

function mainLoop() 
  local(mpos,msg1,msg2,msg3,was_routed)
(

  while(midirecv(mpos, msg1, msg2, msg3))
  (
  
    evt = 0;
    evt.mpos   = mpos;
    evt.msg1   = msg1;
    evt.msg2   = msg2;
    evt.msg3   = msg3;
    evt.status = msg1;
    evt.type   = (msg1 >> 4)& 0x0F;
    evt.chan   = (msg1 & 0x0F)+1; // 1-16, not 0-15
    evt.cc_num = 0;
    evt.cc_val = 0;
     
    // status    = msg1;
    // statusHi  = (status >> 4) & 0x0F;   // Type of message
    // statusLo  = (status & 0x0F);        // Channel
    
    // status = msg1;
    // statusHi = (msg1/16)|0;
    // statusLo = msg1-(statusHi*16);
        
    (evt.type == CC_MSG) ? (
      
      // Translate into "cc words" for more comprehensible code
      evt.cc_num = msg2; 
      evt.cc_val = msg3;
        
      // CC LEARN
      (isCCLearning() && g_selected_control != -1 && isCCLearnable(evt.cc_num))?(
        CONTROL_SRCS[g_selected_control] = evt.cc_num;
        disableCCLearn();
      );
        
      was_routed = processCCMessage(evt);   
      !was_routed && !shouldDropUnroutedCCMessages()?(
        // Re-send message
        midisend(mpos, msg1, msg2, msg3);
      ); 
    ):
    (
      // NOTE MESSAGE
      (evt.type == NOTE_ON_MSG || evt.type == NOTE_OFF_MSG)?(
        
        evt.note      = msg2;
        evt.key       = midiNoteToKey(evt.note);
        evt.velocity  = msg3;
           
        was_routed    = processNoteMessage(evt);
        !was_routed && !shouldDropUnroutedNoteMessages()?(
          // Re-send message
          midisend(mpos, msg1, msg2, msg3);
        );
      ):
      (
        // Not a control event, send as is
        midisend(mpos, msg1, msg2, msg3);
      );
    );
  );
);

mainLoop();
