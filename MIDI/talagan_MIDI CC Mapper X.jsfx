desc: MIDI CC Mapper X
author: Talagan
version: 3.5
changelog:
  - Function library system : functions are stored in a function lib with sets that are extensible
  - Parametric sets : some sets are parametric, they can be used to generate an infinite number of curves
  - User sets : the user can now import her/his own curves in the library
  - Function export : MIDI CC Mapper X is now shipped with a script that exports the current curve
  - Added support for all notes within the MIDI range (0-127).
  - Bug fix for notes that could be transposed outside of midi range.
screenshot:
  Dark Theme https://stash.reaper.fm/37471/CCMapperX-Dark.png
  Light Theme https://stash.reaper.fm/37472/CCMapperX-Light.png
provides:
  [script main] talagan_MIDI CC Mapper X/MIDI CC Mapper X - Dump Current Function.lua
  [data] talagan_MIDI CC Mapper X/README.md
  [data] talagan_MIDI CC Mapper X/lib.txt
  [data] talagan_MIDI CC Mapper X/_tools/*
  [data] talagan_MIDI CC Mapper X/func/lib/*
  [data] talagan_MIDI CC Mapper X/func/lib/circ/*
  [data] talagan_MIDI CC Mapper X/func/lib/kawaik4/*
  [data] talagan_MIDI CC Mapper X/func/lib/sin/*
  [data] talagan_MIDI CC Mapper X/func/lib/sstep/*
  [data] talagan_MIDI CC Mapper X/func/user_lib/*
about:
  # Midi CC Mapper X

  This JSFX  is an extended version of the original plugin called "MIDI CC Mapper" with many more features. It allows to modify the behavior and the real-time feel of a MIDI controller, by acting as a pre-filter on the MIDI input. It can : 

  - Tweak CC response curves :
    - By using predefined curves, some of them being parametric
    - By pen-drawing/prototyping custom curves
    - By smoothing the current curve
    - By restricting the range of values of your curve
    - By extending the predefined curves with your own sets of functions (through lib files)
    - The current curve can be exported and reused in your own sets
  - Filter in/out keyboard keys, channel split and drop/re-route keyboard keys
  - Transpose keyboard keys
  - Re-route CCs
  - Re-route CC channels
  - Tweak the keyboard velocity response curve

  The UI shows a virtual controller, on which CCs can be attributed to controls, allowing a user to visually map her/his real controller.

  High-Res MIDI input can be enabled via a global parameter, and High-Res MIDI output can be enabled on CCs individually.

  ## Keyboard Filtering Module

  Located in the top left of the main window, it can be used to achieve various configurations. You can enable/disable key colorizing with the button located in the module title bar. If key colorizing is enabled, the keys can be colorized in red/green by click/moving the mouse on them. The UI provides feedback for currently pressed keys.

  An input channel may be defined for the keyboard : all other channels will be ignored by the plugin. Output channels may be defined for the green/red parts of the keyboard to possibly reroute them, with the option to drop the red part (to filter them out).

  This module can be of great help for defining regions on the keyboard. Also, by reusing it on multiple tracks at the same time, you can easily achieve keyboard split (left hand/right hand or more) and/or multi-instruments combinations.

  ## Keyboard Transposition Module

  Located in the top right of the main window. This module can be enabled or bypassed with the button located in the module title bar. If enabled, applies the sum of two parameters, one for transposing by octaves, one for transposing by semitones. This module can be optionally applied to the red/green/both parts of the keyboard.

  ## CC Routing/Curve tweaking

  Located in the bottom of the main window. This module UI is contextual to the selected control. When selected, a control can be enabled or disabled individually with the button located in the module title bar. For each control :

  - A description can be given that will appear in the title bar
  - A short description can be given that will appear close to the control for convenience
  - An input CC can be assigned (except for the velocity control which is tied to the keyboard velocity)
  - This input CC can be CC learned
  - An output CC can be assigned
  - This output CC can be copied from the input CC
  - The response curve can be pendrawn by hand with the mouse
  - The response curve can be defined from one of the templates on the right
  - The response curve can be smoothed with the smooth button
  - The response curve may be restricted to a user-defined space by configuring MIDI min/max values.

  Additionally, channel input/output may be configured for the CC.

  ## Customizing the function library
  
  The function library is customizable. You can rearrange things, remove sets and functions, and add your own functions after having generated them or having exported them from REAPER. Please refer to the library manual, which is located in <REAPER_RESOURCE_PATH>/Data/talagan_MIDI CC Mapper X/README.md .

  ## Reaper forum thread

  https://forum.cockos.com/showthread.php?t=172630
  
  ## Notes

  Older versions (v1 and v2) can be found on the forum thread.
license:
  MIT (Do whatever you like with this code).
docs:
  Midi HR CC #88 for Velocity : https://forum.cockos.com/showthread.php?t=83782

options:want_all_kb
options:gmem=MIDICCMapperX


//===========================================//
//=============      INIT      ==============//
//===========================================//
@init

//////////////////////////
//  GLOBAL VARS/UTILS   //
//////////////////////////
function roundi(valf) (
  floor(valf+0.5) | 0;
);

///////////////
//  MEMORY   //
///////////////

// Helper function for memory allocation.
function malloc(msize)
  local(ret)
(
  ret = MEM_PTR;
  MEM_PTR += msize;
  ret;
);

// Same thing for gmem.
function galloc(msize)
  local(ret)
(
  ret = GMEM_PTR;
  GMEM_PTR += msize;
  ret;
);

function sharedGlobalVarInit()
(
  CURVESIZE                 = 128; 
  PREVIEWSIZE               = 32;
  RESOLUTION                = 2;  
);

function instanceGlobalVarInit() 
(
  // Map PTR
  MEM_PTR                   = 0;
  
  NOTE_OFF_MSG              = 8;
  NOTE_ON_MSG               = 9;
  CC_MSG                    = 11; // 0x0B
  
  // Plugin Controls parameters
  CONTROL_WHEELS_START      = 0;  // 1 wheel
  CONTROL_PEDALS_START      = 1;  // 4 peds
  CONTROL_FADERS_START      = 5;  // 10 faders
  CONTROL_KNOBS_START       = 15; // 10 sliders
  CONTROL_PADS_START        = 25; // 10 pads
  CONTROL_VELOCITY_START    = 35; // 1 velo
  CONTROL_COUNT             = 36;
  
  CONTROL_MOD_WHEEL         = CONTROL_WHEELS_START;
  CONTROL_VELOCITY          = CONTROL_VELOCITY_START;
  
  // Various UI dimensions
  KEYBOARD_FILTERING_TOP    = 0;
  CONTROL_PANEL_TOP         = 130;
  GUI_CONTROL_PARAMS_TOP    = 260;
  
  KEYBOARD_PANEL_WIDTH      = 670;
  
  // Pseudo-Object that contains pointer to colors
  TH                        = 0;
  
  // Theme nums
  DARK_THEME                = 0;
  LIGHT_THEME               = 1;
);


function gmemGlobalVarInit()
(
  // Map PTR
  GMEM_PTR                = 0;

  // FSETS : variables and offsets
  FSET_MAX_COUNT          = 21; // 3 lines of 7 tabs
  FSET_ROW_COUNT          = 5;
  FSET_COL_COUNT          = 6;
  
  FSET_ID_MAXLEN          = 10;
  FSET_TAB_MAXLEN         = 8;
  FSET_DESC_MAXLEN        = 50;
);

function gmemMemoryMapInit()
(
  /////////////////////////////////////////////////////////////
  // GMEM Mapping : Shared memory between plugin instances   //
  /////////////////////////////////////////////////////////////
  FSET_ID_MAXSLOT         = roundi(FSET_ID_MAXLEN/4) + 1;
  FSET_TAB_MAXSLOT        = roundi(FSET_TAB_MAXLEN/4) + 1;
  FSET_DESC_MAXSLOT       = roundi(FSET_DESC_MAXLEN/4) + 1;
  
  // FSETS : Function set memory mapping
  FSET_OFFSET_ID            = 0; 
  FSET_OFFSET_IS_PARAMETRIC = FSET_OFFSET_ID            + 1;  
  FSET_OFFSET_PARAMETRIC_ID = FSET_OFFSET_IS_PARAMETRIC + 1;  
  FSET_OFFSET_PARAM         = FSET_OFFSET_PARAMETRIC_ID + 1;
  FSET_OFFSET_TAB           = FSET_OFFSET_PARAM         + FSET_ID_MAXSLOT;  
  FSET_OFFSET_DESC          = FSET_OFFSET_TAB           + FSET_TAB_MAXSLOT;
  FSET_OFFSET_FUNCTIONS     = FSET_OFFSET_DESC          + FSET_DESC_MAXSLOT;
  
  // FSETS : Function memory mapping
  FSF_OFFSET_DEFINED      = 0;
  FSF_OFFSET_CURVE        = FSF_OFFSET_DEFINED + 1;
  FSF_OFFSET_PREVIEW      = FSF_OFFSET_CURVE   + CURVESIZE;
  // Sub-Total size       ------
  FSF_SIZE                = FSF_OFFSET_PREVIEW + PREVIEWSIZE;
  
  // Total size           -----
  FSET_SIZE               = FSET_OFFSET_FUNCTIONS + (FSET_ROW_COUNT * FSET_COL_COUNT * FSF_SIZE);
  
  // Define some ids for the parametric sets
  FSET_PARAMETRIC_LINEAR_ID = 40;
  FSET_PARAMETRIC_XN_ID     = 41;
  FSET_PARAMETRIC_EXPNX_ID  = 42;
  
  // (galloc does not write memory so this will 
  // not squash memory from an instance to the other)
  // But only realign the mem ptr
  GMEM_LOADER_ID        = galloc(1); // The ID of the instance that loaded gmem
  GMEM_CMD              = galloc(1); // Cmd num
  GMEM_CMD_STATUS       = galloc(1); // Cmd status : 0 no cmd, 1 cmd ready, 2 cmd being treated, 3 cmd success, 4 cmd error
  GMEM_CMD_ERROR        = galloc(1); // CMd Error code
  GMEM_RESERVED         = galloc(6);
  GMEM_DUMP_CURVE_BUF   = galloc(CURVESIZE);
  GMEM_LOAD_CURVE_BUF   = galloc(CURVESIZE);
  GMEM_FSET_COUNT       = galloc(1);
  GMEM_FSET_START       = GMEM_PTR;
);

function instanceMemoryMapInit() 
(
  /////////////////////////////////
  // Persistent data (user conf) //
  /////////////////////////////////
  LOADED_VERSION                  = malloc(1);
  
  CONTROL_ENABLED                 = malloc(CONTROL_COUNT);
  CONTROL_SRCS                    = malloc(CONTROL_COUNT);
  CONTROL_DSTS                    = malloc(CONTROL_COUNT);
  CONTROL_HIGHRES_OUTPUT_ENABLED  = malloc(CONTROL_COUNT);  // Per control option
  CURVES                          = malloc(CONTROL_COUNT*CURVESIZE);
  
  KEYBOARD_FILTERING_ENABLED      = malloc(1);
  _OBSOLETE_RESERVED              = malloc(88); // was KEYBOARD_FILTERED_NOTES, now 128 long
  KEYBOARD_TRANSPOSE_ENABLED      = malloc(1);
  KEYBOARD_TRANSPOSE_8VA          = malloc(1);
  KEYBOARD_TRANSPOSE_SEMI_TONES   = malloc(1);
  
  HIGHRES_INPUT_ENABLED           = malloc(1); // Global option              
  DROP_UNROUTED_CC_MESSAGES       = malloc(1); // Global option
  
  /////////////////////////////////
  // Buffers, used for computation
  /////////////////////////////////
  
  // Cosinus and sinus tables for all possible eleven angles
  KNOB_TICS_X                 = malloc(11); // This is not spinal tap... 0..10 == 11 tics!
  KNOB_TICS_Y                 = malloc(11); 
  
  // Curve smoothing buffer
  SCURVE                      = malloc(CURVESIZE);
  
  // Control states memorization
  CONTROL_LAST_IN             = malloc(CONTROL_COUNT);
  CONTROL_LAST_OUT            = malloc(CONTROL_COUNT);
  
  OCTAVE_BLACK_KEY_LOOKUP     = malloc(12);
  OCTAVE_TOP_KEY_WIDTHS       = malloc(12);
  OCTAVE_TOP_KEY_OFFSETS      = malloc(12);
  OCTAVE_LOOKUP_BOTTOM        = malloc(7);
  
  _OBSOLETE_RESERVED          = malloc(88); // was KEY_VELOCITIES, now 128 long
  CC_RECEIVED_VALUES          = malloc(128); 
  
  GUI_MODE                    = malloc(1);
  
  CURRENT_THEME_NUM           = malloc(1);
  
  // Added 3.3
  CONTROL_CHAN_SRCS           = malloc(CONTROL_COUNT);
  CONTROL_CHAN_DSTS           = malloc(CONTROL_COUNT);
  KB_INPUT_CHANNEL            = malloc(1);
  KBG_OUTPUT_CHANNEL          = malloc(1); // Green keys
  KBR_OUTPUT_CHANNEL          = malloc(1); // Red keys
  KEYBOARD_TRANSPOSE_APPLY_TO = malloc(1);
  KEYBOARD_VELOCITY_APPLY_TO  = malloc(1);
  CONTROL_MAXS_MSB            = malloc(CONTROL_COUNT);         
  CONTROL_MAXS_LSB            = malloc(CONTROL_COUNT);
  CONTROL_MINS_MSB            = malloc(CONTROL_COUNT);
  CONTROL_MINS_LSB            = malloc(CONTROL_COUNT);
  DROP_UNROUTED_NOTE_MESSAGES = malloc(1);
  
  // Added 3.4
  CURRENT_FSET                = malloc(1);
  
  // Added 3.5 
  // (these buffers have been extended but for update compatibility reasons
  // old ones are kept in the mem map)
  KEYBOARD_FILTERED_NOTES     = malloc(128);
  KEY_VELOCITIES              = malloc(128);
  CURRENT_OCTAVA_OFFSET       = malloc(1);
);

function initMidiControlNames()
(
  strcpy(0,"Bank Select");
  strcpy(1,"Modulation Wheel");
  strcpy(2,"Breath");
  strcpy(3,"CC 3");
  strcpy(4,"Foot Controller");
  strcpy(5,"Portamento Time");
  strcpy(6,"Data Entry");
  strcpy(7,"Volume");
  strcpy(8,"Balance");
  strcpy(9,"CC 9");
  strcpy(10,"Pan");
  strcpy(11,"Expression");
  strcpy(12,"Effect Controller 1");
  strcpy(13,"Effect Controller 2");
  strcpy(14,"CC 14");
  strcpy(15,"CC 15");
  strcpy(16,"General Purpose Slider 1");
  strcpy(17,"General Purpose Slider 2");
  strcpy(18,"General Purpose Slider 3");
  strcpy(19,"General Purpose Slider 4");
  strcpy(20,"CC 20");
  strcpy(21,"CC 21");
  strcpy(22,"CC 22");
  strcpy(23,"CC 23");
  strcpy(24,"CC 24");
  strcpy(25,"CC 25");
  strcpy(26,"CC 26");
  strcpy(27,"CC 27");
  strcpy(28,"CC 28");
  strcpy(29,"CC 29");
  strcpy(30,"CC 30");
  strcpy(31,"CC 31");
  
  strcpy(32+0,"Bank Select");
  strcpy(32+1,"Modulation Wheel");
  strcpy(32+2,"Breath");
  strcpy(32+3,"CC 3");
  strcpy(32+4,"Foot Controller");
  strcpy(32+5,"Portamento Time");
  strcpy(32+6,"Data Entry");
  strcpy(32+7,"Volume");
  strcpy(32+8,"Balance");
  strcpy(32+9,"CC 14");
  strcpy(32+10,"Pan");
  strcpy(32+11,"Expression");
  strcpy(32+12,"Effect Controller 1");
  strcpy(32+13,"Effect Controller 2");
  strcpy(32+14,"CC 14");
  strcpy(32+15,"CC 15");
  strcpy(32+16,"General Purpose Slider 1");
  strcpy(32+17,"General Purpose Slider 2");
  strcpy(32+18,"General Purpose Slider 3");
  strcpy(32+19,"General Purpose Slider 4");
  strcpy(32+20,"CC 20");
  strcpy(32+21,"CC 21");
  strcpy(32+22,"CC 22");
  strcpy(32+23,"CC 23");
  strcpy(32+24,"CC 24");
  strcpy(32+25,"CC 25");
  strcpy(32+26,"CC 26");
  strcpy(32+27,"CC 27");
  strcpy(32+28,"CC 28");
  strcpy(32+29,"CC 29");
  strcpy(32+30,"CC 30");
  strcpy(32+31,"CC 31");

  strcpy(64,"Damper/Sustain Pedal (Hold1) On/Off");
  strcpy(65,"Portamento On/Off");
  strcpy(66,"Sostenuto On/Off");
  strcpy(67,"Soft Pedal On/Off");
  strcpy(68,"Legato Pedal On/Off");
  strcpy(69,"Damper/Sustain Pedal (Hold2) On/Off");
  strcpy(70,"Sound Variation");
  strcpy(71,"Sound Timbre/Resonance/Harmonics");
  strcpy(72,"Release");
  strcpy(73,"Attack");
  strcpy(74,"Cutoff/Brightness");
  strcpy(75,"Sound Controller 6");
  strcpy(76,"Sound Controller 7");
  strcpy(77,"Sound Controller 8");
  strcpy(78,"Sound Controller 9");
  strcpy(79,"Sound Controller 10");
  strcpy(80,"General Purpose On/Off 1");
  strcpy(81,"General Purpose On/Off 2");
  strcpy(82,"General Purpose On/Off 3");
  strcpy(83,"General Purpose On/Off 4");
  strcpy(83,"General Purpose On/Off 4");
  strcpy(84,"Portamento Amount");
  
  strcpy(88,"Keyboard velocity");
  
  strcpy(91,"Effect 1 Level (Reverb)");
  strcpy(92,"Effect 2 Level (Tremolo)");
  strcpy(93,"Effect 3 Level (Chorus)");
  strcpy(94,"Effect 4 Level (Detune/Celeste)");
  strcpy(95,"Effect 5 Level (Phaser)");
  strcpy(96,"NRPN/RPN Data +1");
  strcpy(97,"NRPN/RPN Data +1");
  strcpy(98,"NRPN LSB");
  strcpy(99,"NRPN MSB");
  strcpy(100,"RPN LSB");
  strcpy(101,"RPN MSB");
);

function initPluginControlNames()
(
  strcpy(128+CONTROL_WHEELS_START+0,"Modulation Wheel");
  
  strcpy(128+CONTROL_PEDALS_START+0,"Pedal Sustain");
  strcpy(128+CONTROL_PEDALS_START+1,"Pedal 2");
  strcpy(128+CONTROL_PEDALS_START+2,"Pedal 3");
  strcpy(128+CONTROL_PEDALS_START+3,"Pedal 4");
  
  strcpy(128+CONTROL_FADERS_START+0,"Fader 1");
  strcpy(128+CONTROL_FADERS_START+1,"Fader 2");
  strcpy(128+CONTROL_FADERS_START+2,"Fader 3");
  strcpy(128+CONTROL_FADERS_START+3,"Fader 4");
  strcpy(128+CONTROL_FADERS_START+4,"Fader 5");
  strcpy(128+CONTROL_FADERS_START+5,"Fader 6");
  strcpy(128+CONTROL_FADERS_START+6,"Fader 7");
  strcpy(128+CONTROL_FADERS_START+7,"Fader 8");
  strcpy(128+CONTROL_FADERS_START+8,"Fader 9");
  strcpy(128+CONTROL_FADERS_START+9,"Fader 10");
  
  strcpy(128+CONTROL_KNOBS_START+0,"Knob 1");
  strcpy(128+CONTROL_KNOBS_START+1,"Knob 2");
  strcpy(128+CONTROL_KNOBS_START+2,"Knob 3");
  strcpy(128+CONTROL_KNOBS_START+3,"Knob 4");
  strcpy(128+CONTROL_KNOBS_START+4,"Knob 5");
  strcpy(128+CONTROL_KNOBS_START+5,"Knob 6");
  strcpy(128+CONTROL_KNOBS_START+6,"Knob 7");
  strcpy(128+CONTROL_KNOBS_START+7,"Knob 8");
  strcpy(128+CONTROL_KNOBS_START+8,"Knob 9");
  strcpy(128+CONTROL_KNOBS_START+9,"Knob 10");
  
  strcpy(128+CONTROL_PADS_START+0,"Pad 1");
  strcpy(128+CONTROL_PADS_START+1,"Pad 2");
  strcpy(128+CONTROL_PADS_START+2,"Pad 3");
  strcpy(128+CONTROL_PADS_START+3,"Pad 4");
  strcpy(128+CONTROL_PADS_START+4,"Pad 5");
  strcpy(128+CONTROL_PADS_START+5,"Pad 6");
  strcpy(128+CONTROL_PADS_START+6,"Pad 7");
  strcpy(128+CONTROL_PADS_START+7,"Pad 8");
  strcpy(128+CONTROL_PADS_START+8,"Pad 9");
  strcpy(128+CONTROL_PADS_START+9,"Pad 10");
  
  strcpy(128+CONTROL_VELOCITY_START+0,"Keyboard velocity");
);

function initOctaveLookups() (
  
  OCTAVE_LOOKUP_BOTTOM[0] = 0; // C
  OCTAVE_LOOKUP_BOTTOM[1] = 2; // D
  OCTAVE_LOOKUP_BOTTOM[2] = 4; // E
  OCTAVE_LOOKUP_BOTTOM[3] = 5; // F
  OCTAVE_LOOKUP_BOTTOM[4] = 7; // G
  OCTAVE_LOOKUP_BOTTOM[5] = 9; // A
  OCTAVE_LOOKUP_BOTTOM[6] = 11; // B
  
  OCTAVE_BLACK_KEY_LOOKUP[ 0] = 0; // C
  OCTAVE_BLACK_KEY_LOOKUP[ 1] = 1; // C#/Db
  OCTAVE_BLACK_KEY_LOOKUP[ 2] = 0; // D
  OCTAVE_BLACK_KEY_LOOKUP[ 3] = 1; // D#/Eb
  OCTAVE_BLACK_KEY_LOOKUP[ 4] = 0; // E
  OCTAVE_BLACK_KEY_LOOKUP[ 5] = 0; // F
  OCTAVE_BLACK_KEY_LOOKUP[ 6] = 1; // F#/Gb
  OCTAVE_BLACK_KEY_LOOKUP[ 7] = 0; // G
  OCTAVE_BLACK_KEY_LOOKUP[ 8] = 1; // G#/Ab     
  OCTAVE_BLACK_KEY_LOOKUP[ 9] = 0; // A
  OCTAVE_BLACK_KEY_LOOKUP[10] = 1; // A#/Bb
  OCTAVE_BLACK_KEY_LOOKUP[11] = 0; // B
  
  OCTAVE_TOP_KEY_WIDTHS[ 0]   = 0.5; // C
  OCTAVE_TOP_KEY_WIDTHS[ 1]   = 1;   // C#/Db
  OCTAVE_TOP_KEY_WIDTHS[ 2]   = 0;   // D
  OCTAVE_TOP_KEY_WIDTHS[ 3]   = 1;   // D#/Eb
  OCTAVE_TOP_KEY_WIDTHS[ 4]   = 0.5; // E
  OCTAVE_TOP_KEY_WIDTHS[ 5]   = 0.5; // F
  OCTAVE_TOP_KEY_WIDTHS[ 6]   = 1;   // F#/Gb
  OCTAVE_TOP_KEY_WIDTHS[ 7]   = 0;   // G
  OCTAVE_TOP_KEY_WIDTHS[ 8]   = 1;   // G#/Ab  
  OCTAVE_TOP_KEY_WIDTHS[ 9]   = 0;   // A
  OCTAVE_TOP_KEY_WIDTHS[10]   = 1;   // A#/Bb
  OCTAVE_TOP_KEY_WIDTHS[11]   = 0.5; // B
  
  OCTAVE_TOP_KEY_OFFSETS[ 0]  = 0;   // C
  OCTAVE_TOP_KEY_OFFSETS[ 1]  = 0.5; // C#/Db
  OCTAVE_TOP_KEY_OFFSETS[ 2]  = 1.5; // D
  OCTAVE_TOP_KEY_OFFSETS[ 3]  = 1.5; // D#/Eb
  OCTAVE_TOP_KEY_OFFSETS[ 4]  = 2.5; // E
  OCTAVE_TOP_KEY_OFFSETS[ 5]  = 3;   // F
  OCTAVE_TOP_KEY_OFFSETS[ 6]  = 3.5; // F#/Gb
  OCTAVE_TOP_KEY_OFFSETS[ 7]  = 4.5; // G
  OCTAVE_TOP_KEY_OFFSETS[ 8]  = 4.5; // G#/Ab 
  OCTAVE_TOP_KEY_OFFSETS[ 9]  = 5.5; // A
  OCTAVE_TOP_KEY_OFFSETS[10]  = 5.5; // A#/Bb
  OCTAVE_TOP_KEY_OFFSETS[11]  = 6.5;   // B
);

function switchToDarkTheme() (

  TH.LIGHTGREEN = 0x80E580;
  TH.MIDGREEN   = 0x20A020;
  TH.LOWGREEN   = 0x10A010;
  
  TH.BACKGROUND          = 0x000000;
  TH.DEFAULT_FONT        = 0xCCCCCC; // Default font color
  
  TH.HEADER              = 0x202066;
  TH.HEADER_TEXT         = TH.DEFAULT_FONT;

  // Enable/Disable button colors (Green/Grey)
  TH.EN_B_ON             = TH.MIDGREEN; // Toggle button on
  TH.EN_B_ON_H           = TH.LIGHTGREEN; // Toggle button on+hover
  TH.EN_B_ON_TEXT        = 0xFFFFFF;
  TH.EN_B_OFF            = 0x303030; // Toggle button off
  TH.EN_B_OFF_H          = 0x606060; // Toggle button off+hover
  TH.EN_B_OFF_TEXT       = TH.DEFAULT_FONT;
  
  // Switch button (Bistate button, but does not change color)
  // Used for changing tabs for example
  TH.SW_B_ON             = 0x202020; 
  TH.SW_B_ON_H           = 0x505050; 
  TH.SW_B_ON_TEXT        = TH.DEFAULT_FONT;
  TH.SW_B_OFF            = 0x202020;
  TH.SW_B_OFF_H          = 0x505050;
  TH.SW_B_OFF_TEXT       = TH.DEFAULT_FONT;
  
  // Mono state button (cannot be toggled)
  TH.MONO_B              = 0x202020; 
  TH.MONO_B_H            = 0x505050;
  TH.MONO_B_TEXT         = 0xAAAAFF; 
  TH.MONO_B_CURVE        = 0xFF5050;
  
  TH.CC_LEARN_ON         = 0x666600;
  TH.CC_LEARN_ON_H       = 0x888800;
  TH.CC_LEARN_ON_TEXT    = 0xFFFF00;
  
  // Dynamic labels (Control information display)
  TH.DYN_LABEL           = 0x8080FF;
  TH.DYN_LABEL_HIGHLIGHT = 0xFFFFFF;
  TH.DYN_LABEL_NEUTRAL   = 0x808080;
  TH.DYN_LABEL_DISABLED  = 0x505050;
  
  // Curve
  TH.CURVE               = 0x6060FF;
  TH.CURVE_BG            = 0x191919;
  TH.CURVE_BG_EXCL       = 0x090909;
  TH.CURVE_GRID          = 0x353535;
  TH.CURVE_BORDER        = 0x474747;
  TH.CURVE_CURRENT_VALUE = 0xFF4040;
  
  // Controls
  TH.CONTROL_HIGHLIGHT              = 0x7070F0;
  TH.CONTROL_HIGHLIGHT_H            = 0xA0A000;
  
  TH.CONTROL_ENABLED_CONTRAST_HIGH  = 0xF0F0F0;
  TH.CONTROL_ENABLED_CONTRAST_MID   = 0xB0B0B0;
  TH.CONTROL_ENABLED_CONTRAST_LOW   = 0x6C6C6C;
  
  TH.CONTROL_DISABLED_CONTRAST_HIGH = 0x505050;
  TH.CONTROL_DISABLED_CONTRAST_MID  = 0x454545;
  TH.CONTROL_DISABLED_CONTRAST_LOW  = 0x202020;
  
  // Edit input lines
  TH.INPUTLINE_BG        = TH.MONO_B;
  TH.INPUTLINE_BG_H      = TH.MONO_B_H;
  TH.INPUTLINE_TEXT      = TH.MONO_B_TEXT;
  
  TH.INPUTLINE_EDIT_BG   = TH.CC_LEARN_ON;
  TH.INPUTLINE_EDIT_BG_H = TH.CC_LEARN_ON_H;
  TH.INPUTLINE_EDIT_TEXT = TH.CC_LEARN_ON_TEXT;
  
  // Function tabs
  TH.TAB_BG     = 0x181818;
  TH.TAB_BG_H   = 0x303030;
  TH.TAB_BG_S   = 0x404040;
  TH.TAB_BG_S_H = 0x505050;
  TH.TAB_TEXT   = 0x909090;
  TH.TAB_TEXT_S = TH.DEFAULT_FONT;
  
  // Src/Dst labels
  TH.ROUTING_INFO_CCNAME = TH.DYN_LABEL;
  TH.ROUTING_INFO_NOT_OK = 0xFF5533;
  TH.ROUTING_INFO_OK     = 0x00FF00;
  
  // Keyboard
  TH.KEY_MARKER_BORDER  = 0x000000;
  TH.KEY_MARKER_BG      = 0xFFFFFF; 
  TH.KEY_BLACK_DISABLED = 0x306030;
  TH.KEY_WHITE_DISABLED = 0x608060;
  
  TH.KEY_WHITE_FILTERED_IN  = TH.LIGHTGREEN;
  TH.KEY_BLACK_FILTERED_IN  = TH.MIDGREEN;
  TH.KEY_BLACK_FILTERED_OUT = 0xB24C4C;
  TH.KEY_WHITE_FILTERED_OUT = 0xE58080;
  
  TH.KEY_OCTAVA_NUMBER = 0x303030;
);

function switchToLightTheme() (

  TH.LIGHTGREEN = 0x50D050;
  TH.MIDGREEN   = 0x20A020;
  TH.LOWGREEN   = 0x10A010;
  
  TH.BACKGROUND          = 0xE0E0E0;
  TH.DEFAULT_FONT        = 0x101010; // Default font color
  
  TH.HEADER              = 0xC0C0C0;
  TH.HEADER_TEXT         = TH.DEFAULT_FONT;

  // Enable/Disable button colors (Green/Grey)
  TH.EN_B_ON             = TH.MIDGREEN; // Toggle button on
  TH.EN_B_ON_H           = TH.LIGHTGREEN; // Toggle button on+hover
  TH.EN_B_ON_TEXT        = 0xFFFFFF;
  TH.EN_B_OFF            = 0xA0A0A0; // Toggle button off
  TH.EN_B_OFF_H          = 0xD0D0D0; // Toggle button off+hover
  TH.EN_B_OFF_TEXT       = TH.DEFAULT_FONT;
  
  // Switch button (Bistate button, but does not change color)
  // Used for changing tabs for example
  TH.SW_B_ON             = 0xA0A0A0; 
  TH.SW_B_ON_H           = 0xD0D0D0; 
  TH.SW_B_ON_TEXT        = TH.DEFAULT_FONT;
  TH.SW_B_OFF            = 0xA0A0A0;
  TH.SW_B_OFF_H          = 0xD0D0D0;
  TH.SW_B_OFF_TEXT       = TH.DEFAULT_FONT;
  
  // Mono state button (cannot be toggled)
  TH.MONO_B              = 0xA0A0A0; 
  TH.MONO_B_H            = 0xD0D0D0;
  TH.MONO_B_TEXT         = 0xFFFFFF; 
  TH.MONO_B_CURVE        = 0xFF2020;
  
  TH.CC_LEARN_ON         = 0x666600;
  TH.CC_LEARN_ON_H       = 0x888800;
  TH.CC_LEARN_ON_TEXT    = 0xFFFF00;
  
  // Dynamic labels (Control information display)
  TH.DYN_LABEL           = 0x6060FF;
  TH.DYN_LABEL_HIGHLIGHT = 0x000000;
  TH.DYN_LABEL_NEUTRAL   = 0x808080;
  TH.DYN_LABEL_DISABLED  = 0x505050;
  
  // Curve
  TH.CURVE               = 0x6060FF;
  TH.CURVE_BG            = 0x393939;
  TH.CURVE_BG_EXCL       = 0x292929;
  TH.CURVE_GRID          = 0x555555;
  TH.CURVE_BORDER        = 0x676767;
  TH.CURVE_CURRENT_VALUE = 0xFF4040;
  
  // Controls
  TH.CONTROL_HIGHLIGHT              = 0xC7C7FF;
  TH.CONTROL_HIGHLIGHT_H            = 0xA0A000;
  
  TH.CONTROL_ENABLED_CONTRAST_HIGH  = 0xA0A0A0;//0xF0F0F0;
  TH.CONTROL_ENABLED_CONTRAST_MID   = 0x707070;//0x909090;
  TH.CONTROL_ENABLED_CONTRAST_LOW   = 0x606060;//0x4C4C4C;
  
  TH.CONTROL_DISABLED_CONTRAST_HIGH = 0xD3D3D3;
  TH.CONTROL_DISABLED_CONTRAST_MID  = 0xD3D3D3;
  TH.CONTROL_DISABLED_CONTRAST_LOW  = 0xC7C7C7;
  
  // Edit input lines
  TH.INPUTLINE_BG        = TH.MONO_B;
  TH.INPUTLINE_BG_H      = TH.MONO_B_H;
  TH.INPUTLINE_TEXT      = TH.MONO_B_TEXT;
  
  TH.INPUTLINE_EDIT_BG   = TH.CC_LEARN_ON;
  TH.INPUTLINE_EDIT_BG_H = TH.CC_LEARN_ON_H;
  TH.INPUTLINE_EDIT_TEXT = TH.CC_LEARN_ON_TEXT;
  
  // Function tabs
  TH.TAB_BG     = TH.MONO_B;
  TH.TAB_BG_H   = TH.MONO_B_H;
  TH.TAB_BG_S   = 0xC0C0C0;
  TH.TAB_BG_S_H = 0xD0D0D0;
  TH.TAB_TEXT   = TH.MONO_B_TEXT;
  TH.TAB_TEXT_S = 0xFFFFFF;
  
  // Src/Dst labels
  TH.ROUTING_INFO_CCNAME = TH.DYN_LABEL;
  TH.ROUTING_INFO_NOT_OK = 0xFF0000;
  TH.ROUTING_INFO_OK     = 0x008F00;
  
  // Keyboard
  TH.KEY_MARKER_BORDER  = 0x000000;
  TH.KEY_MARKER_BG      = 0xFFFFFF; 
  TH.KEY_BLACK_DISABLED = 0x70A070;
  TH.KEY_WHITE_DISABLED = 0x90C090;
  
  TH.KEY_WHITE_FILTERED_IN  = TH.LIGHTGREEN;
  TH.KEY_BLACK_FILTERED_IN  = TH.MIDGREEN;
  TH.KEY_BLACK_FILTERED_OUT = 0xB24C4C;
  TH.KEY_WHITE_FILTERED_OUT = 0xE58080;
  
  TH.KEY_OCTAVA_NUMBER = 0x505050;
);


////////////////////////
// FUNCTION SET TOOLS //
////////////////////////

// Applies a curve from gmem
function applyGmemCurve(curve_address, x01) 
  local(x01, sample_num_f, sample_num_il, sample_num_ir, sample_l, sample_r, curve_interp, alpha)
( 
  // Do some clamping cleanup first
  x01 = min(max(x01,0),1);
  
  // Normalize reference space > Curve space
  sample_num_f  = 127 * x01;
  sample_num_il = floor(sample_num_f);
  sample_num_ir = ceil(sample_num_f);
  
  // Get left sample, right sample, and linear interpolation factor
  sample_l      = gmem[curve_address+sample_num_il];
  sample_r      = gmem[curve_address+sample_num_ir];
  alpha         = sample_num_f - sample_num_il;
  
  // Lerp : this will return a value between 0 and 127
  curve_interp  = (1-alpha) * sample_l + alpha * sample_r;

  // Return a value between 0 and 1.
  (curve_interp);
);

function putStringInGmem(gmem_start_index, gmem_slots, str)
  local(slen, max_len, i, si, bi, c)
(
  // Limit to 32 bits to avoid problems on old architectures.
  slen    = strlen(str);        // We want to add \0
  max_len = gmem_slots * 4 - 1; // Keep one byte for \0

  si = 0;
  while(si < gmem_slots)
  (
    gmem[gmem_start_index + si] = 0;
    si += 1;
  );

  i = 0; bi = 0; si = gmem_start_index;
  while(i<slen && i<max_len)
  (
    c = str_getchar(str,i);
    
    // Write byte.
    gmem[si] = gmem[si] | (c<<bi);
    
    i   += 1;
    bi  += 8;
    (bi==32)?(
      bi = 0;
      si += 1;
    );
  );
);

function getStringFromGmem(gmem_start_index, gmem_slots)
  local(c, max_len, i, bi, si, str)
(
  // Beware! It's specified in the doc that the string
  // Initial value may be unpredictable. Initialize it!
  str = #; strcpy(str,"");

  max_len = gmem_slots * 4; // Keep one byte for \0
   
  i = 0; bi = 0; si = gmem_start_index; c = 1;

  while(i<max_len && c!=0)
  (
    c = (gmem[si]>>bi) & 0xFF;
  
    (c!=0)?(
      str_setchar(str,i,c);
    );
    
    i   += 1;
    bi  += 8;
    (bi==32)?(
      bi = 0;
      si += 1;
    );
  );

  str;
);

function getFSetAddress(set_num) (
  GMEM_FSET_START + (FSET_SIZE * set_num);
);
function getFSetCount() (
  gmem[GMEM_FSET_COUNT];
);

function getFSetId(set_num) (
  getStringFromGmem(getFSetAddress(set_num) + FSET_OFFSET_ID, FSET_ID_MAXSLOT);
);
function getFSetTab(set_num) (
  getStringFromGmem(getFSetAddress(set_num) + FSET_OFFSET_TAB, FSET_TAB_MAXSLOT);
);
function getFSetDescription(set_num) (
  getStringFromGmem(getFSetAddress(set_num) + FSET_OFFSET_DESC, FSET_DESC_MAXSLOT);
);

function isFSetParametric(set_num) (
 (gmem[getFSetAddress(set_num) + FSET_OFFSET_IS_PARAMETRIC] == 1);
);
function setFSetIsParametric(set_num, v) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_IS_PARAMETRIC] = v;
);
function getFSetParametricID(set_num) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_PARAMETRIC_ID];
);
function setFSetParametricID(set_num, id) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_PARAMETRIC_ID] = id;
);
function getFSetParameter(set_num) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_PARAM];
);
function setFSetParameter(set_num, param) (
  gmem[getFSetAddress(set_num) + FSET_OFFSET_PARAM] = param;
);


function getFSetFunctionAddress(set_num, row_num, col_num) (
  getFSetAddress(set_num) + FSET_OFFSET_FUNCTIONS + FSF_SIZE * (row_num * FSET_COL_COUNT + col_num);
);
function getFSetFunctionCurveAddress(set_num, row_num, col_num) (
  getFSetFunctionAddress(set_num, row_num, col_num) + FSF_OFFSET_CURVE;
);
function getFSetFunctionPreviewAddress(set_num, row_num, col_num) (
  getFSetFunctionAddress(set_num, row_num, col_num) + FSF_OFFSET_PREVIEW;
);
function isFSetFunctionDefined(set_num, row_num, col_num) (
  (gmem[getFSetFunctionAddress(set_num, row_num, col_num) + FSF_OFFSET_DEFINED] == 1);
);
function setFSetFunctionDefined(set_num, row_num, col_num, is_defined)(
  gmem[getFSetFunctionAddress(set_num, row_num, col_num) + FSF_OFFSET_DEFINED] = is_defined;
);


function findFSetById(set_id)
  local(s,sn,si,found,fset_addr)
(
  s = #;
  strncpy(s,set_id,FSET_ID_MAXLEN); // Limit to 4 chars      

  si    = 0;
  found = -1;
  
  while(si<gmem[GMEM_FSET_COUNT] && found == -1)
  (
  
    fset_addr = getFSetAddress(si);
    sn        = getStringFromGmem(fset_addr + FSET_OFFSET_ID, 2);
    
    (strcmp(sn,s) == 0)?(
      found = si;
    );
    
    si += 1;
  );
  
  found;
);

function createFSet(fset_id, fset_tab, fset_desc) 
  local(fset_addr, fset_num, s, mi)
(
  // Allocate set
  fset_addr     = galloc(FSET_SIZE);
 
  // Update counts
  fset_num = gmem[GMEM_FSET_COUNT];
  gmem[GMEM_FSET_COUNT] += 1;
  
  // Nullify everything. Full memory cleanup.
  mi = 0;
  while(mi < FSET_SIZE) (
    gmem[fset_addr+mi]=0;
    mi+=1;
  );
  
  // Initialize name/tab/desc limit to max chars  
  s = #;
  strncpy(s, fset_id, FSET_ID_MAXLEN);     
  putStringInGmem(fset_addr + FSET_OFFSET_ID, FSET_ID_MAXSLOT, s);
  strncpy(s, fset_tab, FSET_TAB_MAXLEN);     
  putStringInGmem(fset_addr + FSET_OFFSET_TAB, FSET_TAB_MAXSLOT, s);  
  strncpy(s,fset_desc, FSET_DESC_MAXLEN);
  putStringInGmem(fset_addr + FSET_OFFSET_DESC, FSET_DESC_MAXSLOT, s);
  
  fset_num;
);

function getCurrentFSet() (
  CURRENT_FSET[0];
);
function setCurrentFSet(set_num) (
  CURRENT_FSET[0] = set_num;
);

function getParametricFSetParamRounding(pid) (
  (pid == FSET_PARAMETRIC_XN_ID || pid == FSET_PARAMETRIC_EXPNX_ID)?(
    5;
  ):(
    1;
  );
);

function getParametricFSetParameterName(pid) 
  local(param_label)
(
  // Draw slider
  param_label = "";
  
  (pid == FSET_PARAMETRIC_LINEAR_ID)?(param_label = "Cut");
  (pid == FSET_PARAMETRIC_EXPNX_ID)?(param_label = "N");
  (pid == FSET_PARAMETRIC_XN_ID)?(param_label = "N");
  
  param_label;
);

function getParametricFSetParameterMin(pid) 
  local(mv)
(
  mv = 0;
  
  (pid == FSET_PARAMETRIC_LINEAR_ID)?(mv = 0);
  (pid == FSET_PARAMETRIC_EXPNX_ID)?(mv = 1);
  (pid == FSET_PARAMETRIC_XN_ID)?(mv = 1);
  
  mv;
);

function getParametricFSetParameterMax(pid) 
  local(mv)
(
  mv = 0;
  
  (pid == FSET_PARAMETRIC_LINEAR_ID)?(mv = 1);
  (pid == FSET_PARAMETRIC_EXPNX_ID)?(mv = 10);
  (pid == FSET_PARAMETRIC_XN_ID)?(mv = 10);
  
  mv;
);


/////////////////////
//  Parsing tools  //
/////////////////////

function isBlankChar(char) 
(
  (char == 0x20 || char == 0x0A || char == 0x0D || char == 0x09);
);


// Call on a ctx
function FSCTX_EatBlank()
  local(is_space, c)
(
  is_space = 1;
  
  while(is_space && this.cursor < this.len)
  (
    c         = str_getchar(this.str, this.cursor);
    is_space  = isBlankChar(c);
    (is_space)?(
      this.cursor += 1;
    );
  );
);

// Call on a ctx
function FSCTX_NextChar()
(
  str_getchar(this.str, this.cursor);
);

// Call on a ctx
function FSCTX_AtEnd()
(
  (this.cursor >= this.len);
);

// Call on a ctx
function FSCTX_EatNextToken()
  local()
(
  ctx.tok_start = this.cursor;
  
  // 0x7C == '|', it's the pipe character
  while(!ctx.FSCTX_AtEnd() && ctx.FSCTX_NextChar() != 0x7C)
  (
    this.cursor += 1;
  );
  
  ctx.tok_len = this.cursor - ctx.tok_start;
  
  // Also eat separator
  (ctx.FSCTX_NextChar() == 0x7C)?(
    this.cursor += 1;
  )
);

function FSCTX_BuildFromLine(str)
  local(c, trimmed)
(
  this.str    = str;
  this.len    = strlen(str);
  this.cursor = 0;
  
  // Trim the line end
  (this.len > 0)?(
  
    trimmed = 0;
    while(this.len > 0 && !trimmed)
    (
      c = str_getchar(this.str, this.len-1);
      (isBlankChar(c))?(
        this.len -= 1;
      ):(
        trimmed = 1;
      );
    );
  );
  
  // Trim the line start
  this.FSCTX_EatBlank();
);

function FSCTX_ReadLibParam(p)
(
  (this.FSCTX_AtEnd())?(
    // Refuse to read
    strcpy(p,"");
    -1;
  ):(
    this.FSCTX_EatNextToken();
    strcpy_substr(p,this.str,this.tok_start,this.tok_len);
    this.tok_len;
  );
);

function precalcFSetFunctionPreview(set_num, row_num, col_num)
  local(vi, off, curve_addr, preview_addr)
(
  vi = 0;
  curve_addr    = getFSetFunctionCurveAddress(set_num, row_num, col_num);
  preview_addr  = getFSetFunctionPreviewAddress(set_num, row_num, col_num);
  while(vi < PREVIEWSIZE)
  (
    // off = curve_addr + 4*vi;
    //gmem[preview_addr+vi] = (gmem[off] + gmem[off+1] + gmem[off+2] + gmem[off+3])/(4);
    gmem[preview_addr+vi] = applyGmemCurve(curve_addr, vi/(PREVIEWSIZE-1));
    vi += 1;
  );
);

function addFunctionToFSet(set_num, row_num, col_num, func_path)
  local(handle, ctx, set_addr, curve_addr, preview_addr, set_name, val, vcount, vi, fname, cnum, p1, str)
(
  set_addr = getFSetAddress(set_num);
  
  fname = #;
  sprintf(fname,"talagan_MIDI CC Mapper X/func/%s.txt",func_path);
  
  handle = file_open(fname);
    
  (handle != -1)?(
    vcount = 0;
  
    while(file_avail(handle)>0)
    (
      str = #;
      file_string(handle,str);
    
      ctx = 0;
      ctx.FSCTX_BuildFromLine(str);
    
      // Coments are available through # or @, ignore these lines.
      // Also ignore blank lines.
      // (reapack uses @ for some directives).
      (!ctx.FSCTX_AtEnd() && ctx.FSCTX_NextChar() != 0x23 && ctx.FSCTX_NextChar() != 0x40)?(
      
        p1 = #;
        ctx.FSCTX_ReadLibParam(p1);
        match("%f",p1,val);
      
        (vcount < CURVESIZE)?(
          gmem[GMEM_LOAD_CURVE_BUF + vcount] = val;
        );
      
        vcount += 1;
      );
    );
  
    (vcount == CURVESIZE)?(
  
      // File is OK, accept curve
      // Copy to destination.
      vi         = 0;
      curve_addr = getFSetFunctionCurveAddress(set_num, row_num, col_num);
      
      while(vi < CURVESIZE)
      (
        // Copy
        gmem[curve_addr+vi] = gmem[GMEM_LOAD_CURVE_BUF+vi];
        vi+=1;
      );
      
      precalcFSetFunctionPreview(set_num, row_num, col_num);
      setFSetFunctionDefined(set_num, row_num, col_num, 1);
    );
  
    file_close(handle);
  );
);

function xn(x01,n) (
  pow(x01,n);
);
function ixn(x01,n) (
  pow(x01, 1.0/n);
);
function expnx(x01,n) (
  (exp(n * x01) - 1)/(exp(n)-1);
);
function iexpnx(x01, n) (
  log( x01 * (exp(n) - 1) + 1)/n;
);

function xf(pid, x01, n) (
  (pid == FSET_PARAMETRIC_XN_ID)?(xn(x01,n)):(expnx(x01,n));
);
function ixf(pid, x01, n) (
  (pid == FSET_PARAMETRIC_XN_ID)?(ixn(x01,n)):(iexpnx(x01,n));
);

function xfStepBL(pid, x01, n) (
  (x01 <= 0.5)?(
    x01 = 2 * x01;
    xf(pid, x01 , n)/2;
  ):(
    x01 = 2 * (1 - x01);
    1 - xf(pid, x01, n)/2;
  );
);

function xfStepBR(pid, x01, n) (
  (x01 <= 0.5)?(
    x01 = 2 * x01;
    (1 - ixf(pid, 1 - x01, n))/2;
  ):(
    x01 = 2 * (1 - x01);
    1 - (1 - ixf(pid, 1 - x01, n))/2;
  );
);

function xfStepTR(pid, x01, n) (
  (x01 <= 0.5)?(
    x01 = 2 * x01;
    (1 - xf(pid, 1 - x01, n))/2;
  ):(
    x01 = 2 * (1 - x01);
    1 - (1 - xf(pid, 1 - x01, n))/2;
  );
);

function xfStepTL(pid, x01, n) (
  (x01 <= 0.5)?(
    ixf(pid, 2 * x01, n)/2;
  ):(
    1 - ixf(pid, 2 * (1 - x01), n)/2;
  );
);

function xnExpnxFamilyVal(pid, row_num, col_num, x01, n, point_count) 
  local(ret)
(
  ret = -1;
  (row_num == 0)?(
    (col_num == 0)?(
      ret = xf(pid, x01, n);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = xf(pid, x01, n);
    );
    (col_num == 3)?(
      x01 = 1 - x01;
      ret = 1 - ixf(pid, x01, n);
    );
    (col_num == 4)?(
      ret = 1 - ixf(pid, x01, n); 
    );
  );
  (row_num == 1)?(
    (col_num == 0)?(
      x01 = 1 - x01;
      ret = 1 - xf(pid, x01, n);
    );
    (col_num == 1)?(
      ret = 1 - xf(pid, x01, n);
    );
    (col_num == 3)?(
      ret = ixf(pid, x01, n);
    );
    (col_num == 4)?(
      x01 = 1 - x01;
      ret = ixf(pid, x01, n);
    );
  );
  (row_num == 2)?(
    (col_num == 0)?(
      ret = xfStepBL(pid, x01, n);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = xfStepBL(pid, x01, n);
    );
    (col_num == 3)?(
      ret = xfStepBR(pid, x01, n);
    );
    (col_num == 4)?(
      x01 = 1 - x01;
      ret = xfStepBR(pid, x01, n);
    );
  );
  (row_num == 3)?(
    (col_num == 0)?(
      ret = xfStepTR(pid, x01, n);
    );
    (col_num == 1)?(
      x01 = 1 - x01;
      ret = xfStepTR(pid, x01, n);
    );
  
    (col_num == 3)?(
      ret = xfStepTL(pid, x01, n);
    );
    (col_num == 4)?(
      x01 = 1 - x01;
      ret = xfStepTL(pid, x01, n);
    );
  );
  (row_num == 4)?(
    (col_num == 0)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        xf(pid, 1 - x01, n);
      ):(
        x01 = 2 * (1 - x01);
        xf(pid, 1 - x01, n);
      );
    );
    (col_num == 1)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        1 - xf(pid, 1 - x01, n);
      ):(
        x01 = 2 * (1 - x01);
        1 - xf(pid, 1 - x01, n);
      );
    );
    (col_num == 2)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        xfStepBL(pid, x01, n);
      ):(
        x01 = 2 * (1 - x01);
        xfStepBL(pid, x01, n);
      );
    );
    (col_num == 3)?(
      ret = (x01 <= 0.5)?(
        x01 = 2 * x01;
        1 - xfStepBL(pid, x01, n);
      ):(
        x01 = 2 * (1 - x01);
        1 - xfStepBL(pid, x01, n);
      );
    );
  );
  ret;
);

function linFamilyVal(row_num, col_num, x01, cut, point_count) 
  local(ret, granu)
(
  // Because we generate some discontinuous functions
  // Handle special cases where the "cut" param is very close to 0 or 1
  granu = 1/(point_count-1);
  (cut != 0 && cut !=1)?(
    (cut < granu)?(
      // Force rounding to first non-zero slot
      cut = granu; 
    ):(
      (cut > (1 - granu))?(
        // Force rounding to last non-1 slot
        cut = 1-granu; 
      ):(
        // Round to closest slot
        cut = granu * roundi(cut*(point_count-1));
      );
    );
  );
  
  ret = -1;
  (row_num == 0)?(
  
    (col_num == 0)?(
      ret = x01;
    );
    (col_num == 1)?(
      ret = 1 - x01;
    );
  );
  
  (row_num == 1)?(
    (col_num == 0)?(
      ret = (cut == 0)?(1):( (x01<=cut)?(x01/cut):(1));
    );
    (col_num == 1)?(
      ret = (cut == 1)?(1):( (x01<=cut)?(1):(1 - (x01-cut)/(1-cut)));
    );
    (col_num == 2)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = (x01 < cut)?( x01/cut ):( (x01 > 1 - cut)?( (1 - x01)/cut ):( 1 ) );
    );
    (col_num == 3)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = ( (x01 < cut || x01 > (1-cut) )?(0):(1));
    );
    (col_num == 4)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = (x01 < cut)?(0):( (x01 > 1 - cut)?(1):( (x01-cut)/(1-2*cut)));
    ); 
    (col_num == 5)?(
      ret = (cut == 1)?(0):( (x01<cut)?(0):(1));
    );
  );
  
  (row_num == 2)?(
    (col_num == 1)?(
      ret = (x01>=cut)?((x01-cut)/(1-cut)):(0);
    );
    (col_num == 0)?(
      ret = (cut == 0)?(0):( (x01<=cut)?(1-(x01/cut)):(0) );
    );
    (col_num == 2)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = 1 -((x01 < cut)?( x01/cut ):( (x01 > 1 - cut)?( (1 - x01)/cut ):( 1 )));
    ); 
    (col_num == 3)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = ( (x01 < cut || x01 > (1-cut) )?(1):(0));
    );     
    (col_num == 4)?(
      (cut > 0.5)?(cut = 1 - cut);
      ret = 1 - ((x01 < cut)?(0):( (x01 > 1 - cut)?(1):( (x01-cut)/(1-2*cut))));
    ); 
    (col_num == 5)?(
      ret = (cut == 1)?(1):( (x01>=cut)?(0):(1));
    );   
  );
  
  (row_num == 3)?(
  
    (col_num == 0)?(
      ret = (cut == 0)?(0):( (x01<=cut)?(x01/cut):(0));
    );
    (col_num == 1)?(
      ret = (cut == 1)?(0):( (x01>=cut)?(1 - (x01-cut)/(1-cut)):(0));
    );
    (col_num == 2)?(
      ret = (cut == 0)?(0):( (x01<=cut)?(x01):(0));
    );
    (col_num == 3)?(
      ret = (cut == 1)?(0):( (x01>=cut)?(1-x01):(0));
    );
    (col_num == 4)?(
      ret = (cut == 1)?(0):( (x01>=cut)?(x01):(0));
    );
    (col_num == 5)?(
      ret = (cut == 0)?(0):( (x01<=cut)?(1-x01):(0));
    );
  );
  
  (row_num == 4)?(
    (col_num == 0)?(
      ret = 1 - ((cut == 0)?(0):( (x01<=cut)?(x01/cut):(0)));
    );
    (col_num == 1)?(
      ret = 1 - ((cut == 1)?(0):( (x01>=cut)?(1 - (x01-cut)/(1-cut)):(0)));
    );
    (col_num == 2)?(
      ret = 1 - ((cut == 0)?(0):( (x01<=cut)?(x01):(0)));
    );
    (col_num == 3)?(
      ret = 1 - ((cut == 1)?(0):( (x01>=cut)?(1-x01):(0)));
    );
    (col_num == 4)?(
      ret = 1 - ((cut == 1)?(0):( (x01>=cut)?(x01):(0)));
    );
    (col_num == 5)?(
      ret = 1 - ((cut == 0)?(0):( (x01<=cut)?(1-x01):(0)));
    );
  );
  
  ret;
);

function parametricSetVal(pid, row_num, col_num, x01, n, point_count) (
  (pid == FSET_PARAMETRIC_XN_ID || pid == FSET_PARAMETRIC_EXPNX_ID)?(
    xnExpnxFamilyVal(pid, row_num, col_num, x01, n, point_count);
  ):(
    linFamilyVal(row_num, col_num, x01, n, point_count);
  );
);

function precalcParametricSet(set_num)
  local(pid, ri, ci, si, param, x01, func_address, preview_address)
(
  param = getFSetParameter(set_num);
  pid   = getFSetParametricID(set_num);
    
  ri = 0;
  while(ri < FSET_ROW_COUNT) 
  (
    ci = 0;
    while(ci < FSET_COL_COUNT) 
    (
      // Calculate value at 0. If -1, the col/row is not supported.
      (parametricSetVal(pid, ri, ci, 0, param, CURVESIZE) != -1)?(
      
        func_address = getFSetFunctionCurveAddress(set_num, ri, ci);
        si = 0;
        
        while(si < CURVESIZE) 
        (  
          x01 = si/(CURVESIZE - 1);
          gmem[func_address + si] = parametricSetVal(pid, ri, ci, x01, param, CURVESIZE);
          si += 1;
        );  

        // NO! Use fine-grained computation instead
        // Previews of discontinuous functions are cleaner
        // If computed directly with the equations
        // precalcFSetFunctionPreview(set_num, ri, ci);
        
        preview_address = getFSetFunctionPreviewAddress(set_num, ri, ci);
           
        si = 0;   
        while(si < PREVIEWSIZE) 
        (  
          x01 = si/(PREVIEWSIZE - 1);
          gmem[preview_address + si] = parametricSetVal(pid, ri, ci, x01, param, PREVIEWSIZE);
          si += 1;
        );  
        
        setFSetFunctionDefined(set_num, ri, ci, 1);
      );
      ci += 1;
    );
    ri += 1;
  );
);

function createLinearParametricFSet()
  local(set_num)
(
  set_num = createFSet("|lin|",   "Linear",   "Parametric linear fset");  
  setFSetIsParametric(set_num,1);
  setFSetParametricID(set_num, FSET_PARAMETRIC_LINEAR_ID);
  setFSetParameter(set_num, 0.5);
  precalcParametricSet(set_num);       
);
     
function createExpNXParametricFSet()
  local(set_num)
(
  set_num = createFSet("|expnx|", "exp(n.x)", "Parametric exp(n^x) fset");
  setFSetIsParametric(set_num,1);
  setFSetParametricID(set_num, FSET_PARAMETRIC_EXPNX_ID);
  setFSetParameter(set_num, 2);
  precalcParametricSet(set_num);        
);

function createXNParametricFset()
  local(set_num)
(
  set_num = createFSet("|xn|",    "x^n",      "Parametric x^n fset");
  setFSetIsParametric(set_num,1);
  setFSetParametricID(set_num, FSET_PARAMETRIC_XN_ID);
  setFSetParameter(set_num, 2);
  precalcParametricSet(set_num);       
);        

function readLibFile(lib_name) 
  local(handle, lc, str, fset_num, p1, p2, p3, p4, p5, p6, row_num, col_num, file_ok)
(
  handle  = file_open(lib_name);
  file_ok = (handle != -1);

  lc = 0;
  
  while(file_avail(handle)>0)
  (
    str = #;
    file_string(handle,str);
    
    ctx = 0;
    ctx.FSCTX_BuildFromLine(str);
    
    // Coments are available through # or @ 
    // (reapack uses @ for some directives)
    (!ctx.FSCTX_AtEnd() && ctx.FSCTX_NextChar() != 0x23 && ctx.FSCTX_NextChar() != 0x40)?(

      // Ok, this is a non commented line.
      // Check it.
      p1 = #; p2 = #; p3 = #; p4 = #; p5 = #; p6 = #;
      
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p1));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p2));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p3));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p4));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p5));
      (!ctx.FSCTX_AtEnd())?(ctx.FSCTX_ReadLibParam(p6));
      
      (strcmp(p1, "addpset") == 0)?(
  
        (strcmp(p2,"linear") == 0)?(
          createLinearParametricFSet();
        );
        
        (strcmp(p2,"expnx") == 0)?(
          createExpNXParametricFSet();
        );
        
        (strcmp(p2,"xn") == 0)?(
          createXNParametricFset();
        );
      );
      
      (strcmp(p1, "addset") == 0)?(
        (strlen(p2)>0)?(           
          fset_num = findFSetById(p2);
          (fset_num == -1)?(
            createFSet(p2, p3, p4);
          );
        );
      );
  
      (strcmp(p1, "addfunc") == 0)?(
        // p2 : set 
        // p3 : row 
        // p4 : col 
        // p5 : subpath
        (strlen(p2)>0 && strlen(p3)>0 && strlen(p4)>0 && strlen(p5)>0)?(
        
          fset_num = findFSetById(p2);
          (fset_num != -1)?(
            
            row_num = 0;
            col_num = 0;
            match("%d",p3,row_num);
            match("%d",p4,col_num);
                                    
            (row_num >= 1 && row_num <= FSET_ROW_COUNT && col_num >= 1 && col_num <= FSET_COL_COUNT)?(
              row_num -= 1; // Human > Index
              col_num -= 1; // Human > Index
              
              addFunctionToFset(fset_num, row_num, col_num, p5);
            );
          );
        );
      );
       
    );
    
    lc+=1;
  );
  file_Close(handle);
  
  (file_ok);
);

function clearLoadedLibs()
(
  gmem[GMEM_FSET_COUNT] = 0;
  GMEM_PTR              = GMEM_FSET_START;
  setCurrentFSet(-1);
);

function readLibFiles() 
  local(success)
(
  clearLoadedLibs();
   
  success = readLibFile("talagan_MIDI CC Mapper X/user_lib.txt");
  (!success)?(
    readLibFile("talagan_MIDI CC Mapper X/lib.txt");
  );
  
  (getFsetCount()>0)?(
    setCurrentFSet(0);
  );
);


/////////////////////////
//    MEMORY ACCESS    //
/////////////////////////

function curveAddress(cnum)
(
  (cnum <0 || cnum >= CONTROL_COUNT)?(-1):(
    CURVES + (cnum * CURVESIZE)
  );
);

function shouldDropUnroutedCCMessages() (
  (DROP_UNROUTED_CC_MESSAGES[0] == 1);
);

function shouldDropUnroutedNoteMessages() (
  (DROP_UNROUTED_NOTE_MESSAGES[0] == 1);
);

function isKeyboardFilteringEnabled() (
  (KEYBOARD_FILTERING_ENABLED[0] == 1);
);

function isKeyboardTranspositionEnabled() (
  (KEYBOARD_TRANSPOSE_ENABLED[0] == 1);
);

function isRedKey(k) (
  (KEYBOARD_FILTERED_NOTES[k]==1)
);


/////////////////////////
//        MATH         //
/////////////////////////

// Applies a curve, returns a value from 0 to 1.

function applyCurve(blk_control, x01) 
  local(attached_curve, x01, sample_num_f, sample_num_il, sample_num_ir, sample_l, sample_r, curve_interp, alpha)
(
  attached_curve = curveAddress(blk_control);
  
  // Do some clamping cleanup first
  x01 = min(max(x01,0),1);
  
  // Normalize reference space > Curve space
  sample_num_f  = 127 * x01;
  sample_num_il = floor(sample_num_f);
  sample_num_ir = ceil(sample_num_f);
  
  // Get left sample, right sample, and linear interpolation factor
  sample_l      = attached_curve[sample_num_il];
  sample_r      = attached_curve[sample_num_ir];
  alpha         = sample_num_f - sample_num_il;
  
  // Lerp : this will return a value between 0 and 127
  curve_interp  = (1-alpha) * sample_l + alpha * sample_r;

  // Return a value between 0 and 1.
  (curve_interp/127.0);
);

//////////////////////
//       MIDI       //
//////////////////////

g_hres_h = 0;
g_hres_l = 0;

// Converts a floating value of a CC **between 0 and 1**
// To high/low parts of a 14-bit hres
// For CC #0 to #31 (with respective #32 to #63).
function midiCCHresF012I(f01) 
  local(ival) 
(  
  // Clamp to 0..1 for safety
  f01  = max(min(f01,1),0);
  
  // Convert to 14-bit space
  ival = roundi(f01 * 16383);
  
  // Floor to int for the high part
  g_hres_h  = (ival >> 7);
  g_hres_l  = ival & 0x7F;
);

// Inverse of midiCCHresF012I
function midiCCHresI2F01(high,low)
  local(val01, high, low, ival)
(
  
  // Sanitize
  high = max(min(high,127),0);
  low  = max(min(low,127),0);
  
  // 14-bit value
  ival = (high << 7) + low;
  
  // Put it in 0-1 space
  val01 = ival/16383;
);

// Converts a floating value of a key velocity **between 0 and 1**
// To high/low parts of a 14-bit hres
//
// Specification for this
// https://forum.cockos.com/showthread.php?t=83782
function midiVelocityHresF012I(f01) 
  local(ival) 
(
  
  // Clamp to 0..1 for safety
  f01  = max(min(f01,1),0);

  // Convert to 14-bit space
  // Caution : only 16256+1 values are possible (127*128 non zero values + the zero case)
  // (All LSB values for MSB=0 NOTE OFF are not allowed)
  ival = roundi(f01 * 16256);
  
  (ival==0)?(
    g_hres_h = 0;
    g_hres_l = 0;
  ):(
    // ival is in [1..16256] so put it in [0..16255]
    ival -= 1; 
    // Floor to int for the high part
    // Add 1 for NOTE_ON
    g_hres_h  = (ival >> 7)+1;
    g_hres_l  = ival & 0x7F;
  )
);

// Inverse of midiVelocityHresF012I
function midiVelocityHresI2F01(high,low) 
  local(val01, ival) 
(

  // Sanitize
  high = max(min(high,127),0);
  low  = max(min(low,127),0);
    
  high==0?(
    // If high is equal to 0
    // Low = 0 is not allowed for NOTE OFF compatibility
    // So just return 0, it's a NOTE OFF, period.
    0;
  ):(
  
    // This said, we can start at 0.
    high = high-1;
    
    // 14-bit value
    ival = (high << 7) + low;
    
    // Avoid the zero case, ival is between [0..16255] so put all between [1..16256]
    ival += 1;
    
    // Put it in 0-1 space
    // Only 16256+1 values are available since we rejected all LSB values for MSB=0
    val01 = ival/16256;
    val01 = max(min(val01,1),0);
  );
);

// Octave number for a floating x axis of white keys
function octaveForBottomPos(keyboard_floating_pos) (
  floor(keyboard_floating_pos/7);
);

// Octave note for a floating x axis of white keys
// For the bottom row of the keyboard (only white keys here)
function octaveNoteForBottomPos(keyboard_bottom_floating_pos) (
  OCTAVE_LOOKUP_BOTTOM[floor(keyboard_bottom_floating_pos) % 7];
);

// Is key black? (keys are numbered from 0 to 87)
function keyIsBlack(key_num) (
  OCTAVE_BLACK_KEY_LOOKUP[key_num % 12] == 1;
);

// Key octave
function octaveForKey(key_num) (
  floor(key_num / 12);
);

// Key for midi note
function midiNoteToKey(midi_note) (
  midi_note; // A0
);

// Midi note to key
function keyToMidiNote(key) (
  key; // A0
);


// For a #CC, returns LSB counterpart or -1 if it hasn't.
function ccLsbCounterpart(ccnum) local(ret) (
  ret = -1;
  
  (ccnum>=0 && ccnum < 32)?(
    ret = ccnum + 32;
  );
  
  ret;
);

// For a #CC, returns MSB counterpart or -1 if it hasn't.
function ccMsbCounterpart(ccnum) local(ret) (
  ret = -1;
  
  (ccnum>=32 && ccnum < 64)?(
    ret = ccnum - 32;
  );
  
  ret;
);

function isALsbCC(ccnum) (
  // 88 is the LSB Channel for velocity.
  (ccMsbCounterpart(ccnum) != -1 || ccnum == 88);
);

function isAMsbCC(ccnum) (
  // 88 is the LSB Channel for velocity.
  (ccLsbCounterpart(ccnum) != -1);
);

// High res midi input? (it's a global param)
function isHighResMidiInputEnabled()
(
  HIGHRES_INPUT_ENABLED[0];
);

// High res output? (it's a local param)
function isHighResMidiOutputEnabledForControl(control) 
(
  CONTROL_HIGHRES_OUTPUT_ENABLED[control];
);

function controlHasOperationalHighResOutput(control)
  local(hr_is_legit_for_control, hr_is_enabled)
(
  hr_is_legit_for_control = (control == CONTROL_VELOCITY || ccLsbCounterpart(CONTROL_DSTS[control])!=-1);
  hr_is_enabled           = isHighResMidiOutputEnabledForControl(control);
  
  (hr_is_legit_for_control && hr_is_enabled);
);

function controlCurrentBound01(control,is_min)
  local(lsb,msb)
(
  msb = (is_min)?(CONTROL_MINS_MSB[control]):(CONTROL_MAXS_MSB[control]);
 
  (controlHasOperationalHighResOutput(control))?(
    lsb = (is_min)?(CONTROL_MINS_LSB[control]):(CONTROL_MAXS_LSB[control]);
    
    (control == CONTROL_VELOCITY)?(
      midiVelocityHresI2F01(msb,lsb);
    ):(
      midiCCHresI2F01(msb,lsb);
    );
  ):(
    msb/127.0;
  );
);

function controlCurrentMinBound01(control)
(
  controlCurrentBound01(control,1);
);

function controlCurrentMaxBound01(control)
(
  controlCurrentBound01(control,0);
);


// Is the CC learnable? (in high res, we don't allow LSB controls to be learnable)
function isCCLearnable(ccnum) (
  (!isHighResMidiInputEnabled())?(1):(!isALsbCC(ccnum););
);

function enableCCLearn()
(
  g_cc_learn = 1;
);

function disableCCLearn()
(
  g_cc_learn = 0;
);

function isCCLearning() 
(
  (g_cc_learn == 1);
);


/////////////////////
//  INIT FUNCTIONS //
/////////////////////

function knobTic(val, x_or_y) 
  local(ret, v1, v2)
(
  // Clamp val between 0 and 1
  val = min(val,0.99999);
  val = max(0,val);
  
  val = 10*val;
  
  v1 = floor(val) | 0; // intify, v1 between 0 and 9
  v2 = (v1 + 1) | 0;
  
  (x_or_y == 1)?
  ( 
    ret = KNOB_TICS_X[v1] + (val-v1)*(KNOB_TICS_X[v2]-KNOB_TICS_X[v1]);
  ):
  (
    ret = KNOB_TICS_Y[v1] + (val-v1)*(KNOB_TICS_Y[v2]-KNOB_TICS_Y[v1]); 
  );
);

function initKnobTics() local(t, angle)
(
  t = 0;
  while(t<11)
  (
    angle = 90 + 30 + t*(36-6);
    angle *= $pi / 180;
    KNOB_TICS_X[t] = cos(angle);
    KNOB_TICS_Y[t] = sin(angle);
    t += 1;
  );
);
function switchToTheme(theme_num) (
  (theme_num == DARK_THEME)?(switchToDarkTheme()):(switchToLightTheme());
);

function updateTheme() (
  switchToTheme(CURRENT_THEME_NUM[0]);
);

function initThemes() (
  CURRENT_THEME_NUM[0] = DARK_THEME;
  updateTheme();
);

////////////////////////
//     UI HELPERS     //
////////////////////////

function hasButtonInGrid(row,col)
(
  BUTTON_GRID_PRESENCE[row*BUTTON_GRID_SIZE + col];
);

function buttonDataAddress(row,col)
(
  BUTTON_DATA + (BUTTON_GRID_SIZE*row+col)*32;
);

function midiControlName(midi_cnum)
(
  midi_cnum;
);
function controlName(cnum)
(
  128+cnum;
);
function controlDescription(cnum)
(
  128+CONTROL_COUNT+cnum;
);
function controlLabel(cnum)
(
  128+CONTROL_COUNT+CONTROL_COUNT+cnum;
);
function controlLabelWithFallback(cnum) local(str)
(
  str = controlLabel(cnum);
  (strlen(str)==0)?(str="?");
  str;
);

function selectedControlCurveAddress()
(
  curveAddress(g_selected_control);
);

///////////////////////////////
//     MAIN INIT FUNCTIONS   //
///////////////////////////////

function definitionInit() 
(
  sharedGlobalVarInit();
  instanceGlobalVarInit();
  gmemGlobalVarInit();
  instanceMemoryMapInit();
  gmemMemoryMapInit();
);

function firstInit() 
  local(c, curve, i)
( 
  // Draw actor id
  g_actor_id = rand();
  
  (gmem[GMEM_LOADER_ID] == 0)?(
    // Load lib files if not loaded.
    gmem[GMEM_LOADER_ID] = g_actor_id;
    readLibFiles();
  );

  // Init midi control names
  initMidiControlNames();
  initPluginControlNames();

  // Init theme colors
  initThemes();
  
  // Init knob tics
  initKnobTics();
  
  // Init octave lookups
  initOctaveLookups();

  // Init curves for each control
  c = 0;
  while(c<CONTROL_COUNT) ( 

    // Init to identity.   
    CONTROL_ENABLED[c] = 1;

    curve = curveAddress(c);
    i = 0; 
    while(i<CURVESIZE) ( 
      curve[i] = i;
      i+=1; 
    ); 
    
    c += 1; 
  );
  
  // Init channel options
  KB_INPUT_CHANNEL[0]     = 0;
  KBR_OUTPUT_CHANNEL[0]   = 0;
  KBR_OUTPUT_CHANNEL[0]   =-1; // DROP
  
  // Init controls
  c = 0; while(c<CONTROL_COUNT) (  
    CONTROL_LAST_IN[c]                  = 0;
    CONTROL_LAST_OUT[c]                 = 0;
    CONTROL_ENABLED[c]                  = 0;    
    CONTROL_SRCS[c]                     = 127; 
    CONTROL_DSTS[c]                     = 127;
    CONTROL_CHAN_SRCS[c]                = 0; // Any
    CONTROL_CHAN_DSTS[c]                = 0; // As src
    CONTROL_HIGHRES_OUTPUT_ENABLED[c]   = 0; 
    CONTROL_MINS_LSB[c] = 0;
    CONTROL_MINS_MSB[c] = 0;
    CONTROL_MAXS_LSB[c] = 127;
    CONTROL_MAXS_MSB[c] = 127;
        
    c+=1 
  );
  
  // Init global params
  KEYBOARD_TRANSPOSE_ENABLED[0]     = 0;
  KEYBOARD_TRANSPOSE_8VA[0]         = 0;
  KEYBOARD_TRANSPOSE_SEMI_TONES[0]  = 0;     
 
  HIGHRES_INPUT_ENABLED[0]          = 0;
  DROP_UNROUTED_CC_MESSAGES[0]      = 0;
  DROP_UNROUTED_NOTE_MESSAGES[0]    = 0;

  // Init mod wheel
  CONTROL_ENABLED[CONTROL_WHEELS_START] = 1;
  CONTROL_SRCS[CONTROL_WHEELS_START]    = 1; // Midi mod wheel
  CONTROL_DSTS[CONTROL_WHEELS_START]    = 1; // Midi mod wheel
  
  // Init sustain pedal
  CONTROL_ENABLED[CONTROL_PEDALS_START] = 1;
  CONTROL_SRCS[CONTROL_PEDALS_START]    = 64; // Midi sustain pedal
  CONTROL_DSTS[CONTROL_PEDALS_START]    = 64; // Midi sustain pedal
  
  GUI_MODE[0] = 1;
  CURRENT_OCTAVA_OFFSET[0] = 0;
  
  // Configure font number 1
  gfx_setfont(1,"Arial",10,'b');           
  gfx_setfont(0);
);

ext_noinit=1;

// Reload memory map each time.
// This may allow hot plug of new fx versions.
definitionInit();

!hasinit ? (
  // Memory default values.
  // Only do this once or reaper will destroy user data.
  firstInit();
  last_modified = -1;
  g_selected_control = -1;
);
hasinit=1;

//===========================================//
//==============    SLIDER     ==============//
//===========================================//
@slider

//===========================================//
//==============   SERIALIZE   ==============//
//===========================================//
@serialize

// CURRENT FILE FORMAT
FILE_FORMAT_1_0             = (1<<8)+0; // 1.0 (==256)
CURRENT_FILE_FORMAT_VERSION = FILE_FORMAT_1_0;

function memwr(is_saving, ver) 
  local(ccount,s,avail) 
(
  
  ccount = (is_saving)?(CONTROL_COUNT):(0);
    
  // version and control count bytes introduced in V3.1a
  (ver>0)?(
    // Version number already managed 
    // Now the control count. 
    // Read it if we're reading, or save it if we're writing
    file_var(0,ccount);
    // And the first curve
    file_mem(0,CURVES+0,CURVESIZE);
  ):(
    !is_saving?(
      // In that version there were 35 controls
      ccount = 35;
    );
  
    // Version number was in fact the first sample of the first curve.
    // There are still n-1 samples to read afterwards.
    file_mem(0,CURVES+1,CURVESIZE-1);
  );
  
  // Read/Write other (ccount-1) curves (first one handled separately for bw compatibility)
  file_mem(0,CURVES+CURVESIZE , (ccount-1) * CURVESIZE);
 
  // Flags
  file_mem(0,CONTROL_ENABLED  , ccount);
  
  // Srcs and dests
  file_mem(0,CONTROL_SRCS     , ccount);
  file_mem(0,CONTROL_DSTS     , ccount);
  
  // Descriptions
  s=0;while(s<ccount) 
  ( 
    file_string(0,controlDescription(s)); 
    s+=1;
  );
  
  // Short descriptions
  s=0;while(s<ccount) 
  ( 
    file_string(0,controlLabel(s)); 
    s+=1;
  );
  
  // Introduced in V3 (keyboard filtering)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,KEYBOARD_FILTERING_ENABLED,1);
    file_mem(0,KEYBOARD_FILTERED_NOTES+21,88);
  );
  
  // Introduced in V3.1a (transpose / high res)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CONTROL_HIGHRES_OUTPUT_ENABLED, ccount);
    file_mem(0,KEYBOARD_TRANSPOSE_ENABLED,1);
    file_mem(0,KEYBOARD_TRANSPOSE_8VA,1);
    file_mem(0,KEYBOARD_TRANSPOSE_SEMI_TONES,1);
    file_mem(0,HIGHRES_INPUT_ENABLED,1);
    file_mem(0,DROP_UNROUTED_CC_MESSAGES,1);
  );
  
  // Introduced in V3.1d (theme selection)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CURRENT_THEME_NUM,1);
  );
  
  // Introduced in V3.3 (channel routing + min/max)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,CONTROL_CHAN_SRCS, ccount);
    file_mem(0,CONTROL_CHAN_DSTS, ccount);
    file_mem(0,KB_INPUT_CHANNEL,1);
    file_mem(0,KBG_OUTPUT_CHANNEL,1);
    file_mem(0,KBR_OUTPUT_CHANNEL,1);
    file_mem(0,KEYBOARD_VELOCITY_APPLY_TO,1);
    file_mem(0,KEYBOARD_TRANSPOSE_APPLY_TO,1);
    file_mem(0,CONTROL_MINS_MSB, ccount);
    file_mem(0,CONTROL_MINS_LSB, ccount);
    file_mem(0,CONTROL_MAXS_MSB, ccount);
    file_mem(0,CONTROL_MAXS_LSB, ccount);
    file_mem(0,DROP_UNROUTED_NOTE_MESSAGES,1);
  );
  
  // Introduced in V3.5 (full keyboard filtering)
  avail = file_avail(0);
  (is_saving || avail>0)?( // Avoid squashing default values if reading old format
    file_mem(0,KEYBOARD_FILTERED_NOTES,21);       // 
    file_mem(0,KEYBOARD_FILTERED_NOTES+109,19);   // Skipped 21+88
    file_mem(0,CURRENT_OCTAVA_OFFSET,1);
  );
);

function backupOrRestore() local(is_saving, check_ver, old_format) (

  is_saving = (file_avail(0)<0);
  
  (is_saving)?(

    file_var(0, CURRENT_FILE_FORMAT_VERSION);
    memwr(is_saving, CURRENT_FILE_FORMAT_VERSION);
  ):
  (  
    // Reading the file
    // Have to manage the old format ...
    check_ver = 0;
    file_var(0,check_ver);
    
    // Now, we put a version number >= 256.
    // The old format had a curve point on the first slot, so < 256.
    old_format = (check_ver < 256);
    
    (old_format)?( 
      // Repair first curve 
      // The "ver" would not exist and is in fact the first sample of the first curve
      CURVES[0] = check_ver; // Yuuuk!!
      // Force the file format to 0.0
      memwr(is_saving, 0);
    ):( 
      // 1.0 format, 36 controls
      memwr(is_saving, FILE_FORMAT_1_0);
    );
  )
);

backupOrRestore();

//===========================================//
//===============     GFX     ===============//
//===========================================//
@gfx 840 690

//////////////////////////
// GENERIC UI FUNCTIONS //
//////////////////////////

function gfx_rgb(hex_col) (
  gfx_r = ((hex_col>>16)&0xFF)/255; 
  gfx_g = ((hex_col>>8)&0xFF)/255;
  gfx_b = ((hex_col>>0)&0xFF)/255;
);

function gfx_xy(x,y) (
  gfx_x = x;
  gfx_y = y;
);

function gfx_rgb_control_high(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_HIGH):(TH.CONTROL_DISABLED_CONTRAST_HIGH) );
);
function gfx_rgb_control_mid(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_MID):(TH.CONTROL_DISABLED_CONTRAST_MID) );
);
function gfx_rgb_control_low(control_num) (
 gfx_rgb( (CONTROL_ENABLED[control_num] == 1)?(TH.CONTROL_ENABLED_CONTRAST_LOW):(TH.CONTROL_DISABLED_CONTRAST_LOW) );
);


function textForComboBox(combo_id, val)
  local(tmp)
(
  ( (combo_id == "chan_dst_spinbox" || combo_id == "chan_out_green_spinbox" || combo_id == "chan_out_red_spinbox") && val == 0) ? (
    "As In";
  ):(
    ( (combo_id == "chan_src_spinbox" || combo_id == "chan_in_keyboard_spinbox") && val == 0) ? (
      "Any";
    ):(
      (combo_id == "chan_out_red_spinbox" && val == -1)?(
        "Drop"
      ):(
        (combo_id == "applyto" || combo_id == "velo_applyto")?(
          (val == 0)?(
            "All"
          ):(
            (val== 1)?(
              gfx_rgb(TH.KEY_WHITE_FILTERED_IN);
              "G "
            ):(
              gfx_rgb(TH.KEY_WHITE_FILTERED_OUT);
              " R"
            )
          );
        ):(
          (combo_id == "keyboard_offset")?(
            ""
          ):(
            tmp = #;
            sprintf(tmp, "%d", val);
            tmp;
          );
        );
      );
    );
  );
);

// Draws a enable/disable button
// This button is linked to an adress in memory : flag_address[flag_local_address].
// The only way I had found in EEL to use "pointers" was an array trick.
// I've just discovered pseudo objects, it could be a solution too.
function drawBistateButton(flag_address,flag_local_address,t,l,ontext,offtext,color_on,color_off,color_on_hover,color_off_hover,text_color_on,text_color_off) 
  local(tmp, ontextw, offtextw, 
        bb, br, bw, bh, bl, bt, 
        in_rect, enabled)
(
  tmp = 0; ontextw = 0; offtextw = 0;
  gfx_measurestr(ontext, ontextw, tmp);
  gfx_measurestr(offtext, offtextw, tmp);
  
  bw = max(ontextw,offtextw) + 10;
  bh = 15;
  
  bl = l;
  bt = t;
  
  br = bl + bw;
  bb = bt + bh;
  
  enabled = flag_address[flag_local_address];
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y >= bt && mouse_y <= bb;
  
  in_rect ?(
    // Hover color
    gfx_rgb((enabled)?(color_on_hover):(color_off_hover));

    // Click
    mouse_click == 1 ? (
      flag_address[flag_local_address] = !flag_address[flag_local_address];
    );
  ):(
    // Not-hovered color
    gfx_rgb((enabled)?(color_on):(color_off));
  );
  gfx_rect(bl,bt,bw,bh); 
  
  // Text color
  gfx_rgb((enabled)?(text_color_on):(text_color_off));
  gfx_y = t + 4;
  enabled?(
    gfx_x = l+(bw-ontextw)/2; 
    gfx_drawstr(ontext); 
  ):(
    gfx_x = l+(bw-offtextw)/2;
    gfx_drawstr(offtext)
  );
);

function drawStandardBistateButton(flag_address,flag_local_address,t,l,on_text,off_text) (
  drawBistateButton(flag_address,flag_local_address,t,l,on_text,off_text, TH.EN_B_ON ,TH.EN_B_OFF, TH.EN_B_ON_H, TH.EN_B_OFF_H, TH.EN_B_ON_TEXT, TH.EN_B_OFF_TEXT);
);

function drawSwitchButton(flag_address,flag_local_address,t,l,on_text,off_text) (
 drawBistateButton (flag_address,flag_local_address,t,l,on_text,off_text, TH.SW_B_ON ,TH.SW_B_OFF, TH.SW_B_ON_H, TH.SW_B_OFF_H, TH.SW_B_ON_TEXT, TH.SW_B_OFF_TEXT); 
);


// ShortCut for a OnOff button with "Enabled"/"Bypass" texts
function drawEnableDisableButton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"Enabled","Disabled");
);

// ShortCut for a OnOff button with "Yes"/"No" texts
function drawYesNobutton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"Yes","No");
);

// ShortCut for a OnOff button with "On"/"Off" texts
function drawOnOffButton(flag_address,flag_local_address,t,l) (
  drawStandardBistateButton(flag_address,flag_local_address,t,l,"On","Off");
);

// - or + button for a spinbox
function drawAddOrSubButton(button_id,val_address,val_local_address,l,t,add_or_sub,minval,maxval,should_wrap)
   local(bl,bt,br,bb,in_rect,val_shift,got_event)
(
  got_event = 0;

  bl = l;
  bt = t;
   
  br = bl + 15;
  bb = bt + 15;
  
  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt); 
   
  (mouse_click == 1 && in_rect)?(
    mouse_capturator = button_id;
  ); 
   
  in_rect  ?
  (
    gfx_rgb(TH.MONO_B_H);   
    val_shift = 0;
   
    mouse_cap == 1 && mouse_capturator == button_id ? (
      // Limit this to 20 calls / seconds
      new_srcdstbtn_time = time_precise();
      (new_srcdstbtn_time - last_srcdstbtn_time > 0.03 || mouse_click) ? (
        val_shift = (add_or_sub)?(1):(-1);
        last_srcdstbtn_time = new_srcdstbtn_time; 
        mouse_click == 1 ? (last_srcdstbtn_time += 0.3);
      );
    ); 
    /*
      // maybe too dangerous ?
      mouse_wheeli != 0 ? (
        val_shift = mouse_wheeli;
      );
    */
    val_shift != 0 ? (  
      val_address[val_local_address] += val_shift;
      
      (should_wrap)?(
        (val_address[val_local_address]>maxval)?(val_address[val_local_address]=minval);   
        (val_address[val_local_address]<minval)?(val_address[val_local_address]=maxval);        
      ):(
        val_address[val_local_address] = min(max(val_address[val_local_address],minval),maxval);         
      );
      got_event = val_shift;
    );
  
  ):( gfx_rgb(TH.MONO_B) );  
 
  // Button background 
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
 
  // Button text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb(TH.MONO_B_TEXT);  
  
  (should_wrap)?(
    add_or_sub == 0?(gfx_drawstr("<")):(gfx_drawstr(">"));  
  ):(
    add_or_sub == 0?(gfx_drawstr("-")):(gfx_drawstr("+"));    
  );
  
  got_event;
);

// A Spinbox, with a int value and two +/- buttons
function drawAddOrSubWidget(widget_id, val_address, val_local_address, l, t, minval, maxval, labelwidth, should_wrap)
   local(tmp, roffset, got_event)
(
  roffset = labelwidth + 20; 
  
  got_event = 0;
  
  // Buttons -/+
  got_event |= drawAddOrSubButton(widget_id,val_address,val_local_address,l,t,0,minval,maxval,should_wrap);
  got_event |= drawAddOrSubButton(widget_id,val_address,val_local_address,l+roffset,t,1,minval,maxval,should_wrap);

  (labelwidth > 0)?(
    // Inner text
    gfx_rgb(TH.DYN_LABEL); 
    gfx_x = l+23; gfx_y = t+4;
    tmp = textForComboBox(widget_id, val_address[val_local_address]);
    gfx_drawStr(tmp);
  );
  
  got_event;
);

function drawInputLine(input_id, bl, bt, br, bb, str)
  local(in_rect,new_char,dstr) (
  
  in_rect = ( mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt ); 
  in_rect ?
  (
    gfx_rgb( (g_edited_input==input_id)?(TH.INPUTLINE_EDIT_BG_H):(TH.INPUTLINE_BG_H));   
   
    mouse_click == 1 ? (
      (g_edited_input != input_id)?(
        g_edited_input = input_id;
        while(gfx_getChar()>0); // Empty the queue
      )
      :(
        g_edited_input = "";
      );
    ); 
  ):(
    gfx_rgb( (g_edited_input==input_id)?(TH.INPUTLINE_EDIT_BG):(TH.INPUTLINE_BG) )
  );  
  
  g_edited_input == input_id?
  (
    new_char = gfx_getchar();
    
    // Alpha num
    new_char >= 32 && new_char <= 126 ?
    (
      sprintf(str,"%s%c",str,new_char);
    );
    // Del
    new_char == 8?
    (
      strncpy(str, str, max(strlen(str)-1,0)); 
    );
    // Return / Esc
    new_char == 13 || new_char == 27?
    (
      g_edited_input = "";
    );
  );
  
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb((g_edited_input==input_id)?(TH.INPUTLINE_EDIT_TEXT):(TH.INPUTLINE_TEXT));
  
  g_edited_input == input_id?
  (
    // If in edition, show a caret
    dstr = #;
    sprintf(dstr,"%s_",str);
    gfx_drawstr(dstr);
  ):(
    gfx_drawstr(str);
  );
  
);

/////////////////////
//    CURVE ZONE   //
/////////////////////

function mousePenCallback(gzone)
   local(curve,in_rect,px,py,x1,x2,y1,y2,alpha,i,min_bound,max_bound)
(   
  curve = selectedControlCurveAddress();
  
  in_rect = (mouse_x >= gzone.l && mouse_x < gzone.r && mouse_y >= gzone.t && mouse_y < gzone.b);

  // Remember that first click was in drawing zone (click focus)
  (mouse_click == 1 && in_rect)?(
    mouse_capturator = "curvezone";
  );
  
  // Only handle events if we have click focus
  mouse_cap == 1 && mouse_capturator == "curvezone" && g_pen_is_active ? (  
    // Drawing callback
    in_rect ?
    (
      px = (mouse_x-gzone.il)/(RESOLUTION);
      py = (gzone.ib-mouse_y+2)/(RESOLUTION);
      
      min_bound = controlCurrentMinBound01(g_selected_control);
      max_bound = controlCurrentMaxBound01(g_selected_control);
      
      // If inside the margin around the draw zone, clamp
      px < 0 ? px = 0;
      px > CURVESIZE - 1 ? px = CURVESIZE-1;
      (py < min_bound * (CURVESIZE - 1)) ? (py = min_bound * (CURVESIZE-1));
      (py > max_bound * (CURVESIZE - 1)) ? (py = max_bound * (CURVESIZE-1));
      px = roundi(px);
      py = roundi(py); 
      
      last_modified == -1 || last_modified == px ? (
        curve[px]     = py;
        last_modified = px;
      ):
      (
        // Perform some interpolation since mouse positions are not continuous
        x1=x2=y1=y2=0;
        px <= last_modified ? 
        ( x1 = px; x2 = last_modified; y1 = py; y2 = curve[last_modified]; ):
        ( x1 = last_modified; x2 = px; y1 = curve[last_modified]; y2 = py; );
        i = x1;
        while(i <= x2) (
          alpha  = (i-x1)/(x2-x1);
          curve[i] = y1 + alpha * (y2-y1);
          i += 1;
        );
        last_modified = px;
      )
    )
  ):(
    last_modified = -1
  );
);

function smoothButtonCallback()
  local(curve, i)
(
  curve = selectedControlCurveAddress();
  
  // Limit this to 20 calls / seconds
  new_smooth_time = time_precise();
  (new_smooth_time - last_smooth_time > 0.05) ? (
    
    SCURVE[0]           = curve[0];
    SCURVE[CURVESIZE-1] = curve[CURVESIZE-1];
    
    // Blur the curve
    i = 1;
    while(i<CURVESIZE-1)
    (
      SCURVE[i] = (CURVE[i-1] + CURVE[i] + CURVE[i+1])/3;
      i+=1;
    );
    
    i=0; while(i<CURVESIZE) ( CURVE[i] = SCURVE[i]; i+=1 );
    last_smooth_time = new_smooth_time;
  );
);


function drawMousePenButton(gzone)
  local(in_rect,bl,bt,br,bb)
(
  bl = gzone.il;
  bt = gzone.b;
  br = bl + 44;
  bb = bt + 20;
  
  in_rect = mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt;
 
  (in_rect && mouse_click == 1 && !g_pen_is_active)?(
    g_pen_is_active = 1;
  ):(
    (mouse_click == 1 && mouse_capturator != "curvezone")?(
      g_pen_is_active = 0;
    );
  );

  in_rect ?
  (
    gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON_H):(TH.MONO_B_H) );
  ):(
    gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON):(TH.MONO_B) );
  );
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  

  gfx_rgb( (g_pen_is_active)?(TH.CC_LEARN_ON_TEXT):(TH.MONO_B_TEXT) );
  gfx_x   = bl+10;
  gfx_y   = bt+7;
  gfx_drawstr("Pen");   
);


// Smooth button
function drawSmoothButton(gzone) 
  local(bl,bt,br,bb)
(
  bl = gzone.ir-88;
  bt = gzone.b;
  br = bl + 88;
  bb = bt + 20;
   
  mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt ?
  (
   gfx_rgb(TH.MONO_B_H);
   
   mouse_click == 1 ? ( mouse_capturator = "smoothbutton" );
   
   mouse_cap == 1 && mouse_capturator == "smoothbutton" ? (
     smoothButtonCallback();
   ); 
  ):(gfx_rgb(TH.MONO_B));  
  
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  gfx_x   = bl+20;
  gfx_y   = bt+7;
  gfx_rgb(TH.MONO_B_TEXT);
  gfx_drawstr("Smooth");  
);

// Gets the curve in GMEM cooresponding to button
// And builds a curve for the user.
function fsetCurveButtonCallback(set_num, row_num, col_num) 
  local(i,curve,curve_addr,min_bound,max_bound)
(
  curve       = selectedControlCurveAddress();
  curve_addr  = getFsetFunctionCurveAddress(set_num, row_num, col_num);

  min_bound   = controlCurrentMinBound01(g_selected_control);
  max_bound   = controlCurrentMaxBound01(g_selected_control);

  i = 0;
  while(i<CURVESIZE) (
    curve[i] = (CURVESIZE-1) * (min_bound + (max_bound-min_bound) * gmem[curve_addr+i]);
    i+=1;
  );
);

function drawFsetCurveButton(bzone, voffset, set_num, row_num, col_num) 
  local(preview_address,bl,bt,br,bb,i,curve_addr)
( 
  preview_address = getFSetFunctionPreviewAddress(set_num, row_num, col_num);

  bl = bzone.margin + 5 + bzone.l + col_num*41;
  bt = bzone.margin + bzone.t + row_num*42 + voffset + 10;
  br = bl + 32;
  bb = bt + 32;
   
  mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt ?
  (
   gfx_rgb(TH.MONO_B_H);   
   // Handle the callback in the draw function... erm
   (mouse_click==1) ? (
      fsetCurveButtonCallback(set_num, row_num, col_num);
   ); 
  ):
  ( 
    gfx_rgb(TH.MONO_B);
  );
  
  // Draw the button rect
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
     
  // Draw the button points
  gfx_rgb(TH.MONO_B_CURVE);
  gfx_x = bl; gfx_y = bb -31*gmem[preview_address+0] - 0.5; 
  
  i = 1;
  while(i<PREVIEWSIZE)
  (
    gfx_lineto(bl+i, bb - 31*gmem[preview_address+i] - 0.5);
    i+=1;
  );  
);


// Curve buttons
function drawCurveButtons(bzone) 
  local(bt, bb, bl, br, by, r, c, 
    has_sets, cur_set_num, is_selected, 
    cur_set_adr, cur_set_desc, got_event, ri, ci, in_rect,
    w, h, bww, bwx, bwy, si, sc, loff, offx, offy, offr,
    slider_l, slider_w, slider_t, sli_l, sli_r, sli_t, sli_b,
    tabs_per_row, tab_width, tab_height, loff,
    param_label, str, tab_text, to, voff,
    pos, new_pos, pval, new_val, vmin, vmax, pid, rounding)
(
  sc = getFSetCount();
  cur_set_num = getCurrentFSet();
     
  tabs_per_row  = 7;
  tab_width     = 70;
  tab_height    = 16;
  loff          = 6;
  
  (sc == 0)?(
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_xy(bzone.l, bzone.t + bzone.margin + 50);
    gfx_drawstr("Oops... It looks like your function");
    gfx_x = bzone.l; gfx_y += 20;
    gfx_drawstr("lib is empty. Be sure to install this");
    gfx_x = bzone.l; gfx_y += 20;
    gfx_drawstr("plugin through ReaPack and read the");
    gfx_x = bzone.l; gfx_y += 20;
    gfx_drawstr("README.md file in the Data folder of");    
    gfx_x = bzone.l; gfx_y += 20;
    gfx_drawstr("MIDI CC Mapper X located here :");   
    gfx_x = bzone.l; gfx_y += 40;
    gfx_drawstr("<RSRC>/Data/talagan_MIDI CC Mapper X");            
  );
    
  si    = 0;
  offy  = 0;
  while(si < sc)
  (   
    is_selected = (si == cur_set_num);
        
    offx  = (si % tabs_per_row) * (tab_width + 1);
    offy  = floor(si / tabs_per_row) * (tab_height + 1);
    offr  = floor(si / tabs_per_row) * loff;
        
    bl = bzone.l + offx + offr;
    br = bl + tab_width;
    bt = bzone.t + bzone.margin + offy;
    bb = bt + tab_height;
    
    in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt); 
        
    (in_rect)? (
      gfx_rgb((is_selected)?(TH.TAB_BG_S_H):(TH.TAB_BG_H));
      (mouse_click == 1)?(
        setCurrentFset(si);
      );
    ):( 
      gfx_rgb((is_selected)?(TH.TAB_BG_S):(TH.TAB_BG));
    );
        
    gfx_rect(bl,bt,br-bl,bb-bt);
        
    // Create a tab
    gfx_rgb((is_selected)?(TH.TAB_TEXT_S):(TH.TAB_TEXT));
        
    tab_text = getFSetTab(si);
    w = 0; h = 0; gfx_measurestr(tab_text,w,h);
    to = (tab_width - w)/2;
    gfx_x = bl+to+1;
    gfx_y = bt+4;        
    gfx_drawstr(tab_text);
    si += 1;
  );
  
  voff = offy+20;
  (sc > 0)?(
      
    // Curve buttons
    ri = 0;
    while(ri < FSET_ROW_COUNT) (
      ci = 0;
      while(ci < FSET_COL_COUNT) (
        (isFSetFunctionDefined(cur_set_num,ri,ci))?(
          drawFSetCurveButton(bzone, voff, cur_set_num, ri, ci);
        );
        ci += 1;
      );
      ri += 1;
    );
    
    (isFSetParametric(cur_set_num))?(
                  
      pid         = getFSetParametricID(cur_set_num);             
      
      param_label = getParametricFSetParameterName(pid);
      vmin        = getParametricFSetParameterMin(pid);
      vmax        = getParametricFSetParameterMax(pid);
      rounding    = getParametricFSetParamRounding(pid);
                  
      bwx = bzone.l + 10;
      bwy = bzone.t + voff + 5*50;
      bww = 220;
      
      gfx_measurestr(param_label,w,h);
      gfx_rgb(TH.DEFAULT_FONT);
      gfx_x   = bwx; gfx_y = bwy;
      gfx_drawstr(param_label); 
      
      slider_w = bww - w;
      slider_l = bwx + w + 10;
      slider_t = bwy + 2;
      
      gfx_rgb(TH.MONO_B);
      gfx_rect(slider_l, slider_t, slider_w, 3);
      
      gfx_rgb(TH.DEFAULT_FONT);
      gfx_xy(slider_l + slider_w + 10, bwy);
      
      pval = getFSetParameter(cur_set_num);
      
      pos = (pval - vmin)/(vmax - vmin);
      
      gfx_rect(slider_l + (pos * slider_w) - 4, slider_t - 4, 7, 11);
      
      sli_l = slider_l;
      sli_r = slider_l + slider_w;
      sli_t = slider_t - 4;
      sli_b = slider_t + 7;
      
      in_rect = (mouse_x >= sli_l-5 && mouse_x <= sli_r+5 && mouse_y >= sli_t-5 && mouse_y <= sli_b+5);
      
      (in_rect)?(
        (mouse_click == 1)?(
          mouse_capturator = "fset_param_slider";
        );
      );
      
      (mouse_cap == 1 && mouse_capturator == "fset_param_slider")?(
        new_pos = (mouse_x - sli_l)/(sli_r - sli_l);
        new_val = vmin + new_pos * (vmax - vmin);
        (new_val < vmin)?(new_val = vmin);
        (new_val > vmax)?(new_val = vmax);
        
        new_val = (rounding * roundi((new_val * 100)/rounding))/100.0;
        setFSetParameter(cur_set_num, new_val);
        precalcParametricSet(cur_set_num);
      );
      
      str = #;
      sprintf(str, "%.2f", pval+0.0001);
      gfx_drawstr(str);
      
    ):
    (
      gfx_rgb(TH.DEFAULT_FONT);
      gfx_x   = bzone.l+10; gfx_y = bzone.t + voff + 5*50;
      gfx_drawstr(getFSetDescription(cur_set_num)); 
    );
  );
);

function drawBoundariesPanel()
  local(got_event,i,min_bound,max_bound,with_lsb,curve,left, top)
(
  gfx_rgb(TH.DEFAULT_FONT);

  with_lsb = controlHasOperationalHighResOutput(g_selected_control);
  
  left = 610;
  top  = 170;
  
  gfx_xy(left+74, GUI_CONTROL_PARAMS_TOP + top + 2);
  gfx_drawStr("Curve limits");
  
  gfx_xy((with_lsb)?(left+152):(left+112), GUI_CONTROL_PARAMS_TOP + top + 42);
  gfx_drawStr("MSB");
  
  (with_lsb)?(
    gfx_xy(left+70, GUI_CONTROL_PARAMS_TOP + top + 42);
    gfx_drawStr("LSB");
  );
  
  gfx_xy((with_lsb)?(left):(left+40), GUI_CONTROL_PARAMS_TOP + top + 72);
  gfx_drawStr("Min");
  
  gfx_xy((with_lsb)?(left):(left+40), GUI_CONTROL_PARAMS_TOP + top + 102);
  gfx_drawStr("Max");
  
  got_event = 0;
  
  got_event |= drawAddOrSubWidget("min_spinbox_msb",CONTROL_MINS_MSB,g_selected_control,(with_lsb)?(left+50):(left+90),GUI_CONTROL_PARAMS_TOP+top+70,0,127,35,0); 
  got_event |= drawAddOrSubWidget("max_spinbox_msb",CONTROL_MAXS_MSB,g_selected_control,(with_lsb)?(left+50):(left+90),GUI_CONTROL_PARAMS_TOP+top+100,0,127,35,0); 
  
  (with_lsb)?(
    got_event |= drawAddOrSubWidget("min_spinbox_lsb",CONTROL_MINS_LSB,g_selected_control,left+130,GUI_CONTROL_PARAMS_TOP+top+70,0,127,35,0);
    got_event |= drawAddOrSubWidget("max_spinbox_lsb",CONTROL_MAXS_LSB,g_selected_control,left+130,GUI_CONTROL_PARAMS_TOP+top+100,0,127,35,0); 
  );

  got_event?(
  
    min_bound = controlCurrentMinBound01(g_selected_control)*127;
    max_bound = controlCurrentMaxBound01(g_selected_control)*127;
   
    curve = curveAddress(g_selected_control);
         
    // Reclamp the curve.
    i = 0;
    while(i<CURVESIZE) (
    
      (curve[i]<min_bound)?(curve[i] = min_bound);
      (curve[i]>max_bound)?(curve[i] = max_bound);
      
      i+=1;
    );
  );
);

function drawCurvezone() 
  local(curve, curve_panel_top, left, top, right, bottom, gridstep, gzone, bzone, i, t1,t2,t3,t4)
(
   // Curve zone
    curve_panel_top = GUI_CONTROL_PARAMS_TOP+70;  
    curve = selectedControlCurveAddress();
   
    gzone = 0;
    gzone.margin = 20;
    
    gzone.l   = 10;
    gzone.t   = curve_panel_top; 
    gzone.ih  = (CURVESIZE-1)*RESOLUTION;
    gzone.iw  = (CURVESIZE-1)*RESOLUTION;
    gzone.it  = gzone.t  + gzone.margin;
    gzone.il  = gzone.l  + gzone.margin;
    gzone.ir  = gzone.il + gzone.iw;
    gzone.ib  = gzone.it + gzone.ih;
    gzone.r   = gzone.ir + gzone.margin;
    gzone.b   = gzone.ib + gzone.margin;
  
    left   = gzone.il;
    right  = gzone.ir;
    top    = gzone.it;
    bottom = gzone.ib; 
   
    bzone         = 0;
    bzone.margin  = 20;
    bzone.l       = gzone.r;
    bzone.t       = gzone.t;
    
    t1        = top;
    t2        = bottom - gzone.ih * controlCurrentMaxBound01(g_selected_control);
    t3        = bottom - gzone.ih * controlCurrentMinBound01(g_selected_control);
    t4        = bottom;
    
    // Draw background
    gfx_rgb(TH.CURVE_BG); 
    gfx_rect(left,top,right-left,bottom-top);
    
    gfx_rgb(TH.CURVE_BG_EXCL);
    gfx_rect(left,t1,right-left,t2-t1);
    gfx_rect(left,t3,right-left,t4-t3);
    
      
    // Draw grid
    gfx_rgb(TH.CURVE_GRID);
    gridstep = (CURVESIZE/4)*RESOLUTION;
    gfx_line(left+1*gridstep,top,left+1*gridstep,bottom);
    gfx_line(left+2*gridstep,top,left+2*gridstep,bottom);
    gfx_line(left+3*gridstep,top,left+3*gridstep,bottom);
    gfx_line(left,top+1*gridstep,right,top+1*gridstep);
    gfx_line(left,top+2*gridstep,right,top+2*gridstep);
    gfx_line(left,top+3*gridstep,right,top+3*gridstep);
      
    // Draw border
    gfx_rgb(TH.CURVE_BORDER);
    gfx_x = left;
    gfx_y = top;
    gfx_lineto(right,top);
    gfx_lineto(right,bottom);
    gfx_lineto(left,bottom);
    gfx_lineto(left,top);
     
    // Draw curve
    gfx_rgb(TH.CURVE);
    gfx_x = left;
    gfx_y = bottom-roundi(RESOLUTION*curve[0]);
      
    i = 1; while(i<CURVESIZE)(
      gfx_lineto(left+i*RESOLUTION, bottom - roundi(RESOLUTION*curve[i]));
      i+=1; 
    );
      
    gfx_rgb(TH.CURVE_CURRENT_VALUE);   
    // Draw last event
    gfx_circle(left + CONTROL_LAST_IN[g_selected_control]*RESOLUTION ,bottom-floor(1.5 + RESOLUTION*CONTROL_LAST_OUT[g_selected_control]),3);
        
    mousePenCallback(gzone);    
        
    drawCurveButtons(bzone);
    drawMousePenButton(bzone);
    drawSmoothButton(bzone);
    drawBoundariesPanel();
);

//////////////////////
//  ASSIGN PANEL   //
//////////////////////

// Enable/Disable button for a CC control
function drawEnableDisableButtonForControl(control_num) (
  drawEnableDisableButton(CONTROL_ENABLED,control_num,CONTROL_PANEL_TOP+3,10);
);

function onControlSelect()
(
  disableCCLearn();
  g_edited_input = "";
);

function drawWheel(wh_num) 
  local(control_num, in_rect, slider_zone_x_offset, slider_zone_y_offset,
        slider_h, slider_w, slider_l, slider_t, slider_b, slider_r,
        slider_zone_x_offset, slider_zone_y_offset,
        rect_x, rect_y,
        cval)
(
  control_num = CONTROL_WHEELS_START + wh_num;
 
  slider_zone_x_offset = 30;
  slider_zone_y_offset = CONTROL_PANEL_TOP + 32;
  
  slider_h     = 70 + 5;  
  slider_w     = 15;
  slider_t     = slider_zone_y_offset;
  slider_l     = slider_zone_x_offset; 
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;

  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);
  
  // Click event
  mouse_click == 1 && in_rect ?
  (
    g_selected_control == control_num?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();
  );
  
  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);
    gfx_rect(slider_l-5,slider_t-5,slider_w+10,slider_h+10);
  );
  
  // Draw wheel body 
  gfx_rgb_control_high(control_num);
  gfx_rect(slider_l,slider_t,slider_w,slider_h);
    
  // Draw Cursor
  cval = CONTROL_LAST_IN[control_num]/127.0;
  gfx_rgb_control_low(control_num);
  rect_x = slider_l;
  rect_y = slider_b - cval*65 - 10;
  gfx_rect(rect_x, rect_y, slider_w,10);
);

function drawPad(pad_num, is_pedal)
   local(in_rect, control_num, cval,
         slider_t, slider_l, slider_b, slider_r, slider_h, slider_w,
         slider_h_inner, slider_t_inner, slider_l_inner, slider_w_inner,
         slider_zone_x_offset, slider_zone_y_offset,
         str, str_h, str_w)
(
  control_num = (is_pedal==1)?(CONTROL_PEDALS_START + pad_num):(CONTROL_PADS_START + pad_num);
 
  slider_h     = is_pedal == 1?(12):(22);  
  slider_w     = is_pedal == 1?(15):(32);
 
  slider_zone_x_offset = (is_pedal==1)?(58):(
    507 + (pad_num % 5) * (slider_w+9);
  );
  slider_zone_y_offset =(is_pedal==1)?(32 + pad_num*21):
  (
    30 + floor(pad_num / 5) * (slider_h+23);
  );
  
  slider_t     = CONTROL_PANEL_TOP + slider_zone_y_offset;
  slider_l     = slider_zone_x_offset; 
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;
  
  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);
  
  // Handle events
  mouse_click == 1 && in_rect ?
  (
    g_selected_control == control_num?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();
  );
  
  // Draw highlight
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);  
    gfx_rect(slider_l-3,slider_t-3,slider_w+6,slider_h+((is_pedal==1)?(7):(17)) );
  );
  
  cval = CONTROL_LAST_IN[control_num]/127.0;

  // Draw body
  (is_pedal)?(
    (CONTROL_ENABLED[control_num] == 1)?(
      (cval>0.5)?(
        gfx_rgb_control_high(control_num);
      ):(
        gfx_rgb_control_mid(control_num);
      );
    ):(
      gfx_rgb_control_mid(control_num);
    );
    gfx_rect(slider_l,slider_t,slider_w,slider_h);
     
    // Draw small line pattern that make this look like a pedal
    gfx_rgb( (g_selected_control == control_num)?(TH.CONTROL_HIGHLIGHT):(TH.BACKGROUND) );
    gfx_line(slider_l,slider_t+4,slider_r,slider_t+4);  
    gfx_line(slider_l+3,slider_t,slider_l+3,slider_t+4);  
    gfx_line(slider_l+7,slider_t,slider_l+7,slider_t+4);  
    gfx_line(slider_l+11,slider_t,slider_l+11,slider_t+4);  
     
  ):(
   
    gfx_rgb_control_mid(control_num);
    gfx_rect(slider_l,slider_t,slider_w,slider_h);
    
    // Growing center rect
    (CONTROL_ENABLED[control_num] == 1)?(
      slider_w_inner = roundi(slider_w * cval / 2)*2;
      slider_h_inner = roundi(slider_h * cval / 2)*2;
      slider_l_inner = slider_l + (slider_w - slider_w_inner) * 0.5;
      slider_t_inner = slider_t + (slider_h - slider_h_inner) * 0.5;
            
      gfx_rgb_control_high(control_num);
      gfx_rect(slider_l_inner,slider_t_inner,slider_w_inner,slider_h_inner);
    );  
  
    // Draw Label
    gfx_rgb_control_high(control_num);
    gfx_setfont(1);
    str_w = 0; str_h = 0;
    str = controlLabelWithFallback(control_num);
    gfx_measurestr(str,str_w,str_h);
    gfx_x = slider_l + slider_w/2 - str_w/2; gfx_y = slider_b+1;
    gfx_drawstr(str);
    gfx_setfont(0);
  ); 
);

function drawPedal(ped_num)
(
  drawPad(ped_num,1);
);

function drawFader(sl_num) 
   local(control_num, cval, rect_x, rect_y,
         str, str_w, str_h,
         slider_zone_x_offset, slider_zone_y_offset,
         slider_inter,
         slider_w, slider_h, slider_t, slider_l, slider_b, slider_r, s)
(
  control_num = CONTROL_FADERS_START + sl_num;
 
  slider_zone_x_offset = 85;
  slider_zone_y_offset = 32;
  
  slider_inter = 6;
  slider_w     = 15;
  slider_h     = slider_inter*10 + 5;  
  slider_t     = CONTROL_PANEL_TOP + slider_zone_y_offset;
  slider_l     = slider_zone_x_offset + sl_num * 20; 
  slider_b     = slider_t + slider_h;
  slider_r     = slider_l + slider_w;
  
  // Handle events
  mouse_click == 1 && mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t ?
  (
    g_selected_control == control_num?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();
  );
  
  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT); 
    gfx_rect(slider_l,slider_t,slider_w,slider_h+12);
  );
  
  // Draw tics
  gfx_rgb_control_mid(control_num);
  s = 0;
  while(s<11)
  (
    gfx_line(slider_l + 3, 2 + slider_t + s*slider_inter, slider_r - 4, 2 + slider_t + s*slider_inter);
    s += 1;
  );
  
  // Draw Cursor
  cval = CONTROL_LAST_IN[control_num]/127.0;
  gfx_rgb_control_high(control_num);
  rect_x = slider_l;
  rect_y = slider_b - cval*slider_inter*10-5;
  gfx_rect(rect_x, rect_y, slider_w,5);
  
  // Draw Label
  gfx_rgb_control_high(control_num);
  gfx_setfont(1);
  str_w = 0; str_h = 0;
  str = controlLabelWithFallback(control_num);
  gfx_measurestr(str,str_w,str_h);
  gfx_x = slider_l + slider_w/2 - str_w/2; gfx_y = slider_b;
  gfx_drawstr(str);
  gfx_setfont(0);
);

function drawVelocityWidget() 
   local(control_num, is_control_enabled, is_control_selected,
         icon_top,
         slider_w, slider_h, slider_t, slider_l, slider_r, slider_b, slider_full_h,
         in_rect)
(
 
  control_num          = CONTROL_VELOCITY;
  is_control_enabled   = (CONTROL_ENABLED[control_num] == 1);
  is_control_selected  = (g_selected_control == control_num);
 
  slider_w      = 60;
  slider_h      = 67;
  slider_full_h = 72;
 
  slider_t      = CONTROL_PANEL_TOP + 32;
  slider_l      = 722; 
  
  slider_r      = slider_l + slider_w;
  slider_b      = slider_t + slider_full_h;
  
  in_rect = (mouse_x >= slider_l && mouse_x <= slider_r && mouse_y <= slider_b && mouse_y >= slider_t);
  
  // Click event
  mouse_click == 1 && in_rect ?
  (
    is_control_selected?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();
  );
  
  // Draw background
  is_control_selected ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT); 
    gfx_rect(slider_l-5,slider_t-5,slider_w+10,slider_full_h+10);
  );
  
  // Icon
  icon_top = slider_t + 17;
  gfx_rgb_control_high(control_num);
    
  // White keys
  gfx_rect(slider_l,    icon_top + 14, 18, 3);
  gfx_rect(slider_l+20, icon_top + 14, 18, 3);
  gfx_rect(slider_l+40, icon_top + 14, 18, 3);
  
  gfx_rect(slider_l+2,  icon_top + 19, 16, 11); 
  gfx_rect(slider_l+20, icon_top + 19, 18, 11);
  gfx_rect(slider_l+40, icon_top + 19, 16, 11); 
  
  // Black keys
  gfx_rgb_control_low(control_num);  
  gfx_rect(slider_l+11, icon_top+1, 14, 11); 
  gfx_rect(slider_l+33, icon_top+1, 14, 11); 

  // Label
  gfx_rgb_control_high(control_num);  
  gfx_setfont(1);
  gfx_x = slider_l+9; gfx_y = icon_top + 35;
  gfx_drawstr("Velocity");
  gfx_setfont(0);
);

function drawKnob(knob_num) 
  local(kb_zone_x_offset, kb_zone_y_offset, 
        kb_l, kb_r, kb_t, kb_b,
        kb_center_x, kb_center_y, 
        control_num,
        xpos, ypos, t, cval, x, y, 
        str_w, str_h, str)
(
  control_num = CONTROL_KNOBS_START + knob_num;

  kb_zone_x_offset = 305;
  kb_zone_y_offset = 41;
  
  xpos = (knob_num % 5);
  ypos = floor(knob_num / 5);
  
  kb_center_x = kb_zone_x_offset + xpos*43;
  kb_center_y =  CONTROL_PANEL_TOP + kb_zone_y_offset + ypos*44;
  
  kb_l        = kb_center_x - 16;
  kb_r        = kb_center_x + 17;
  kb_t        = kb_center_y - 16;
  kb_b        = kb_center_y + 17;
  
  // Handle events
  mouse_click == 1 && mouse_x >= kb_l && mouse_x <= kb_r && mouse_y <= kb_b && mouse_y >= kb_t ?
  (
    (g_selected_control == control_num)?(g_selected_control = -1):(g_selected_control = control_num);
    onControlSelect();   
  );
  
  // Draw background
  g_selected_control == control_num ?
  (
    gfx_rgb(TH.CONTROL_HIGHLIGHT);  
    gfx_rect(kb_l,kb_t,33,43);
  );
  
  // KB Tics
  gfx_rgb_control_high(control_num);
  t = 0;
  while(t<11)
  (
    gfx_line(kb_center_x,kb_center_y,kb_center_x + floor(14*KNOB_TICS_X[t]+0.5), kb_center_y + floor(14*KNOB_TICS_Y[t]+0.5));
    t += 1;
  ); 
  
  // KB Background
  gfx_rgb_control_mid(control_num);
  gfx_circle(kb_center_x,kb_center_y,12,1,0);
  
  // KB Border
  gfx_rgb((g_selected_control == control_num)?(TH.CONTROL_HIGHLIGHT):(TH.BACKGROUND));
  gfx_circle(kb_center_x,kb_center_y,12,0,1);
  
  // Cursor
  gfx_rgb_control_high(control_num);
  
  cval = CONTROL_LAST_IN[control_num]/127.0;
  x = floor(knobTic(cval,1)*12 + 0.5);
  y = floor(knobTic(cval,0)*12 + 0.5);
  
  gfx_line(kb_center_x, kb_center_y, kb_center_x + x, kb_center_y + y);
  
  // Draw Label
  gfx_rgb_control_high(control_num);
  gfx_setfont(1);
  str_w = 0; str_h = 0;
  str = controlLabelWithFallback(control_num);
  gfx_measurestr(str,str_w,str_h);
  gfx_x = kb_center_x - str_w/2; gfx_y = kb_b-3;
  gfx_drawstr(str);
  gfx_setfont(0);
);

// CC Learn widget
function drawCCLearnButton(cnum) 
   local(bl,bt,br,bb,in_rect)
(
  bl = 253;
  bt = GUI_CONTROL_PARAMS_TOP+30;
  br = bl + 70;
  bb = bt + 15;
   
  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt);
  in_rect ? 
  (
    (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON_H)):(gfx_rgb(TH.MONO_B_H));   
    
    mouse_click == 1 ? (
      (isCCLearning())?(disableCCLearn()):(enableCCLearn());
    ); 
  ):
  (
    (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON)):(gfx_rgb(TH.MONO_B));   
  );  
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
  
  // Now the text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  (isCCLearning())?(gfx_rgb(TH.CC_LEARN_ON_TEXT)):(gfx_rgb(TH.MONO_B_TEXT));  
  gfx_drawstr("CC Learn");
);

// CC Learn widget
function drawCopySrcButton(cnum) 
   local(bl,bt,br,bb,in_rect)
(
  bl = 253;
  bt = GUI_CONTROL_PARAMS_TOP+50;
  br = bl + 70;
  bb = bt + 15;
   
  in_rect = (mouse_x >= bl && mouse_x <= br && mouse_y <= bb && mouse_y >= bt);
  in_rect ?
  (
    // Hover in color
    gfx_rgb(TH.MONO_B_H); 
    // Handle the callback in the draw function... erm
    mouse_click == 1 ? (
      CONTROL_DSTS[cnum] = CONTROL_SRCS[cnum];
    ); 
  ):
  (
    // Hover out color
    gfx_rgb(TH.MONO_B);
  );  
  
  gfx_x   = bl;
  gfx_y   = bt;
  gfx_rect(bl,bt,br-bl,bb-bt);
 
  // Now the text
  gfx_x   = bl+3;
  gfx_y   = bt+4;
  gfx_rgb(TH.MONO_B_TEXT);
  gfx_drawstr("Copy Src");
);

// Description label widget
function drawDescriptionInputLine() 
   local(bl,bt,br,bb,str)
(
  bl = 130;
  bt = GUI_CONTROL_PARAMS_TOP+10;
  br = bl + 146;
  bb = bt + 15;
  str = controlDescription(g_selected_control);
  
  drawInputLine("input_desc", bl, bt, br, bb, str);
);

// Small label edition widget
function drawSmallLabelInputLine() 
   local(bl,bt,br,bb,str)
(
  bl = 395;
  bt = GUI_CONTROL_PARAMS_TOP+10;
  br = bl + 40;
  bb = bt + 15;
  
  str = controlLabel(g_selected_control);
  drawInputLine("input_sl", bl, bt, br, bb, str);
);


// Control editor sub panel for midi cc assignment
function drawAssignZone() 
   local(src_cc, src_name, src_is_lsb, src_is_msb,
         dst_cc, dst_name, dst_is_lsb, dst_is_msb)
(
  gfx_rgb(TH.DEFAULT_FONT);
    
  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+14;
  gfx_drawStr("Description");
  
  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+34;
  gfx_drawStr("In  ->");
  
  gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+54;
  gfx_drawStr("Out ->");
  
  
  gfx_rgb(TH.DEFAULT_FONT); 
  gfx_x=90; gfx_y = GUI_CONTROL_PARAMS_TOP+34;  
  gfx_drawStr("Chan");  
  
  gfx_rgb(TH.DEFAULT_FONT); 
  gfx_x=90; gfx_y = GUI_CONTROL_PARAMS_TOP+54;  
  gfx_drawStr("Chan");
  
  g_selected_control != CONTROL_VELOCITY ?(
    drawAddOrSubWidget("chan_src_spinbox",CONTROL_CHAN_SRCS,g_selected_control,130,GUI_CONTROL_PARAMS_TOP+30,0,16,51,0);  
    drawAddOrSubWidget("chan_dst_spinbox",CONTROL_CHAN_DSTS,g_selected_control,130,GUI_CONTROL_PARAMS_TOP+50,0,16,51,0);
  ):(
    gfx_rgb(TH.DYN_LABEL); 
    gfx_x=140; gfx_y = GUI_CONTROL_PARAMS_TOP+34;  
    gfx_drawStr("Keyb In");
  
    gfx_rgb(TH.DYN_LABEL); 
    gfx_x=140; gfx_y = GUI_CONTROL_PARAMS_TOP+54;  
    gfx_drawStr("Keyb Out");
  );
  
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_x=230; gfx_y = GUI_CONTROL_PARAMS_TOP+34;
  gfx_drawStr("CC");
  gfx_x=230; gfx_y = GUI_CONTROL_PARAMS_TOP+54;
  gfx_drawStr("CC");
  
  g_selected_control != CONTROL_VELOCITY ?(
    gfx_x = 295; gfx_y = GUI_CONTROL_PARAMS_TOP+14;
    gfx_drawStr("Small Label");
    
    drawDescriptionInputLine();
    drawSmallLabelInputLine();

    drawCCLearnButton(g_selected_control);
    drawCopySrcButton(g_selected_control);
   
    drawAddOrSubWidget("cc_src_spinbox",CONTROL_SRCS,g_selected_control,332,GUI_CONTROL_PARAMS_TOP+30,0,127,37,0);
    drawAddOrSubWidget("cc_dst_spinbox",CONTROL_DSTS,g_selected_control,332,GUI_CONTROL_PARAMS_TOP+50,0,127,37,0);
  
    // Name of the src CC
    gfx_rgb(TH.ROUTING_INFO_CCNAME);
    gfx_x = 412;  gfx_y = GUI_CONTROL_PARAMS_TOP+34;
    src_cc     = CONTROL_SRCS[g_selected_control];
    src_name   = midiControlName(src_cc);
    
    src_is_lsb = isALsbCC(src_cc);
    src_is_msb = isAMsbCC(src_cc);
    
    gfx_drawStr(src_name);
    
    (src_is_lsb)?(
      (isHighResMidiInputEnabled())?(
        gfx_rgb(TH.ROUTING_INFO_NOT_OK);
        gfx_drawStr(" [LSB not routable in High-Res]");
      ):(
        gfx_drawStr(" (LSB)");
      );
    );
    
    (src_is_msb)?(
      (isHighResMidiInputEnabled())?(
        gfx_rgb(TH.ROUTING_INFO_OK);
        gfx_drawStr(" [High Res]");
      ):(
        gfx_drawStr(" (MSB)");
      );
    );
    
    // Name of the dst CC
    gfx_rgb(TH.ROUTING_INFO_CCNAME);
    gfx_x = 412;  gfx_y = GUI_CONTROL_PARAMS_TOP+54;
    dst_cc     = CONTROL_DSTS[g_selected_control];
    dst_name   = midiControlName(dst_cc);
    dst_is_lsb = isALsbCC(dst_cc);
    dst_is_msb = isAMsbCC(dst_cc);
    
    gfx_drawStr(dst_name);
    
    (dst_is_msb)?(
      (isHighResMidiOutputEnabledForControl(g_selected_control))?(
       gfx_rgb(TH.ROUTING_INFO_OK);
        gfx_drawStr(" [High Res]");
      ):(
        gfx_drawStr(" (MSB)");
      );
    );
    
    (dst_is_lsb)?(
      gfx_drawStr(" (LSB)");
    );
    
  ):(
  
    // Keyboard Velocity special case
    gfx_rgb(TH.DYN_LABEL);
    gfx_x = 140; gfx_y = GUI_CONTROL_PARAMS_TOP+14;
    gfx_drawStr("Keyboard velocity");  
    
    // Src
    gfx_rgb(TH.DEFAULT_FONT); 
    gfx_x=90; gfx_y = GUI_CONTROL_PARAMS_TOP+34;  
    gfx_drawStr("Chan");
    
    gfx_rgb(TH.DYN_LABEL_DISABLED);
    gfx_x = 260; gfx_y = GUI_CONTROL_PARAMS_TOP+34;
    gfx_drawStr("Keyboard velocity");  
    (isHighResMidiInputEnabled())?(
      gfx_rgb(TH.ROUTING_INFO_OK);
      gfx_drawStr(" [High Res]");
    );
    
    // Dst
    gfx_rgb(TH.DYN_LABEL_DISABLED);
    gfx_x = 260; gfx_y = GUI_CONTROL_PARAMS_TOP+54;
    gfx_drawStr("Keyboard velocity");    
    (isHighResMidiOutputEnabledForControl(g_selected_control))?(
      gfx_rgb(TH.ROUTING_INFO_OK);
      gfx_drawStr(" [High Res]");
    );
  ); 
  
  (g_selected_control == CONTROL_VELOCITY)?(
    gfx_rgb(TH.DEFAULT_FONT); 
    gfx_x=312; gfx_y = GUI_CONTROL_PARAMS_TOP+14;  
    gfx_drawStr("Keys");
    drawAddOrSubWidget("velo_applyto", KEYBOARD_VELOCITY_APPLY_TO,0,358,GUI_CONTROL_PARAMS_TOP+11,0,2,32,0);  
  );
  
  (g_selected_control == CONTROL_VELOCITY || ccLsbCounterpart(CONTROL_DSTS[g_selected_control])!=-1)?(
    // High Res Control
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_x = 455; gfx_y = GUI_CONTROL_PARAMS_TOP+14;
    gfx_drawStr("High res output");  
    drawYesNobutton(CONTROL_HIGHRES_OUTPUT_ENABLED,g_selected_control,GUI_CONTROL_PARAMS_TOP+11,590);
  );
);

function drawControlPanel() 
   local(i, str)
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,CONTROL_PANEL_TOP,gfx_w,20);
       
  (g_selected_control != -1)?(
  
    // Header text
    gfx_rgb(TH.HEADER_TEXT);
    gfx_x = 88; gfx_y = CONTROL_PANEL_TOP+7;
    str = #;
    sprintf(str,"%s / %s", controlName(g_selected_control), controlDescription(g_selected_control));
    gfx_drawstr(str);
    
    // Enable / Disable
    drawEnableDisableButtonForControl(g_selected_control);
  ):(
    gfx_rgb(TH.HEADER_TEXT);
    gfx_x = 10; gfx_y = CONTROL_PANEL_TOP+7;  
    gfx_drawstr("Select a control to edit it."); 
  );
  
  drawWheel(0);
  drawPedal(0);
  drawPedal(1);
  drawPedal(2);
  drawPedal(3);
  
  i = 0; while(i<10)
  (
    drawKnob(i);
    i += 1;
  );
  i = 0; while(i<10)
  (
    drawFader(i);
    i += 1;
  );
  i = 0; while(i<10)
  (
    drawPad(i,0);
    i += 1;
  );
  
  drawVelocityWidget();
  
  // Edition of the selected control
  (g_selected_control != -1)?(
    (CONTROL_ENABLED[g_selected_control] == 1 )?(
      // Assignment zone   
      drawAssignZone();
      drawCurveZone();
    ):(
      gfx_x = 30; gfx_y = GUI_CONTROL_PARAMS_TOP+14 ; gfx_rgb(TH.DEFAULT_FONT);
      gfx_drawstr("To edit the parameters for this control, enable it first.");
    );
  );
);


////////////////////////
//   KEYBOARD PANEL  //
////////////////////////

function drawKeyboardKeyMarker(x,y)
(
  gfx_rgb(TH.KEY_MARKER_BG);
  gfx_circle(x,y,4,1,0);
  gfx_rgb(TH.KEY_MARKER_BORDER);
  gfx_circle(x,y,4,0,0);
);

function drawTransposePanel() 
   local(enabled) 
(

  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(KEYBOARD_PANEL_WIDTH+2,KEYBOARD_FILTERING_TOP,gfx_w - KEYBOARD_PANEL_WIDTH-2,20);

  // Button 
  drawEnableDisableButton(KEYBOARD_TRANSPOSE_ENABLED,0,KEYBOARD_FILTERING_TOP + 3,10 + KEYBOARD_PANEL_WIDTH);
  
  // Title
  gfx_x = 88 + KEYBOARD_PANEL_WIDTH; gfx_y = KEYBOARD_FILTERING_TOP + 7;
 
  gfx_rgb(TH.HEADER_TEXT);
  gfx_drawstr("Transpose"); 
  
  enabled = KEYBOARD_TRANSPOSE_ENABLED[0];
  
  enabled?(

    gfx_x = KEYBOARD_PANEL_WIDTH+10; gfx_y = KEYBOARD_FILTERING_TOP+50;
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_drawstr("8vi");

    gfx_x = KEYBOARD_PANEL_WIDTH+10; gfx_y = KEYBOARD_FILTERING_TOP+70;
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_drawstr("Semitones");
    
    gfx_x = KEYBOARD_PANEL_WIDTH+10; gfx_y = KEYBOARD_FILTERING_TOP+90;
    gfx_rgb(TH.DEFAULT_FONT);
    gfx_drawstr("Keys");
    
    drawAddOrSubWidget("8va"     , KEYBOARD_TRANSPOSE_8VA,0,KEYBOARD_PANEL_WIDTH+90,KEYBOARD_FILTERING_TOP+46,-2,2,32,0);
    drawAddOrSubWidget("semitone", KEYBOARD_TRANSPOSE_SEMI_TONES,0,KEYBOARD_PANEL_WIDTH+90,KEYBOARD_FILTERING_TOP+66,-12,12,32,0);
    drawAddOrSubWidget("applyto",  KEYBOARD_TRANSPOSE_APPLY_TO,0,KEYBOARD_PANEL_WIDTH+90,KEYBOARD_FILTERING_TOP+86,0,2,32,0);
  );
);

function drawKeyboardChannelsPanel() 
   local(kf_enabled) 
(
  kf_enabled = KEYBOARD_FILTERING_ENABLED[0];

  gfx_x = 30; gfx_y = KEYBOARD_PANEL_TOP + 106;
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawstr("Channels");

  gfx_x = 130; gfx_y = KEYBOARD_PANEL_TOP + 106;
  gfx_rgb(TH.DEFAULT_FONT);
  gfx_drawstr("In");

  drawAddOrSubWidget("chan_in_keyboard_spinbox",KB_INPUT_CHANNEL,0,155,KEYBOARD_PANEL_TOP+102,0,16,35,0);

  gfx_x = 260; gfx_y = KEYBOARD_PANEL_TOP + 106;
  gfx_rgb(TH.ROUTING_INFO_OK);
  gfx_drawstr("Green out");
  
  drawAddOrSubWidget("chan_out_green_spinbox",KBG_OUTPUT_CHANNEL,0,342,KEYBOARD_PANEL_TOP+102,0,16,51,0);  
  
  (kf_enabled)?(
    gfx_x = 470; gfx_y = KEYBOARD_PANEL_TOP + 106;
    gfx_rgb(TH.ROUTING_INFO_NOT_OK);
    gfx_drawstr("Red out");
 
    drawAddOrSubWidget("chan_out_red_spinbox",KBR_OUTPUT_CHANNEL,0,537,KEYBOARD_PANEL_TOP+102,-1,16,51,0);  
  );
);

function drawKeyboardPanel() 
   local(kf_enabled, loff, left, top, white_key_width, key_height_top, key_height_bottom, key_height_full, 
         bk, key_top, key_offset, key_width, oct, octoff, in_oct_pos, in_rect, i, imax,
         normalized_key_offset, normalized_key_width, str,
         wkcount)
(
  kf_enabled = KEYBOARD_FILTERING_ENABLED[0];

  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,KEYBOARD_FILTERING_TOP,KEYBOARD_PANEL_WIDTH,20);
  
  // Enable/Disable
  drawEnableDisableButton(KEYBOARD_FILTERING_ENABLED,0,KEYBOARD_FILTERING_TOP + 3,10);

  // Header text
  gfx_rgb(TH.HEADER_TEXT);
  gfx_x = 87; gfx_y = KEYBOARD_FILTERING_TOP+7;
  
  gfx_drawstr((kf_enabled)?("Keyboard splitting"):("Keyboard splitting (All keys are green)"));
  
  // Octava offset 
  drawAddOrSubWidget("keyboard_offset",CURRENT_OCTAVA_OFFSET,0,12,KEYBOARD_FILTERING_TOP+50,-1,2,616,1); 
    
  // 88 keys keyboard
  // A0 : midi note 21
  // C8 : midi note 108
  
  loff              = 30;
  white_key_width   = 11;
  key_height_top    = 35;
  key_height_bottom = 25;
  key_height_full   = key_height_top + key_height_bottom;
  
  key_top           = KEYBOARD_FILTERING_TOP + 30; // Header skip
  
  // Top part of the keyboard
  octoff = CURRENT_OCTAVA_OFFSET[0];
  i      = (octoff * 12) + 12; 
  imax   = i + (12 * 8); (imax > 128)?(imax = 128);
  while(i<imax) (
    bk = keyIsBlack(i);
      
    oct         = floor(i / 12);
    in_oct_pos  = i%12;
    
    normalized_key_offset = OCTAVE_TOP_KEY_OFFSETS[in_oct_pos];
    normalized_key_width  = OCTAVE_TOP_KEY_WIDTHS[in_oct_pos];
    
    // G9
    (i == 127)?(normalized_key_width = 0.5);
    
    key_offset = loff + (normalized_key_offset + (oct - octoff - 1) * 7) * white_key_width; 
    key_width  = normalized_key_width * white_key_width;
    
    (key_width != 0)?(
    
      // Key should appear at the top part of the keyboard
      left = key_offset;
      top  = key_top;
      
      // Draw white keys
      (!kf_enabled)?(
        // Keyboard filtering not enabled, all keys are grayed out
        gfx_rgb((bk)?(TH.KEY_BLACK_DISABLED):(TH.KEY_WHITE_DISABLED));
        gfx_rect(left,top,key_width,key_height_top);
      ):(
      
        // Keyboard filtering enabled, color depends on key conf
        (KEYBOARD_FILTERED_NOTES[i] == 1)?(
          // The Key is disabled
          gfx_rgb((bk)?(TH.KEY_BLACK_FILTERED_OUT):(TH.KEY_WHITE_FILTERED_OUT));
        ):(
          // The Key is enabled 
          gfx_rgb((bk)?(TH.KEY_BLACK_FILTERED_IN):(TH.KEY_WHITE_FILTERED_IN));
        );
        gfx_rect(left,top,key_width,key_height_top);
        
        in_rect = (mouse_x >= left && mouse_y >= top && mouse_x <= (left+key_width) && mouse_y <= (top+key_height_top));       
        (in_rect)?(
          
          (mouse_click == 1)?( 
            // Remember that the keybord has click focus
            mouse_capturator      = "keyboard";
            // We clicked on a key, we are colorizing all future hovered keys
            // With the opposite color.
            keyboard_key_enabling = ((KEYBOARD_FILTERED_NOTES[i] == 1)?(0):(1));
          );
          
          (mouse_cap == 1 && mouse_capturator == "keyboard")?(
            
            // Ok we are changing the status of this key
            KEYBOARD_FILTERED_NOTES[i] = keyboard_key_enabling;
          );  
        );
        
      );

      // Black separation lines
      gfx_rgb(TH.BACKGROUND);
      gfx_line(left+key_width-1,top,left+key_width-1,top+key_height_top-1);
      
      (bk)?(
        gfx_line(left,top+key_height_top-1,left+key_width-1,top+key_height_top-1);
        
        // Key press marker
        (KEY_VELOCITIES[i] > 0)?(
          drawKeyboardKeyMarker(left + floor(key_width/2) -1,top+floor(key_height_top/2));
        );
      );
    );
    
    i+=1;
  );

  // Bottom part of the keyboard
  wkcount = 0; 
  i       = (CURRENT_OCTAVA_OFFSET[0] * 12) + 12; 
  imax  = i + (12 * 8); (imax > 128)?(imax = 128);
  while(i<imax) (
  
    oct = floor(i / 12);
    bk  = keyIsBlack(i);
    
    (!bk)?(
      left = loff+wkcount*white_key_width;
      top  = key_top + key_height_top;
    
      // Draw white keys
      (!kf_enabled)?(
        // Keyboard filtering not enabled, all keys are grayed out
        gfx_rgb(TH.KEY_WHITE_DISABLED);
        gfx_rect(left,top,white_key_width,key_height_bottom);
      ):
      (
        // Keyboard filtering enabled, color depends on key conf
        (KEYBOARD_FILTERED_NOTES[i] == 1)?(
          // The Key is disabled
          gfx_rgb(TH.KEY_WHITE_FILTERED_OUT);
        ):(
          // The Key is enabled 
          gfx_rgb(TH.KEY_WHITE_FILTERED_IN);
        );
        
        gfx_rect(left,top,white_key_width,key_height_bottom); 
      
        in_rect = (mouse_x >= left && mouse_y >= top && mouse_x <= (left+white_key_width) && mouse_y <= (top+key_height_bottom));       
        (in_rect)?(
          
          (mouse_click == 1)?( 
            // Remember that the keybord has click focus
            mouse_capturator      = "keyboard";
            // We clicked on a key, we are colorizing all future hovered keys
            // With the opposite color.
            keyboard_key_enabling = ((KEYBOARD_FILTERED_NOTES[i] == 1)?(0):(1));
          ); 
          
          (mouse_cap == 1 && mouse_capturator == "keyboard")?(
  
            //Ok we are changing the status of this key
            KEYBOARD_FILTERED_NOTES[i] = keyboard_key_enabling;
          );
        );
      );  
            
      // Black separation line
      gfx_rgb(TH.BACKGROUND);
      gfx_line(left+white_key_width-1,top,left+white_key_width-1,top+key_height_bottom-1);
      
      // Key press marker
      (KEY_VELOCITIES[i] > 0)?(
        drawKeyboardKeyMarker(left + floor(white_key_width/2) -1,top+floor(key_height_bottom/2));
      );
      
      (i%12 == 0)?(
        gfx_rgb(TH.KEY_OCTAVA_NUMBER);
        gfx_xy(left+1,top+14);
        str = #;
        sprintf(str, "%d", oct-1);
        gfx_drawstr(str);
      );
      
      // Increment white key counter
      wkcount += 1;
    );
    
    // Next key
    i+=1; 
  );
  
  drawKeyboardChannelsPanel();
  drawTransposePanel();
);

function drawBottomBanner()
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,gfx_h-20,gfx_w,20);
      
  // Header text
  gfx_rgb(TH.HEADER_TEXT);
  gfx_x = 6; gfx_y = gfx_h - 14;
  gfx_drawstr("Midi CC Mapper X (3.5) by Benjamin 'Talagan' Babut - Dedicated to Kenji Kawai"); 

  drawSwitchButton(GUI_MODE,0,gfx_y-4,gfx_w-134,"Global settings","Back to plugin");
);

function drawGlobalSettingsPanel() 
  local(l ,t, r, b, w, in_rect)
(
  // Header Background
  gfx_rgb(TH.HEADER);
  gfx_rect(0,0,gfx_w,20);
  
  gfx_rgb(TH.HEADER_TEXT);
  gfx_x= 10; gfx_y = 7;
  gfx_drawstr("Global Settings"); 
  
  // Add an additional button for going back (one never knows)
  drawSwitchButton(GUI_MODE,0,4,gfx_w - 134,"Global settings","Back to plugin");

  // High Res input option
  drawOnOffButton(HIGHRES_INPUT_ENABLED,0,50,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_x= 100; gfx_y = 54;
  gfx_drawstr("High-Res midi input"); 
  
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_x= 100; gfx_y = 74;
  gfx_drawstr("If this option is on, all LSB CCs become 'unroutable' : they are aggregated"); 
  gfx_x= 100; gfx_y = 88;
  gfx_drawstr("to their MSB counterparts to form High-Res midi CC values. To route these"); 
  gfx_x= 100; gfx_y = 102;
  gfx_drawstr("values in that configuration, you should route the MSB CC."); 
    
  // Firewall option 
  drawOnOffButton(DROP_UNROUTED_CC_MESSAGES,0,120,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_x= 100; gfx_y = 124;
  gfx_drawstr("Drop unrouted CC messages"); 
  
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_x= 100; gfx_y = 144;
  gfx_drawstr("If this option is on, all CC messages from unrouted controls are dropped."); 
  gfx_x= 100; gfx_y = 158;
  gfx_drawstr("This makes the plugin acts as a firewall for the CC controls."); 
  
  // Firewall note
  drawOnOffButton(DROP_UNROUTED_NOTE_MESSAGES,0,180,50);
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_x= 100; gfx_y = 184;
  gfx_drawstr("Drop unrouted Note messages"); 
  
  gfx_rgb(TH.DYN_LABEL_NEUTRAL);
  gfx_x= 100; gfx_y = 204;
  gfx_drawstr("If this option is on, all Note messages that do not match the keyboard input"); 
  gfx_x= 100; gfx_y = 218;
  gfx_drawstr("channel are dropped. This makes the plugin acts as a firewall for the keyboard."); 
  
  // Theme option 
  drawSwitchButton(CURRENT_THEME_NUM,0,240,35,"Dark","Light");
  gfx_rgb(TH.DYN_LABEL_HIGHLIGHT);
  gfx_x= 100; gfx_y = 244;
  gfx_drawstr("Theme"); 
  
  // Reload function library
  w = 204; l = (gfx_w - w)/2; t = 550; r = l + 204; b = t + 15;
  in_rect = (mouse_x >= l && mouse_x <= r && mouse_y >= t && mouse_y <= b);
  
  gfx_rgb((in_rect)?(TH.MONO_B_H):(TH.MONO_B));
  gfx_rect(l,t,r-l,b-t);
  
  gfx_x = l + 10; gfx_y = t+4;
  gfx_rgb(TH.MONO_B_TEXT);
  gfx_drawstr("Reload function library");  
  
  (in_rect && mouse_click == 1)?(
    readLibFiles();
  );
);

function drawGui()
(
  updateTheme();
  gfx_clear = (TH.BACKGROUND & 0xFF) << 16 + (TH.BACKGROUND & 0x00FF00) + (TH.BACKGROUND >> 16) ;
  (GUI_MODE[0] == 1)?(
  //  drawChannelPanel();
    drawKeyboardPanel();
    drawControlPanel();
  ):(
    drawGlobalSettingsPanel();
  );
  drawBottomBanner();
);

function listenToGmemCommands()
  local(si, addr, min_bound, max_bound)
(
  (gmem[GMEM_CMD_STATUS] == 1)?(
    // Take the command
    gmem[GMEM_CMD_STATUS] = 2;
    
    (g_selected_control == -1)?(
      gmem[GMEM_CMD_ERROR]  = 600;
      gmem[GMEM_CMD_STATUS] = 4;
    ):(
      (!CONTROL_ENABLED[g_selected_control])?(
        gmem[GMEM_CMD_ERROR]  = 601;
        gmem[GMEM_CMD_STATUS] = 4;
      ):
      (
        si        = 0; 
        addr      = selectedControlCurveAddress();
        min_bound = controlCurrentMinBound01(g_selected_control);
        max_bound = controlCurrentMaxBound01(g_selected_control);
        
        while(si < CURVESIZE)
        (
          gmem[GMEM_DUMP_CURVE_BUF + si] = ((addr[si]/127.0) - min_bound)/(max_bound - min_bound);
          si += 1;
        );
        gmem[GMEM_CMD_STATUS] = 3;
      );
    );      
  );
);

///////////////////////////////////
// MOUSE EVENT ADDITIONAL LOGIC  //
///////////////////////////////////

function mouseClickAddOn()
(
  // Create a mouse_click event
  (mouse_cap != g_last_mouse_cap)?(
    (mouse_cap == 1)?(mouse_click = 1):(mouse_click = 0);
    g_last_mouse_cap = mouse_cap;    
  ):(
    mouse_click = 0;
  );
  
  // Clear the capturator source
  (mouse_cap == 0)?(
     mouse_capturator = "";
  );
);

function mouseWheelAddon()
(
  mouse_wheel != 0?
  (
    mouse_wheeli = (mouse_wheel>0)?(1):(-1);
  ):(
    mouse_wheeli = 0;
  );
  
  mouse_wheel = 0;
);

//////////////
// UI MAIN  //
//////////////

function ui_main() (
  // Main Routine
  mouseClickAddon();
  mouseWheelAddon();
  drawGui();
  listenToGmemCommands();
);

ui_main();

// TEST LIB LOADING
 
/*
zzz_set_count   = gmem[GMEM_FSET_COUNT];
zzz_test_ben = isFSetFunctionDefined(0,0,0);
zzz_t00 = getFSetFunctionAddress(0,0,0);
zzz_t01 = getFSetFunctionAddress(0,0,1);
zzz_t10 = getFSetFunctionAddress(0,1,0);

#aaa_test = getFSetId(7);
#aaa_test2 = getFSetTab(7);
*/

// TESTS : Convert to i and back
/*
aaa_test_fconv     = midiVelocityHresI2F01(0,0);
midiVelocityHresF012I(aaa_test_fconv);
aaa_test_fconv_h   = g_hres_h;
aaa_test_fconv_l   = g_hres_l;

aaa_vtest_fconv     = midiVelocityHresI2F01(0,0);
midiVelocityHresF012I(aaa_vtest_fconv);
aaa_vtest_fconv_h   = g_hres_h;
aaa_vtest_fconv_l   = g_hres_l;
*/

//===========================================//
//==============     BLOCK     ==============//
//===========================================//
@block

// For a given CONTROL on the UI, try to process the CC message
// The value is not passed. It's already been stored in CC_RECEIVED_VALUES.
function tryProcessCCWithControl(evt, blk_control) 
  local (was_processed, 
         in_val_01, out_val_01, 
         ctrl_input_chan, ctrl_output_chan,
         out_cc_num, out_chan, out_status,
         in_lsb_counterpart, out_lsb_counterpart,
         src_matches, src_cc_matches, src_chan_matches, src_is_enabled, src_matches_and_is_enabled, control_is_not_velocity) 
(
  was_processed = 0;
  
  ctrl_input_chan  = CONTROL_CHAN_SRCS[blk_control];
  ctrl_output_chan = CONTROL_CHAN_DSTS[blk_control];

  // We found in the GUI a Control with is enabled and matches this CC
  src_cc_matches              = (CONTROL_SRCS[blk_control] == evt.cc_num);
  src_chan_matches            = (ctrl_input_chan == evt.chan || ctrl_input_chan == 0); // 0 is ANY
  src_matches                 = src_cc_matches && src_chan_matches;
  src_is_enabled              = (CONTROL_ENABLED[blk_control] == 1);
  src_matches_and_is_enabled  = (src_matches && src_is_enabled);
  control_is_not_velocity     = (blk_control != CONTROL_VELOCITY);
 
  (src_matches_and_is_enabled && control_is_not_velocity) ? (
  
    // Calculate curve result
    in_val_01  = 0;
    
    in_lsb_counterpart = ccLsbCounterpart(evt.cc_num); 
    
    in_lsb_counterpart != -1 && isHighResMidiInputEnabled() ? (
      // It's a high res control. 
      // Read full value and convert.
      in_val_01   = midiCCHresI2F01(CC_RECEIVED_VALUES[evt.cc_num], CC_RECEIVED_VALUES[in_lsb_counterpart]);
    ):(
      // Low res are normalized with a max of 127.0
      in_val_01   = CC_RECEIVED_VALUES[evt.cc_num]/127.0;
    );
  
    // Apply the curve
    out_val_01 = applyCurve(blk_control, in_val_01);
    
    // Save some values for UI feedback (small red circle)
    CONTROL_LAST_IN[blk_control]  = in_val_01 * 127;
    CONTROL_LAST_OUT[blk_control] = out_val_01 * 127;
    
    // Send result
    out_cc_num          = CONTROL_DSTS[blk_control];
    out_lsb_counterpart = ccLsbCounterpart(out_cc_num);
    out_chan            = (ctrl_output_chan == 0)?(evt.chan):(ctrl_output_chan);
    out_status          = (CC_MSG<<4)|(out_chan-1); // Chan : 1-16 ->> 0-15
     
    out_lsb_counterpart != -1 && isHighResMidiOutputEnabledForControl(blk_control) ? (
      // Output high res
      midiCCHresF012I(out_val_01);     
      // Send lsb first then msb
      midiSend(evt.mpos, out_status, out_lsb_counterpart, g_hres_l);
      midiSend(evt.mpos, out_status, out_cc_num,          g_hres_h);
    ):(
      // Output low res, normalize by 127 (max is 127).
      midiSend(evt.mpos, out_status, out_cc_num, roundi(out_val_01 * 127) );
    );
    
    was_processed = 1;
  );

  was_processed;
);

function processCCMessage(evt) 
  local (process_counter, blk_control) 
( 
  // Memorize, may be useful
  CC_RECEIVED_VALUES[evt.cc_num] = evt.cc_val;

  process_counter = 0;
  (isHighResMidiInputEnabled() && isALsbCC(evt.cc_num))?(
  
    // In high res midi, drop all messages coming from lsb channels
    // They've been just stored for aggregation.
    process_counter = 1;
  ):(
  
    // Loop on all controls and see if we could find
    // Some of them linked to that cc.
    blk_control = 0; while(blk_control < CONTROL_COUNT)
    (              
      process_counter += tryProcessCCWithControl(evt, blk_control);
      blk_control     += 1;
    );
  );
  
  process_counter;
);

function processNoteMessage(evt) 
  local(new_key, is_red_key,
    src_chan, dst_chan, src_chan_matches, dst_status,
    was_processed, should_keep_note, 
    has_velocity, velocity_01, out_velocity_01, 
    velocity_control_enabled, should_apply_velocity_to_key, should_transpose, transpose_tgt, velocity_tgt,
    lsb_cc_msg)
(
  was_processed = 0;
  
  // Update key statuses, to be displayed in the gui
  (evt.type == NOTE_OFF_MSG)?(
    // For safety. I don't know if it's useful.
    evt.velocity=0;
  );  
  
  // Save the source velocity, this is for UI feedback
  KEY_VELOCITIES[evt.key] = evt.velocity;
  
  is_red_key       = isKeyboardFilteringEnabled() && isRedKey(evt.key); // Key is green if filtering not enabled
  src_chan         = KB_INPUT_CHANNEL[0];
  src_chan_matches = (src_chan == evt.chan || src_chan == 0); // 0 is ANY
  
  (src_chan_matches)?(
  
    dst_chan  = (is_red_key)?(KBR_OUTPUT_CHANNEL[0]):(KBG_OUTPUT_CHANNEL[0]);  
    dst_chan  = (dst_chan == 0)?(evt.chan):(dst_chan);
  
    // -1 is the drop channel.
    (dst_chan != -1)?( 
    
      new_key = evt.key;
          
      transpose_tgt    = KEYBOARD_TRANSPOSE_APPLY_TO[0];
      should_transpose = (transpose_tgt == 0 || (!is_red_key && transpose_tgt == 1) || (is_red_key && transpose_tgt == 2));
      
      // Transpose if asked to.
      (should_transpose)?(
        (KEYBOARD_TRANSPOSE_ENABLED[0])?(
          new_key = evt.key + KEYBOARD_TRANSPOSE_8VA[0]*12 + KEYBOARD_TRANSPOSE_SEMI_TONES[0];      
        );
      );
      
      // Transposition should not be outside midi range
      (new_key >= 0 && new_key <= 127)?(
      
        // Caution : Note OFF can be either (NOTE_OFF_MSG) or (NOTE_ON_MSG + velocity zero)
        // Thus, the following code should be tolerant :
        // Velocity 0 should not be changed to something else.
        
        has_velocity                  = (evt.velocity!=0);  
        velocity_01                   = 0;         
         
        // CALCULATE INPUT VALUE HI/LOW RES
        (isHighResMidiInputEnabled())?(
          (has_velocity)?(
            // Seems to me we should sub 1 to the velocity (MSB)
            // To be continuous starting from 0 (First non-null HR velocity starts at 0x0080, MSB is non null)
            velocity_01 = midiVelocityHresI2F01(evt.velocity-1, CC_RECEIVED_VALUES[88]); 
            CC_RECEIVED_VALUES[88] = 0; // Clear the LSB. 
          );
        ):(
          velocity_01 = evt.velocity/127;
        );
      
        // APPLY THE CURVE
        out_velocity_01 = 0;
        has_velocity?(    
          // Apply velocity curve if needed
          velocity_control_enabled      = CONTROL_ENABLED[CONTROL_VELOCITY];
          velocity_tgt                  = KEYBOARD_VELOCITY_APPLY_TO[0];
          should_apply_velocity_to_key  = (velocity_tgt == 0 || (!is_red_key && velocity_tgt == 1) || (is_red_key && velocity_tgt == 2));
       
          (velocity_control_enabled && should_apply_velocity_to_key)?(
            out_velocity_01                     = applyCurve(CONTROL_VELOCITY, velocity_01);
        
            // Save for UI feedback (red circle).
            // Do it only when there's some velocity, having the circle 
            // going back to 0 each time we release a key is annoying
            CONTROL_LAST_IN[CONTROL_VELOCITY]   = velocity_01*127;
            CONTROL_LAST_OUT[CONTROL_VELOCITY]  = out_velocity_01*127;
          ):(
            // Just keep the value as is (bypass any calculation)
            out_velocity_01 = velocity_01;
          )   
        );
      
        // Create out status, remap chan to to 0-15
        dst_status = (evt.type << 4) | (dst_chan-1);
                   
        // SEND THE FINAL RESULT HI/LOW RES
        (isHighResMidiOutputEnabledForControl(CONTROL_VELOCITY))?(
         
          lsb_cc_msg = ((CC_MSG << 4) | evt.chan);
          (has_velocity)?(
            // Send modified velocity
            midiVelocityHresF012I(out_velocity_01);
        
            // Note : if pen drawn
            // g_hres_l will always be = 127 due to the drawing resolution
            midisend(evt.mpos, lsb_cc_msg, 88, g_hres_l);
            midisend(evt.mpos, dst_status, keyToMidiNote(new_key), g_hres_h);
          ):(
            // Send 0-velocity note.
            midisend(evt.mpos, lsb_cc_msg, 88, 0);
            midisend(evt.mpos, dst_status, keyToMidiNote(new_key), 0);
          );
        ):
        (   
          // This is compatible with zero-velocity
          midisend(evt.mpos, dst_status, keyToMidiNote(new_key), roundi(out_velocity_01 * 127) );
        );
      
      ); // <- Transposition is not outside range 
      
    ); // <- dst chan is not drop
  
    // As long as the input channel is concerned
    // Consider the event as treated.
    was_processed = 1;
    
  ); // <- src chan matches  
);

function mainLoop() 
  local(mpos,msg1,msg2,msg3,was_routed)
(

  while(midirecv(mpos, msg1, msg2, msg3))
  (
  
    evt = 0;
    evt.mpos   = mpos;
    evt.msg1   = msg1;
    evt.msg2   = msg2;
    evt.msg3   = msg3;
    evt.status = msg1;
    evt.type   = (msg1 >> 4)& 0x0F;
    evt.chan   = (msg1 & 0x0F)+1; // 1-16, not 0-15
    evt.cc_num = 0;
    evt.cc_val = 0;
     
    // status    = msg1;
    // statusHi  = (status >> 4) & 0x0F;   // Type of message
    // statusLo  = (status & 0x0F);        // Channel
    
    // status = msg1;
    // statusHi = (msg1/16)|0;
    // statusLo = msg1-(statusHi*16);
        
    (evt.type == CC_MSG) ? (
      
      // Translate into "cc words" for more comprehensible code
      evt.cc_num = msg2; 
      evt.cc_val = msg3;
        
      // CC LEARN
      (isCCLearning() && g_selected_control != -1 && isCCLearnable(evt.cc_num))?(
        CONTROL_SRCS[g_selected_control] = evt.cc_num;
        disableCCLearn();
      );
        
      was_routed = processCCMessage(evt);   
      !was_routed && !shouldDropUnroutedCCMessages()?(
        // Re-send message
        midisend(mpos, msg1, msg2, msg3);
      ); 
    ):
    (
      // NOTE MESSAGE
      (evt.type == NOTE_ON_MSG || evt.type == NOTE_OFF_MSG)?(
        
        evt.note      = msg2;
        evt.key       = midiNoteToKey(evt.note);
        evt.velocity  = msg3;
           
        was_routed    = processNoteMessage(evt);
        !was_routed && !shouldDropUnroutedNoteMessages()?(
          // Re-send message
          midisend(mpos, msg1, msg2, msg3);
        );
      ):
      (
        // Not a control event, send as is
        midisend(mpos, msg1, msg2, msg3);
      );
    );
  );
);

mainLoop();
