desc: MIDI CC fluctuation
author: Michael Schnell (mschnell@bschnell.de)
version: 2.0
changelog:
  Added option for standard resolution CCs
  Some bug fixes
provides: [data] mschnell_MIDI CC fluctuation/Voice Doubling.RfxChain
about:
  ## Description 

    MIDI CC fluctuation generates a randomly fluctuating 14 bit (high resolution) CC Midi data stream.

    The fluctuation is generated by randomly increasing / decreasing the current CC value. The way this is done, can be "humanized" by several parameters.

    "Midi Channel" selects the Midi channel to output the CC messages

    "CC" selects the CC number. CC#s 0..31 with "HR" notification  are selectable for high resolution CCs, 0...127  are selectable for standard resolution CCs

    "Delta wide (~ ^1)" controls the amount the delta increasing / decreasing the output as a equally distributed random value

    "Delta mid (~ ^3)" controls the amount the delta increasing / decreasing the output as a random value controls the that covers the extreme ends less often

    "Delta narrow (~ ^5)" controls the amount the delta increasing / decreasing the output as a random value controls the that covers the extreme ends even less often

    "Hold speed": for humanizing, a directivity of the fluctuation is implemented. This parameter defines how often then the preferred direction and migrating speed is supposed to change

    "Hold mix" defines the intensity of the directivity vs a purely random walk 

    "Speed (Roughness, exponential scale)" controls the total amount of the random value that is added to the current output value. The actual factor is calculated using an exponential curve regarding the value set here.

    "Fade (~ ^1)" defines the force to pull back the output to the center in a linear (proportional to the displacement) way.

    "Fade if wide (~ ^3)" defines the force to pull back the output to the center in a way increasing with the displacement

    "Fade if even wider (~ ^5)" defines the force to pull back the output to the center in a way increasing with the displacement even more.

    "maximum step" defines the step size (per audio block) to the raw output is allowed to fluctuate

    "gain" and "bias": values to multiply the output with and to add to the output

    The other sliders show the generate signals in realtime: 

    "Delta": the current raw random delta value

    "Hold": the current hold / directivity value

    "Delta with Hold": value to be added to the raw result

    "Result raw": Result before applying gain and bias

    "Result -1 ... 1": Normalized output value

    "Result Midi (0 ... 16383)": High resolution Midi CC output value

    A graphics shows the history of the "Delta with Hold" value in blue and the history of the output value in yellow. The gray line defines the center (Zero / CC value = 8191), the purple line shows the average of the output during the shown range of time.

//tags: MIDI processing filter
//author: MSchnell


// these lines tell Reaper the effect has no audio input/output,
// which enables processing optimizations.
// MIDI-only FX should always have these lines.
in_pin:none
out_pin:none


slider1:  0<0,15,1{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>Midi Channel 
slider2:  16<0,128,1{0 Bank Sel HR,1 Mod Wheel HR,2 Breath HR,3+35 HR,4 Foot P HR,5 Porta HR,6 Data Entry HR,7 Vol HR,8 Balance HR,9+42 HR,10 Pan HR,11 Expression HR,12 Ctrl 1 HR,13 Ctrl 2 HR,14+46 HR,15+47 HR,16 GP Slider HR,17 GP Slider HR,18 GP Slider HR,19 GP Slider HR,20+52 HR,21+53 HR,22+54 HR,23+55 HR,24+56 HR,25+57 HR,26+58 HR,27+59 HR,28+60 HR,29+61 HR,30+62 HR,31+63 HR,0 Bank Sel M,1 Mod Wheel M,2 Breath M,3,4 Foot P M,5 Porta M,6 Data Entry M,7 Vol M,8 Balance M,9,10 Pan M,11 Expression M,12 Ctrl 1 M,13 Ctrl 2 M,14,15,16 GP Slider 1,17 GP Slider 2,18 GP Slider 3,19 GP Slider 4,20,21,22,23,24,25,26,27,28,29,30,31,32 Bank Sel L,33 Mod Wheel L,34 Breath L,35,36 Foot P L,37 Porta L,38 Data Entry L,39 Vol L,40 Balance L,41,42 Pan L,43 Expression L,44 Ctrl 1 L,45 Ctrl 2 L,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64 Hold P sw,65 Porta sw,66 Sustenuto sw,67 Soft P sw,68 Legato P sw,69 Hold 2 P sw,70 S.Variation,71 S.Timbre,72 S.Release,73 S.Attack,74 S.Brightness,75 S.Ctrl 6,76 S.Ctrl 7,77 S.Ctrl 8,78 S.Ctrl 9,79 S.Ctrl 10,80 GP B.1 sw,81 GP B.2 sw,82 GP B.3 sw,83 GP B.4 sw,84,85,86,87,88,89,90,91 Effects Lv,92 Trem Lv,93 Chorus Lv,94 Celeste Lv,95 Phaser Lv,96 Data B. Inc,97 Data B. Dec,98 NRP L,99 NRP M,100 RP L,101 RP M,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,N/A}>In CC# 
slider3:  0.5<0,1,0.01>Delta wide (~ ^1)
slider4:  0<0,1,0.01>Delta mid (~ ^3)
slider5:  1<0,1,0.01>Delta narrow (~ ^5)
slider6:  0.01<0,0.1,0.001>Hold speed
slider7:  0.9<0,1,0.001>Hold mix 
slider8:  0.1<0,1,0.001>Speed (Roughness, exponential scale) 
slider9:  0.01<0,1,0.01>Fade (~ ^1)
slider10: 0.1<0,10,0.1>Fade if wide (~ ^3)
slider11: 0.2<0,20,0.1>Fade if even wider (~ ^5)
slider12: 0.0001<0,0.1,0.0001>maximum step
slider13: 1<0,10,0.1>gain
slider14: 0<-1,1,0.01>bias

slider20: 0<-1,1,0.0001>Delta
slider21: 0<-1,1,0.0001>Hold
slider22: 0<-1,1,0.0001>Delta with Hold
slider23: 0<-1,1,0.0001>Result raw
slider24: 0<-1,1,0.0001>Result -1 ... 1
//slider25: 8191<0,16383,1>Result Midi (HR: 0.. 16383, LR: 0...127)
slider25: 8191<0,0,1>Result Midi (HR: 0.. 16383, LR: 0...127)


@init
  CC_MSG      =  0xB0; // 11;  
  s  = 0;
  h  = 0;
  result= 0;
  msg31 = -1;
  msg32 = -1;
  offset = 0;
  _p = 0;
  _result = 0;
  _delta  = 2560;
  memset(_result, 8192, 2560);
  memset(_delta,  0,    2560);
  
@slider
  msg1  = CC_MSG + slider1;
  msg21 = slider2;
  msg21 > 31 ? (
//    hr = 0;
    msg21 -= 32;
    msg22 = -1;
   ) : ( 
//    hr = 1;
    msg22 = msg21 + 32;
  ); 
  
  a1 = slider3;
  a3 = slider4;
  a5 = slider5;
  aa = a1 + a3 + a5;
  aa > 1 ? (
    a1 /= aa;
    a3 /= aa;
    a5 /= aa;
  );
  
  s_h  = slider6;
  v_h  = slider7;
  
  sp = slider8;
  sp = exp(sp*log(200)) / 200;
  
  s1 = slider9;
  s3 = slider10;
  s5 = slider11;
  ss = s1 + s3 + s5;
  ss > 1 ? (
    s1 /= ss;
    s3 /= ss;
    s5 /= ss;
  );
//  s1 *= sp;
  
  ms   = slider12;
  gain = slider13;
  bias = slider14;
  
  


@block 
  r  = rand();
  v1 = r*2 - 1;
  v2 = v1*v1;
  v3 = v1*v2;
  v5 = v3*v2;
  va = a1*v1 +a3*v3 + a5*v5;
  slider20 = va;
  
/*
  va > h + hyst ? (
    h = va;
    va = -va;                 // avoid exeeding ly ar jump
   ) : (
    va < h - hyst ? (
      h = va;
      va = -va;               // avoid exeeding ly ar jump
    );  
  );
*/
  r = rand();
  r < s_h ? ( 
    h = va;
    va = -va;               // avoid exeeding ly ar jump    
  );
  
  slider21 = h;
  
  vh = (1-v_h)*va + v_h*h;
  slider22 = vh;
  _delta[_p] = vh;
  
  s += sp*vh;
  
  s < -1 ? s = -1;
  s >  1 ? s =  1;

  d1 = s;
  d2 = s*s;
  d3 = d2*s;
  d5 = d3*d2;
  s -= d1*s1;
  s -= d3*s3;
  s -= d5*s5;
  
  result < s-ms ? (
     result += ms;
    ) : result > s + ms ? (
      result -= ms;
   ) : ( 
    result = s;
  );  
  
  slider23 = result;

  result_1 = result * gain + bias;
  result_1 < -1 ? result_1 = -1;
  result_1 >  1 ? result_1 =  1;
  
  slider24 = result_1;
  
  
  
  _m = (result_1 + 1) / 2;  
  m  = ((_m * 16384) - 0.5) | 0; 
  m  > 16383 ? (
    m = 16383;
   ) : m < 0 ? ( 
    m = 0;
  );
  m1 = (m / 128) | 0;
  m2 = m - 128 * m1; 

  msg31 != m1 ? (
    msg31 = m1;
    midisend(offset, msg1, msg21, msg31);    
  );
  msg22 >= 0 ? (
    slider25 = m;
    msg32 != m2 ? (
      msg32 = m2;
      midisend(offset, msg1, msg22, msg32);    
    );  
   ) : ( 
    slider25 = msg31;
  );
  
  _p >= _w ? _p = 0 : _p += 1;
  _result[_p] = m;

@sample  

@gfx 640 400
  _w = gfx_w;  
  _w > 2560 ? _w = 2560;    // HDMI
  gfx_r=gfx_g=gfx_b=0; gfx_a=1;
  gfx_x=gfx_y=0;
  gfx_rectto(gfx_w, gfx_h);
  _a = 0;
  _min = 16384;
  _max = 0;
  _pp = 0;
  loop (_w,
    _y = _result[_pp];
    _a += _y;
    _min > _y ? _min = _y;
    _max < _y ? _max = _y;
    _pp += 1;
  );
  _a /= _w;
  _min = 8192 - _min;
  _max = _max - 8192;
  _max < _min ? _max = _min;
  _max < 5 ? _max = 5;
  _fact = gfx_h / _max / 2;
  _offs = gfx_h / 2;
  _offs += 8191 * _fact;


  _min_d = 1;
  _max_d = -1;
  _pp = 0;
  loop (_w,
    _y = _delta[_pp];
//    _a += _y;
    _min_d > _y ? _min_d = _y;
    _max_d > _y ? _max_d = _y;
    _pp += 1;
  );
//  _a /= _w;
  _min_d = - _min_d;
  _max_d < _min_d ? _max_d = _min_d;
  _fact_d = gfx_h / _max_d / 2;
  _offs_d = gfx_h /2;


  _y = gfx_h / 2;
  gfx_x = 0;
  gfx_y = _y;
  gfx_r=gfx_g=gfx_b=0.5; 
  gfx_lineto(_w-1, _y); 
 
  gfx_b = 0.75; gfx_r=gfx_g=0; 
  _x = 0;
  gfx_x = 0;
  _pp = _p+1;
  _pp > _w ? _pp = 0;    
  _y = _offs - _delta[_pp] * _fact_d;
  gfx_y = _y;
  loop (_w-1,
    _x += 1;
    _pp += 1;
    _pp > _w ? _pp = 0;    
    _y = _offs_d - _delta[_pp] * _fact_d;
    gfx_lineto(_x, _y);
  );  
  
  _y = _offs - _a * _fact;
  gfx_x = 0;
  gfx_y = _y;
  gfx_g = 0; 
  gfx_r= 1; 
  gfx_g=gfx_b=0.5; 
  gfx_lineto(_w-1, _y); 
  
  gfx_x = 120;
  gfx_y = _y + 4;
  gfx_y +8 >= gfx_h ? gfx_y -= 13;
  _a_ = _a - 8192;
  _a_ < 0 ? (
    _a_ += 0.5;
    _a_ = _a_|0;
   ) : ( 
    _a_ = - _a_;
    _a_ += 0.5;
    _a_ = _a_|0;
    _a_ = - _a_;
  ); 
  
  _xx = msg22 >= 0 ? _a+0.5 : _a/128 - 0.5;
  gfx_printf("%d  (%d)", _xx, _a_);  
  
  gfx_r=gfx_g=gfx_b=0.5; 
  gfx_x = 10;
  gfx_y = gfx_h/2 + 4;
  _xx = msg22 >= 0 ? 8191 : _xx = 63;
  gfx_printf("%d  (%d)",_xx, 0);  
  
  gfx_r=gfx_g=gfx_b=0.5; 
  gfx_x = 10;
  gfx_y = 4;
  _xx = msg22 >= 0 ? 8192.5+_max :  63.5+_max/128;
  gfx_printf("%d  (%d)", _xx, _max - 0.5);  
  
  gfx_x = 10;
  gfx_y = gfx_h - 10;
  _xx = msg22 >= 0 ? 8191.5-_max : 63.5 -_max/128;
  gfx_printf("%d  (%d)", _xx, -_max + 0.5);  

  gfx_b = 0; gfx_r=gfx_g=1; 
  _x = 0;
  gfx_x = 0;
  _pp = _p+1;
  _pp > _w ? _pp = 0;    
  _y = _offs - _result[_pp] * _fact;
  gfx_y = _y;
  loop (_w-1,
    _x += 1;
    _pp += 1;
    _pp > _w ? _pp = 0;    
    _y = _offs - _result[_pp] * _fact;
    gfx_lineto(_x, _y);
  );
