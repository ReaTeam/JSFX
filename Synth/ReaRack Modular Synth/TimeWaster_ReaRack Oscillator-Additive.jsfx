version: 1.0.2
desc:ReaRack - Oscillator-Additive
noindex: true
author: Malcolm Smith
about: Audio oscillator module for the ReaRack modular JSFX synth system.
changelog: Version 1.0.2 (18/8/2017) Fixed a bug in the master/slave function (wrong slider numbers).

  Version 1.0.0 (15/3/2017) Initial release.
  Version 1.0.1 (11/7/2017) Removed some rubbish from the graphics section
  and removed a few siliders used during development. Fixed an issue with white noise volume.
  Version 1.0.2 (18/8/2017) Fixed a bug in the master/slave function (wrong slider numbers).

  Copyright(C) 2016 and later, Malcolm Smith (username 'Time Waster' on REAPER forums).
  License: LGPL - http://www.gnu.org/licenses/lgpl.html

slider1:0<0,128,1{Off,0 Bank Sel M,1 Mod Wheel M,2 Breath M,3,4 Foot P M,5 Porta M,6 Data Entry M,7 Vol M,8 Balance M,9,10 Pan M,11 Expression M,12 Ctrl 1 M,13 Ctrl 2 M,14,15,16 GP Slider 1,17 GP Slider 2,18 GP Slider 3,19 GP Slider 4,20,21,22,23,24,25,26,27,28,29,30,31,32 Bank Sel L,33 Mod Wheel L,34 Breath L,35,36 Foot P L,37 Porta L,38 Data Entry L,39 Vol L,40 Balance L,41,42 Pan L,43 Expression L,44 Ctrl 1 L,45 Ctrl 2 L,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64 Hold P sw,65 Porta sw,66 Sustenuto sw,67 Soft P sw,68 Legato P sw,69 Hold 2 P sw,70 S.Variation,71 S.Timbre,72 S.Release,73 S.Attack,74 S.Brightness,75 S.Ctrl 6,76 S.Ctrl 7,77 S.Ctrl 8,78 S.Ctrl 9,79 S.Ctrl 10,80 GP B.1 sw,81 GP B.2 sw,82 GP B.3 sw,83 GP B.4 sw,84,85,86,87,88,89,90,91 Effects Lv,92 Trem Lv,93 Chorus Lv,94 Celeste Lv,95 Phaser Lv,96 Data B. Inc,97 Data B. Dec,98 NRP L,99 NRP M,100 RP L,101 RP M,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127}>CC Input (Pitch Modulaton)
slider2:0<0,128,1{Off,0 Bank Sel M,1 Mod Wheel M,2 Breath M,3,4 Foot P M,5 Porta M,6 Data Entry M,7 Vol M,8 Balance M,9,10 Pan M,11 Expression M,12 Ctrl 1 M,13 Ctrl 2 M,14,15,16 GP Slider 1,17 GP Slider 2,18 GP Slider 3,19 GP Slider 4,20,21,22,23,24,25,26,27,28,29,30,31,32 Bank Sel L,33 Mod Wheel L,34 Breath L,35,36 Foot P L,37 Porta L,38 Data Entry L,39 Vol L,40 Balance L,41,42 Pan L,43 Expression L,44 Ctrl 1 L,45 Ctrl 2 L,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64 Hold P sw,65 Porta sw,66 Sustenuto sw,67 Soft P sw,68 Legato P sw,69 Hold 2 P sw,70 S.Variation,71 S.Timbre,72 S.Release,73 S.Attack,74 S.Brightness,75 S.Ctrl 6,76 S.Ctrl 7,77 S.Ctrl 8,78 S.Ctrl 9,79 S.Ctrl 10,80 GP B.1 sw,81 GP B.2 sw,82 GP B.3 sw,83 GP B.4 sw,84,85,86,87,88,89,90,91 Effects Lv,92 Trem Lv,93 Chorus Lv,94 Celeste Lv,95 Phaser Lv,96 Data B. Inc,97 Data B. Dec,98 NRP L,99 NRP M,100 RP L,101 RP M,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127}>CC Input (Pulse Width Modulaton)
slider3:0<0,128,1{Off,0 Bank Sel M,1 Mod Wheel M,2 Breath M,3,4 Foot P M,5 Porta M,6 Data Entry M,7 Vol M,8 Balance M,9,10 Pan M,11 Expression M,12 Ctrl 1 M,13 Ctrl 2 M,14,15,16 GP Slider 1,17 GP Slider 2,18 GP Slider 3,19 GP Slider 4,20,21,22,23,24,25,26,27,28,29,30,31,32 Bank Sel L,33 Mod Wheel L,34 Breath L,35,36 Foot P L,37 Porta L,38 Data Entry L,39 Vol L,40 Balance L,41,42 Pan L,43 Expression L,44 Ctrl 1 L,45 Ctrl 2 L,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64 Hold P sw,65 Porta sw,66 Sustenuto sw,67 Soft P sw,68 Legato P sw,69 Hold 2 P sw,70 S.Variation,71 S.Timbre,72 S.Release,73 S.Attack,74 S.Brightness,75 S.Ctrl 6,76 S.Ctrl 7,77 S.Ctrl 8,78 S.Ctrl 9,79 S.Ctrl 10,80 GP B.1 sw,81 GP B.2 sw,82 GP B.3 sw,83 GP B.4 sw,84,85,86,87,88,89,90,91 Effects Lv,92 Trem Lv,93 Chorus Lv,94 Celeste Lv,95 Phaser Lv,96 Data B. Inc,97 Data B. Dec,98 NRP L,99 NRP M,100 RP L,101 RP M,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127}>CC Input (No. of Harmonics Modulaton)
// Choose your preferred note naming convention:
//slider4:0<0,128,1{MIDI note,C0,C#0,D0,D#0,E0,F0,F#0,G0,G#0,A0,A#0,B0,C1,C#1,D1,D#1,E1,F1,F#1,G1,G#1,A1,A#1,B1,C2,C#2,D2,D#2,E2,F2,F#2,G2,G#2,A2,A#2,B2,C3,C#3,D3,D#3,E3,F3,F#3,G3,G#3,A3,A#3,B3,C4,C#4,D4,D#4,E4,F4,F#4,G4,G#4,A4,A#4,B4,C5,C#5,D5,D#5,E5,F5,F#5,G5,G#5,A5,A#5,B5,C6,C#6,D6,D#6,E6,F6,F#6,G6,G#6,A6,A#6,B6,C7,C#7,D7,D#7,E7,F7,F#7,G7,G#7,A7,A#7,B7,C8,C#8,D8,D#8,E8,F8,F#8,G8,G#8,A8,A#8,B8,C9,C#9,D9,D#9,E9,F9,F#9,G9,G#9,A9,A#9,B9,C10,C#10,D10,D#10,E10,F10,F#10,G10}> Pitch
slider4:0<0,128,1{Any (MIDI note input),C-1,C#-1,D-1,D#-1,E-1,F-1,F#-1,G-1,G#-1,A-1,A#-1,B-1,C0,C#0,D0,D#0,E0,F0,F#0,G0,G#0,A0,A#0,B0,C1,C#1,D1,D#1,E1,F1,F#1,G1,G#1,A1,A#1,B1,C2,C#2,D2,D#2,E2,F2,F#2,G2,G#2,A2,A#2,B2,C3,C#3,D3,D#3,E3,F3,F#3,G3,G#3,A3,A#3,B3,C4,C#4,D4,D#4,E4,F4,F#4,G4,G#4,A4,A#4,B4,C5,C#5,D5,D#5,E5,F5,F#5,G5,G#5,A5,A#5,B5,C6,C#6,D6,D#6,E6,F6,F#6,G6,G#6,A6,A#6,B6,C7,C#7,D7,D#7,E7,F7,F#7,G7,G#7,A7,A#7,B7,C8,C#8,D8,D#8,E8,F8,F#8,G8,G#8,A8,A#8,B8,C9,C#9,D9,D#9,E9,F9,F#9,G9}>Pitch
//slider4:0<0,128,1{MIDI note,C-2,C#-2,D-2,D#-2,E-2,F-2,F#-2,G-2,G#-2,A-2,A#-2,B-2,C-1,C#-1,D-1,D#-1,E-1,F-1,F#-1,G-1,G#-1,A-1,A#-1,B-1,C0,C#0,D0,D#0,E0,F0,F#0,G0,G#0,A0,A#0,B0,C1,C#1,D1,D#1,E1,F1,F#1,G1,G#1,A1,A#1,B1,C2,C#2,D2,D#2,E2,F2,F#2,G2,G#2,A2,A#2,B2,C3,C#3,D3,D#3,E3,F3,F#3,G3,G#3,A3,A#3,B3,C4,C#4,D4,D#4,E4,F4,F#4,G4,G#4,A4,A#4,B4,C5,C#5,D5,D#5,E5,F5,F#5,G5,G#5,A5,A#5,B5,C6,C#6,D6,D#6,E6,F6,F#6,G6,G#6,A6,A#6,B6,C7,C#7,D7,D#7,E7,F7,F#7,G7,G#7,A7,A#7,B7,C8,C#8,D8,D#8,E8,F8,F#8,G8}>Pitch
slider5:1<0,2,.001>Output Level*
slider6:0<0,3,1{Sawtooth,Triangle,Pulse,White Noise}>Wave Shape*
slider7:0.5<0.01,0.99,0.001>Pulse Width*
slider8:0.5<0.01,0.99,0.001>Pulse Width Modulation Range*
slider9:128<1,128,1>Highest Harmonic*
slider10:128<1,128,1>Highest Harmonic Modulation Range*
slider12:0<1,16,1{1 (fundamental),2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>Lowest Harmonic*
slider13:0<-4,4,1>Tune (octave)*
slider14:0<-12,12,1>Tune (semitone)*
slider15:0<-100,100,1>Fine Tune (cents)*
slider16:0<0,3>Portamento (sec)*
slider17:0<-1,1,0.001>Pitch Modulation Centre*
slider18:0<-1,1,0.001>Pitch Modulation Range*
slider19:0<0,3,1{Off,Frequency Modulation,Ring Modulation,Amplitude Modulation}>Audio Modulation*
slider20:0<0,3,1{None,Master,Slave}>Class
slider21:0<0,15,1{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>Class Group

options:gmem=ReRackAddOsc

@init
tau = $pi*2.0;
adj = tau*440/srate;
blkadj = tau*440/srate;
volcount = ceil(srate/100);
sliderbits = 2^5+2^6+2^7+2^8+2^9+2^10+2^12+2^13+2^14+2^15+2^16+2^17+2^18+2^19;

@slider
////////////////////////////Store slider values/////////////////
group = slider21*20;

slider20 == 1 ? (
//gmem[group+4] = slider4;
  gmem[group+5] = slider5;
  gmem[group+6] = slider6;
  gmem[group+7] = slider7;
  gmem[group+8] = slider8;
  gmem[group+9] = slider9;
  gmem[group+10] = slider10;
  gmem[group+12] = slider12;
  gmem[group+13] = slider13;
  gmem[group+14] = slider14;
  gmem[group+15] = slider15;
  gmem[group+16] = slider16;
  gmem[group+17] = slider17;
  gmem[group+18] = slider18;
  gmem[group+19] = slider19;
  );
  
@block
///////////////////////set slider values (slave mode)/////////////////////
slider20 == 2 ? ( 
  //slider4 = gmem[group+4];
  slider5 = gmem[group+5];
  slider6 = gmem[group+6];
  slider7 = gmem[group+7];
  slider8 = gmem[group+8];
  slider9 = gmem[group+9];
  slider10 = gmem[group+10];
  slider12 = gmem[group+12];
  slider13 = gmem[group+13];
  slider14 = gmem[group+14];
  slider15 = gmem[group+15];
  slider16 = gmem[group+16];
  slider17 = gmem[group+17];
  slider18 = gmem[group+18];
  slider19 = gmem[group+19];
  sliderchange(sliderbits);
);  

/////////////////////////Get slider values//////////////////////////
modcc = slider1-1;
pwcc = slider2-1;
harmcc = slider3-1;
pitch = slider4-1;
voltarget = slider5*0.5;
gvol = 1+(slider5/60);
shape = slider6;
pulsew = slider7*tau;
pwmodlev = slider8*tau;
maxh = slider9;
harmodlev = slider10;
countlimit = floor(srate*(slider11/1000));
harm = slider12+1;
detune = 2^(slider13 + slider14/12 + slider15/1200);
portaval = slider16;
modetune = 2^(slider17/127);
modcentre = slider17;
modlev = slider18;
modaudio = slider19;
volstep = (voltarget-prevol)/volcount;
volstepcount = volcount;

/////////////////////////portamento/////////////////////////
portastep = floor(max(1,((srate/samplesblock)*portaval)));

/////////////////////////MIDI pitch control/////////////////
pitch == -1 ? (
// MIDI keyboard pitch control
while (midirecv(offset, msg1, msg2, msg3))
(  
  // Extract message type and channel
  status = msg1 & $xF0;
  // Is it a note on event?
     status == $x90 ?
      (
       // Get note and velocity
       note = msg2 & $x7F;
       //velocity = msg3;
       // Note on
       freq = 2^((note-69)/12)*440*harm+2^detune;
       blkadjtarget = tau*freq/srate;
       adjstep = (blkadjtarget - blkadj)/portastep;
      //End of Get note and velocity
      ) : (
      // Not a note on event.
      // Is it a controller event?
      status == $xB0 ?
     (
      //Pitch Modulation
      // Is it the right CC?
      msg2 == modcc ?
       (
        modval = (msg3/63.5) - (1+modcentre);
        modlevel = modval * modlev;
        freq *=(1+modlevel);
        modadj = tau*freq/srate;
        );
        // Shape Modulation
        // Is it the right CC?
        msg2 == pwcc ?
        (
        //pwval = msg3 - pwmodcentre;
        pwval = (msg3/127);
        pw = pulsew+pwval*(pwmodlev-pulsew);
        );
         // Harmonics Modulation
         // Is it the right CC?
         msg2 == harmcc ?
         (
         harmval = (msg3/127);
         maxhout = maxh + floor(harmval*(harmodlev-maxh));   
        );
     ); 
   );
   // Pass through
   midisend(offset, msg1, msg2, msg3);                
);
blkadj != blkadjtarget ? ( blkadj += adjstep);

modcc == -1 ? modadj = 0;
pwcc == -1 ? pw = pulsew;
harmcc == -1 ? maxhout = maxh;
/////////////////////////Slider pitch control//////////////
) : (
       freq = 2^((pitch-69)/12)*440*harm*detune;
       blkadj = tau*freq/srate;
  while (midirecv(offset, msg1, msg2, msg3))
  (  
    // Extract message type and channel
    status = msg1 & $xF0;
     status == $xB0 ?
      (
      // Pitch Modulation
      // Is it the right CC?
          msg2 == modcc ?
         (
          modval = (msg3/63.5) - (1+modcentre);
          modlevel = modval * modlev;
          freq *=(1+modlevel);
          modadj = tau*freq/srate;
          );
          // Shape Modulation
          // Is it the right CC?
          msg2 == pwcc ?
          (
          pwval = (msg3/127);
          pw = pulsew+pwval*(pwmodlev-pulsew);
         );
          // Harmonics Modulation
          // Is it the right CC?
          msg2 == harmcc ?
          (
          harmval = (msg3/127);
          maxhout = maxh + floor(harmval*(harmodlev-maxh));     
         );
      );
      // Pass through
      midisend(offset, msg1, msg2, msg3); 
   );
blkadj != blkadjtarget ? ( blkadj += adjstep);

modcc == -1 ? modadj = 0;
pwcc == -1 ? pw = pulsew;
harmcc == -1 ? maxhout = maxh;
);
////////////////////////Step Change//////////////////////
modstep = (modadj-premod)/samplesblock;
outmod = premod;
premod = modadj;
pwstep = ((pw-prepw)/samplesblock);
outpw = prepw;
prepw = pw;
count = 0;

modadjspl = modadj;

@sample
cutoff = min(maxhout,floor(srate/(freq+freq)));
/////////////////////////Modulation Smoothing///////////////////
count > 0 ? (
  modadjspl += modstep;
  pulsewspl += pwstep;
  ):(
  modadjspl = outmod;
  pulsewspl = outpw;
  );
count += 1;

/////////////////////////Volume ramping/////////////////////////
vol != voltarget ?
(
  volstepcount >=0 ?
   (
    vol += volstep;
    volstepcount -= 1;
    ):(
    vol = voltarget; // Just to be sure!
    );
);

/////////////////////////////FM/////////////////////////////////
inlev = (spl0+spl1)/2;
modaudio == 2 ? adj = blkadj*(1+inlev)*10: adj = blkadj;
////////////////////////////Define waveforms////////////////////
shape == 0 ? (
    // Sawtooth
  sample = 0;
  wharm = 1;
    while(wharm <= cutoff)(
    nsample = sin(wharm*pos)/wharm;
    sample += nsample;
    wharm +=1;
    );
  ):(
shape == 1 ? (
    // Triangle
  sample = 0;
  wharm = 0;
    while(wharm <=((cutoff-1)/2))(
    nsample = -1^wharm*(sin((2*wharm+1)*pos)/(2*wharm+1)^2);
    sample += nsample;
    wharm +=1;
    );
    sample *= 16/$pi^2;    
  ):(
shape == 2 ? (
    // Pulse
  sample = 0;
  wharm = 1;
    while(wharm <= cutoff)(
    nsample = (2/(wharm*$pi))*sin((wharm*pulsewspl)/2)*cos(wharm*pos);
    sample += nsample;
    wharm +=1;
    );
    sample += (pulsewspl/tau);
    sample = $pi*sample-$pi/2;
    ):(
    // White noise
    sample =  2-rand(4);
    );
  );
);
cutcount += 1;
cutcount > countlimit? cutcount = countlimit + 1;
///////////////////////////////Audio output/////////////////////////////
freq < (srate/2.1) ? (
sample *= vol;
  modaudio == 0 ? (          //Unmodulated waveform
     spl0 = sample+spl0;
     spl1 = sample+spl1;
     )
     :
     (
    modaudio == 2 ? (        //Ring Modulation   
     spl0 = (sample*spl0);
     spl1 = (sample*spl1);
        )
        :
        (
         modaudio == 3 ? (   //Amplitude Modulation
         spl0 = ((0.5+(sample/2))*spl0);
         spl1 = ((0.5+(sample/2))*spl1);           
          )
          :
          (                  //Frequency Modulation
          spl0 = sample;
          spl1 = sample;
         );
      );
   );      
) : ( 
spl0 = spl0;
spl1 = spl1;
);

//////////Buffer results for graphics////////
looplen = srate/8;
bufflen = floor(looplen);
  bpos<=bufflen ? (
    bpos[0] = pos;
    modaudio == 0 ? (bpos+bufflen)[0] = sample:(bpos+bufflen)[0] = (spl0+spl1)/2;
    );
  
buffcount+=1;
buffcount > looplen ? (
  buffcount-=looplen;
  );
bpos=floor(buffcount);

////////Increment phase position///////////
pos=pos+adj+modadjspl;
(pos >= tau) ? pos -= tau;
prevol = vol;

/////////////////////////////////graphics//////////////////////////////////////
@gfx 400 140

sclx = 20;
scly = 50;
gfx_r = 0;
gfx_g = 1;
gfx_b = 0;
gfx_a = 1;

gpos = 1;
gfx_x = 25;
gfx_y = 40;
while (gpos <= bufflen)(
  gfx_x = 25+sclx*gpos[0];
  gfx_y = 40+scly+(scly/sqrt(2*voltarget))*(gpos+bufflen)[0];
  gfx_setpixel(0,1,0);
  gpos+=1;
);

gfx_x=gfx_y=5;
gfx_lineto(gfx_x, gfx_y,0);
gfx_r=gfx_b=0;
gfx_g=gfx_a=1;
gfx_drawstr("Base Frequency = ");
gfx_drawnumber(freq,0);
gfx_drawstr(" Hz, No. of Harmonics = ");
gfx_drawnumber(cutoff,0);
gfx_r = 1;
gfx_g = 0;
gfx_a = 0.5;
gfx_x = 25;
gfx_y = 40;
gfx_lineto(25+(sclx*tau),40);
gfx_x = 25;
gfx_y = 40+scly;
gfx_lineto(25+(sclx*tau),40+scly);
gfx_x = 25;
gfx_y = 40+scly+scly;
gfx_lineto(25+(sclx*tau),40+scly+scly);
gfx_a =1;
gfx_x = 13;
gfx_y = 35;
gfx_drawstr("1");
gfx_x = 13;
gfx_y = 35+scly;
gfx_drawstr("0");
gfx_x = 5;
gfx_y = 35+scly+scly;
gfx_drawstr("-1");

